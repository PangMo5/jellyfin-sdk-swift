// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var syncPlay: SyncPlay {
        SyncPlay(path: "/SyncPlay")
    }

    public struct SyncPlay {
        /// Path: `/SyncPlay`
        public let path: String
    }
}

extension Paths.SyncPlay {
    public var ready: Ready {
        Ready(path: path + "/Ready")
    }

    public struct Ready {
        /// Path: `/SyncPlay/Ready`
        public let path: String

        /// Notify SyncPlay group that member is ready for playback.
        public func post(_ body: JellyfinAPI.ReadyRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.SyncPlay {
    public var stop: Stop {
        Stop(path: path + "/Stop")
    }

    public struct Stop {
        /// Path: `/SyncPlay/Stop`
        public let path: String

        /// Request stop in SyncPlay group.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths {
    public static var library: Library {
        Library(path: "/Library")
    }

    public struct Library {
        /// Path: `/Library`
        public let path: String
    }
}

extension Paths.Library {
    public var movies: Movies {
        Movies(path: path + "/Movies")
    }

    public struct Movies {
        /// Path: `/Library/Movies`
        public let path: String
    }
}

extension Paths.Library.Movies {
    public var added: Added {
        Added(path: path + "/Added")
    }

    public struct Added {
        /// Path: `/Library/Movies/Added`
        public let path: String

        /// Reports that new movies have been added by an external source.
        public func post(tmdbID: String? = nil, imdbID: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(tmdbID, imdbID))
        }

        private func makePostQuery(_ tmdbID: String?, _ imdbID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tmdbID, forKey: "tmdbId")
            encoder.encode(imdbID, forKey: "imdbId")
            return encoder.items
        }
    }
}

extension Paths.Users {
    public var authenticateWithQuickConnect: AuthenticateWithQuickConnect {
        AuthenticateWithQuickConnect(path: path + "/AuthenticateWithQuickConnect")
    }

    public struct AuthenticateWithQuickConnect {
        /// Path: `/Users/AuthenticateWithQuickConnect`
        public let path: String

        /// Authenticates a user with quick connect.
        public func post(_ body: JellyfinAPI.QuickConnectDto) -> Request<JellyfinAPI.AuthenticationResult> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var system: System {
        System(path: "/System")
    }

    public struct System {
        /// Path: `/System`
        public let path: String
    }
}

extension Paths.System {
    public var mediaEncoder: MediaEncoder {
        MediaEncoder(path: path + "/MediaEncoder")
    }

    public struct MediaEncoder {
        /// Path: `/System/MediaEncoder`
        public let path: String
    }
}

extension Paths.System.MediaEncoder {
    public var path: Path {
        Path(path: path + "/Path")
    }

    public struct Path {
        /// Path: `/System/MediaEncoder/Path`
        public let path: String

        /// Updates the path to the media encoder.
        public func post(_ body: JellyfinAPI.MediaEncoderPathDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var images: Images {
        Images(path: "/Images")
    }

    public struct Images {
        /// Path: `/Images`
        public let path: String
    }
}

extension Paths.Images {
    public var general: General {
        General(path: path + "/General")
    }

    public struct General {
        /// Path: `/Images/General`
        public let path: String

        /// Get all general images.
        public var get: Request<[JellyfinAPI.ImageByNameInfo]> {
            .get(path)
        }
    }
}

extension Paths.Library.VirtualFolders {
    public var paths: Paths {
        Paths(path: path + "/Paths")
    }

    public struct Paths {
        /// Path: `/Library/VirtualFolders/Paths`
        public let path: String

        /// Add a media path to a library.
        public func post(isRefreshLibrary: Bool? = nil, _ body: JellyfinAPI.MediaPathDto) -> Request<Void> {
            .post(path, query: makePostQuery(isRefreshLibrary), body: body)
        }

        private func makePostQuery(_ isRefreshLibrary: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
            return encoder.items
        }

        /// Remove a media path.
        public func delete(parameters: DeleteParameters? = nil) -> Request<Void> {
            .delete(path, query: parameters?.asQuery)
        }

        public struct DeleteParameters {
            /// The name of the library.
            public var name: String?
            /// The path to remove.
            public var path: String?
            /// Whether to refresh the library.
            public var isRefreshLibrary: Bool?

            public init(name: String? = nil, path: String? = nil, isRefreshLibrary: Bool? = nil) {
                self.name = name
                self.path = path
                self.isRefreshLibrary = isRefreshLibrary
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(path, forKey: "path")
                encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var liveTv: LiveTv {
        LiveTv(path: "/LiveTv")
    }

    public struct LiveTv {
        /// Path: `/LiveTv`
        public let path: String
    }
}

extension Paths.LiveTv.ListingProviders {
    public var `default`: Default {
        Default(path: path + "/Default")
    }

    public struct Default {
        /// Path: `/LiveTv/ListingProviders/Default`
        public let path: String

        /// Gets default listings provider info.
        public var get: Request<JellyfinAPI.ListingsProviderInfo> {
            .get(path)
        }
    }
}

extension Paths.SyncPlay {
    public var setNewQueue: SetNewQueue {
        SetNewQueue(path: path + "/SetNewQueue")
    }

    public struct SetNewQueue {
        /// Path: `/SyncPlay/SetNewQueue`
        public let path: String

        /// Request to set new playlist in SyncPlay group.
        public func post(_ body: JellyfinAPI.PlayRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Items.WithItemID {
    public var contentType: ContentType {
        ContentType(path: path + "/ContentType")
    }

    public struct ContentType {
        /// Path: `/Items/{itemId}/ContentType`
        public let path: String

        /// Updates an item's content type.
        public func post(contentType: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(contentType))
        }

        private func makePostQuery(_ contentType: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(contentType, forKey: "contentType")
            return encoder.items
        }
    }
}

extension Paths {
    public static var videos: Videos {
        Videos(path: "/Videos")
    }

    public struct Videos {
        /// Path: `/Videos`
        public let path: String
    }
}

extension Paths.Videos {
    public func videoID(_ videoID: String) -> WithVideoID {
        WithVideoID(path: "\(path)/\(videoID)")
    }

    public struct WithVideoID {
        /// Path: `/Videos/{videoId}`
        public let path: String
    }
}

extension Paths.Videos.WithVideoID {
    public func mediaSourceID(_ mediaSourceID: String) -> WithMediaSourceID {
        WithMediaSourceID(path: "\(path)/\(mediaSourceID)")
    }

    public struct WithMediaSourceID {
        /// Path: `/Videos/{videoId}/{mediaSourceId}`
        public let path: String
    }
}

extension Paths.Videos.WithVideoID.WithMediaSourceID {
    public var attachments: Attachments {
        Attachments(path: path + "/Attachments")
    }

    public struct Attachments {
        /// Path: `/Videos/{videoId}/{mediaSourceId}/Attachments`
        public let path: String
    }
}

extension Paths.Videos.WithVideoID.WithMediaSourceID.Attachments {
    public func index(_ index: Int) -> WithIndex {
        WithIndex(path: "\(path)/\(index)")
    }

    public struct WithIndex {
        /// Path: `/Videos/{videoId}/{mediaSourceId}/Attachments/{index}`
        public let path: String

        /// Get video attachment.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.System {
    public var logs: Logs {
        Logs(path: path + "/Logs")
    }

    public struct Logs {
        /// Path: `/System/Logs`
        public let path: String

        /// Gets a list of available server log files.
        public var get: Request<[JellyfinAPI.LogFile]> {
            .get(path)
        }
    }
}

extension Paths.Plugins.WithPluginID {
    public func version(_ version: String) -> WithVersion {
        WithVersion(path: "\(path)/\(version)")
    }

    public struct WithVersion {
        /// Path: `/Plugins/{pluginId}/{version}`
        public let path: String

        /// Uninstalls a plugin by version.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var playingItems: PlayingItems {
        PlayingItems(path: path + "/PlayingItems")
    }

    public struct PlayingItems {
        /// Path: `/Users/{userId}/PlayingItems`
        public let path: String
    }
}

extension Paths.Users.WithUserID.PlayingItems.WithItemID {
    public var progress: Progress {
        Progress(path: path + "/Progress")
    }

    public struct Progress {
        /// Path: `/Users/{userId}/PlayingItems/{itemId}/Progress`
        public let path: String

        /// Reports a user's playback progress.
        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            /// The id of the MediaSource.
            public var mediaSourceID: String?
            /// Optional. The current position, in ticks. 1 tick = 10000 ms.
            public var positionTicks: Int?
            /// The audio stream index.
            public var audioStreamIndex: Int?
            /// The subtitle stream index.
            public var subtitleStreamIndex: Int?
            /// Scale of 0-100.
            public var volumeLevel: Int?
            /// The play method.
            public var playMethod: PlayMethod?
            /// The live stream id.
            public var liveStreamID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The repeat mode.
            public var repeatMode: RepeatMode?
            /// Indicates if the player is paused.
            public var isPaused: Bool?
            /// Indicates if the player is muted.
            public var isMuted: Bool?

            public typealias PlayMethod = JellyfinAPI.PlayMethod

            public typealias RepeatMode = JellyfinAPI.RepeatMode

            public init(mediaSourceID: String? = nil, positionTicks: Int? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, volumeLevel: Int? = nil, playMethod: PlayMethod? = nil, liveStreamID: String? = nil, playSessionID: String? = nil, repeatMode: RepeatMode? = nil, isPaused: Bool? = nil, isMuted: Bool? = nil) {
                self.mediaSourceID = mediaSourceID
                self.positionTicks = positionTicks
                self.audioStreamIndex = audioStreamIndex
                self.subtitleStreamIndex = subtitleStreamIndex
                self.volumeLevel = volumeLevel
                self.playMethod = playMethod
                self.liveStreamID = liveStreamID
                self.playSessionID = playSessionID
                self.repeatMode = repeatMode
                self.isPaused = isPaused
                self.isMuted = isMuted
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(positionTicks, forKey: "positionTicks")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(volumeLevel, forKey: "volumeLevel")
                encoder.encode(playMethod, forKey: "playMethod")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(repeatMode, forKey: "repeatMode")
                encoder.encode(isPaused, forKey: "isPaused")
                encoder.encode(isMuted, forKey: "isMuted")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var dlna: Dlna {
        Dlna(path: "/Dlna")
    }

    public struct Dlna {
        /// Path: `/Dlna`
        public let path: String
    }
}

extension Paths.Dlna.Profiles {
    public func profileID(_ profileID: String) -> WithProfileID {
        WithProfileID(path: "\(path)/\(profileID)")
    }

    public struct WithProfileID {
        /// Path: `/Dlna/Profiles/{profileId}`
        public let path: String

        /// Gets a single profile.
        public var get: Request<JellyfinAPI.DeviceProfile> {
            .get(path)
        }

        /// Updates a profile.
        public func post(_ body: JellyfinAPI.DeviceProfile? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Deletes a profile.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.LiveTv.Recordings {
    public func recordingID(_ recordingID: String) -> WithRecordingID {
        WithRecordingID(path: "\(path)/\(recordingID)")
    }

    public struct WithRecordingID {
        /// Path: `/LiveTv/Recordings/{recordingId}`
        public let path: String

        /// Gets a live tv recording.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }

        /// Deletes a live tv recording.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var startup: Startup {
        Startup(path: "/Startup")
    }

    public struct Startup {
        /// Path: `/Startup`
        public let path: String
    }
}

extension Paths.Startup {
    public var remoteAccess: RemoteAccess {
        RemoteAccess(path: path + "/RemoteAccess")
    }

    public struct RemoteAccess {
        /// Path: `/Startup/RemoteAccess`
        public let path: String

        /// Sets remote access and UPnP.
        public func post(_ body: JellyfinAPI.StartupRemoteAccessDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.LiveTv.TunerHosts {
    public var types: Types {
        Types(path: path + "/Types")
    }

    public struct Types {
        /// Path: `/LiveTv/TunerHosts/Types`
        public let path: String

        /// Get tuner host types.
        public var get: Request<[JellyfinAPI.NameIDPair]> {
            .get(path)
        }
    }
}

extension Paths.ScheduledTasks {
    public func taskID(_ taskID: String) -> WithTaskID {
        WithTaskID(path: "\(path)/\(taskID)")
    }

    public struct WithTaskID {
        /// Path: `/ScheduledTasks/{taskId}`
        public let path: String

        /// Get task by id.
        public var get: Request<JellyfinAPI.TaskInfo> {
            .get(path)
        }
    }
}

extension Paths.Sessions.Capabilities {
    public var full: Full {
        Full(path: path + "/Full")
    }

    public struct Full {
        /// Path: `/Sessions/Capabilities/Full`
        public let path: String

        /// Updates capabilities for a device.
        public func post(id: String? = nil, _ body: JellyfinAPI.ClientCapabilitiesDto) -> Request<Void> {
            .post(path, query: makePostQuery(id), body: body)
        }

        private func makePostQuery(_ id: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            return encoder.items
        }
    }
}

extension Paths {
    public static var scheduledTasks: ScheduledTasks {
        ScheduledTasks(path: "/ScheduledTasks")
    }

    public struct ScheduledTasks {
        /// Path: `/ScheduledTasks`
        public let path: String

        /// Get tasks.
        public func get(isHidden: Bool? = nil, isEnabled: Bool? = nil) -> Request<[JellyfinAPI.TaskInfo]> {
            .get(path, query: makeGetQuery(isHidden, isEnabled))
        }

        private func makeGetQuery(_ isHidden: Bool?, _ isEnabled: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isHidden, forKey: "isHidden")
            encoder.encode(isEnabled, forKey: "isEnabled")
            return encoder.items
        }
    }
}

extension Paths.Items {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/Items/{id}`
        public let path: String
    }
}

extension Paths.Items.WithID {
    public var instantMix: InstantMix {
        InstantMix(path: path + "/InstantMix")
    }

    public struct InstantMix {
        /// Path: `/Items/{id}/InstantMix`
        public let path: String

        /// Creates an instant playlist based on a given item.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.userID = userID
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }
    }
}

extension Paths.LiveTv {
    public var tuners: Tuners {
        Tuners(path: path + "/Tuners")
    }

    public struct Tuners {
        /// Path: `/LiveTv/Tuners`
        public let path: String
    }
}

extension Paths.LiveTv.Tuners {
    public var discvover: Discvover {
        Discvover(path: path + "/Discvover")
    }

    public struct Discvover {
        /// Path: `/LiveTv/Tuners/Discvover`
        public let path: String

        /// Discover tuners.
        public func get(isNewDevicesOnly: Bool? = nil) -> Request<[JellyfinAPI.TunerHostInfo]> {
            .get(path, query: makeGetQuery(isNewDevicesOnly))
        }

        private func makeGetQuery(_ isNewDevicesOnly: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isNewDevicesOnly, forKey: "newDevicesOnly")
            return encoder.items
        }
    }
}

extension Paths {
    public static var audio: Audio {
        Audio(path: "/Audio")
    }

    public struct Audio {
        /// Path: `/Audio`
        public let path: String
    }
}

extension Paths.Audio {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Audio/{itemId}`
        public let path: String
    }
}

extension Paths.Audio.WithItemID {
    public var hls1: Hls1 {
        Hls1(path: path + "/hls1")
    }

    public struct Hls1 {
        /// Path: `/Audio/{itemId}/hls1`
        public let path: String
    }
}

extension Paths.Audio.WithItemID.Hls1 {
    public func playlistID(_ playlistID: String) -> WithPlaylistID {
        WithPlaylistID(path: "\(path)/\(playlistID)")
    }

    public struct WithPlaylistID {
        /// Path: `/Audio/{itemId}/hls1/{playlistId}`
        public let path: String
    }
}

extension Paths.Audio.WithItemID.Hls1.WithPlaylistID {
    public func segmentID(_ segmentID: Int) -> WithContainer {
        WithContainer(path: "\(path)/\(segmentID).{container}")
    }

    public struct WithContainer {
        /// Path: `/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}`
        public let path: String

        /// Gets a video stream using HTTP live streaming.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. The maximum streaming bitrate.
            public var maxStreamingBitrate: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.maxStreamingBitrate = maxStreamingBitrate
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }
    }
}

extension Paths.Dlna {
    public func serverID(_ serverID: String) -> WithServerID {
        WithServerID(path: "\(path)/\(serverID)")
    }

    public struct WithServerID {
        /// Path: `/Dlna/{serverId}`
        public let path: String
    }
}

extension Paths.Dlna.WithServerID.ConnectionManager {
    public var control: Control {
        Control(path: path + "/Control")
    }

    public struct Control {
        /// Path: `/Dlna/{serverId}/ConnectionManager/Control`
        public let path: String

        /// Process a connection manager control request.
        public var post: Request<String> {
            .post(path)
        }
    }
}

extension Paths.Sessions {
    public func sessionID(_ sessionID: String) -> WithSessionID {
        WithSessionID(path: "\(path)/\(sessionID)")
    }

    public struct WithSessionID {
        /// Path: `/Sessions/{sessionId}`
        public let path: String
    }
}

extension Paths.Sessions.WithSessionID {
    public var viewing: Viewing {
        Viewing(path: path + "/Viewing")
    }

    public struct Viewing {
        /// Path: `/Sessions/{sessionId}/Viewing`
        public let path: String

        /// Instructs a session to browse to an item or view.
        public func post(parameters: PostParameters) -> Request<Void> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            /// The type of item to browse to.
            public var itemType: String
            /// The Id of the item.
            public var itemID: String
            /// The name of the item.
            public var itemName: String

            public init(itemType: String, itemID: String, itemName: String) {
                self.itemType = itemType
                self.itemID = itemID
                self.itemName = itemName
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(itemType, forKey: "itemType")
                encoder.encode(itemID, forKey: "itemId")
                encoder.encode(itemName, forKey: "itemName")
                return encoder.items
            }
        }
    }
}

extension Paths.SyncPlay {
    public var removeFromPlaylist: RemoveFromPlaylist {
        RemoveFromPlaylist(path: path + "/RemoveFromPlaylist")
    }

    public struct RemoveFromPlaylist {
        /// Path: `/SyncPlay/RemoveFromPlaylist`
        public let path: String

        /// Request to remove items from the playlist in SyncPlay group.
        public func post(_ body: JellyfinAPI.RemoveFromPlaylistRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var notifications: Notifications {
        Notifications(path: "/Notifications")
    }

    public struct Notifications {
        /// Path: `/Notifications`
        public let path: String
    }
}

extension Paths.Notifications.WithUserID {
    public var read: Read {
        Read(path: path + "/Read")
    }

    public struct Read {
        /// Path: `/Notifications/{userId}/Read`
        public let path: String

        /// Sets notifications as read.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Videos {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Videos/{itemId}`
        public let path: String
    }
}

extension Paths.Videos.WithItemID {
    public var mainM3u8: MainM3u8 {
        MainM3u8(path: path + "/main.m3u8")
    }

    public struct MainM3u8 {
        /// Path: `/Videos/{itemId}/main.m3u8`
        public let path: String

        /// Gets a video stream using HTTP live streaming.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }
    }
}

extension Paths.MusicGenres {
    public var instantMix: InstantMix {
        InstantMix(path: path + "/InstantMix")
    }

    public struct InstantMix {
        /// Path: `/MusicGenres/InstantMix`
        public let path: String

        /// Creates an instant playlist based on a given genre.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// The item id.
            public var id: String
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(id: String, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.id = id
                self.userID = userID
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(id, forKey: "id")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }
    }
}

extension Paths.Packages {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/Packages/{name}`
        public let path: String

        /// Gets a package by name or assembly GUID.
        public func get(assemblyGuid: String? = nil) -> Request<JellyfinAPI.PackageInfo> {
            .get(path, query: makeGetQuery(assemblyGuid))
        }

        private func makeGetQuery(_ assemblyGuid: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(assemblyGuid, forKey: "assemblyGuid")
            return encoder.items
        }
    }
}

extension Paths.Library.VirtualFolders {
    public var name: Name {
        Name(path: path + "/Name")
    }

    public struct Name {
        /// Path: `/Library/VirtualFolders/Name`
        public let path: String

        /// Renames a virtual folder.
        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            /// The name of the virtual folder.
            public var name: String?
            /// The new name.
            public var newName: String?
            /// Whether to refresh the library.
            public var isRefreshLibrary: Bool?

            public init(name: String? = nil, newName: String? = nil, isRefreshLibrary: Bool? = nil) {
                self.name = name
                self.newName = newName
                self.isRefreshLibrary = isRefreshLibrary
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(newName, forKey: "newName")
                encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
                return encoder.items
            }
        }
    }
}

extension Paths.Items {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Items/{itemId}`
        public let path: String

        /// Updates an item.
        public func post(_ body: JellyfinAPI.BaseItemDto) -> Request<Void> {
            .post(path, body: body)
        }

        /// Deletes an item from the library and filesystem.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Items {
    public var remoteSearch: RemoteSearch {
        RemoteSearch(path: path + "/RemoteSearch")
    }

    public struct RemoteSearch {
        /// Path: `/Items/RemoteSearch`
        public let path: String
    }
}

extension Paths.Items.RemoteSearch {
    public var musicVideo: MusicVideo {
        MusicVideo(path: path + "/MusicVideo")
    }

    public struct MusicVideo {
        /// Path: `/Items/RemoteSearch/MusicVideo`
        public let path: String

        /// Get music video remote search.
        public func post(_ body: JellyfinAPI.MusicVideoInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Artists {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Artists/{itemId}`
        public let path: String
    }
}

extension Paths.Artists.WithItemID {
    public var similar: Similar {
        Similar(path: path + "/Similar")
    }

    public struct Similar {
        /// Path: `/Artists/{itemId}/Similar`
        public let path: String

        /// Gets similar items.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Exclude artist ids.
            public var excludeArtistIDs: [String]?
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
            public var fields: [JellyfinAPI.ItemFields]?

            public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
                self.excludeArtistIDs = excludeArtistIDs
                self.userID = userID
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithItemID.RemoteImages {
    public var providers: Providers {
        Providers(path: path + "/Providers")
    }

    public struct Providers {
        /// Path: `/Items/{itemId}/RemoteImages/Providers`
        public let path: String

        /// Gets available remote image providers for an item.
        public var get: Request<[JellyfinAPI.ImageProviderInfo]> {
            .get(path)
        }
    }
}

extension Paths.Library {
    public var virtualFolders: VirtualFolders {
        VirtualFolders(path: path + "/VirtualFolders")
    }

    public struct VirtualFolders {
        /// Path: `/Library/VirtualFolders`
        public let path: String

        /// Gets all virtual folders.
        public var get: Request<[JellyfinAPI.VirtualFolderInfo]> {
            .get(path)
        }

        /// Adds a virtual folder.
        public func post(parameters: PostParameters? = nil, _ body: JellyfinAPI.AddVirtualFolderDto? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            /// The name of the virtual folder.
            public var name: String?
            /// The type of the collection.
            public var collectionType: CollectionType?
            /// The paths of the virtual folder.
            public var paths: [String]?
            /// Whether to refresh the library.
            public var isRefreshLibrary: Bool?

            public typealias CollectionType = JellyfinAPI.CollectionTypeOptions

            public init(name: String? = nil, collectionType: CollectionType? = nil, paths: [String]? = nil, isRefreshLibrary: Bool? = nil) {
                self.name = name
                self.collectionType = collectionType
                self.paths = paths
                self.isRefreshLibrary = isRefreshLibrary
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(collectionType, forKey: "collectionType")
                encoder.encode(paths, forKey: "paths")
                encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
                return encoder.items
            }
        }

        /// Removes a virtual folder.
        public func delete(name: String? = nil, isRefreshLibrary: Bool? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(name, isRefreshLibrary))
        }

        private func makeDeleteQuery(_ name: String?, _ isRefreshLibrary: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(name, forKey: "name")
            encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
            return encoder.items
        }
    }
}

extension Paths.Artists {
    public var instantMix: InstantMix {
        InstantMix(path: path + "/InstantMix")
    }

    public struct InstantMix {
        /// Path: `/Artists/InstantMix`
        public let path: String

        /// Creates an instant playlist based on a given artist.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// The item id.
            public var id: String
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(id: String, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.id = id
                self.userID = userID
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(id, forKey: "id")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var authenticate: Authenticate {
        Authenticate(path: path + "/Authenticate")
    }

    public struct Authenticate {
        /// Path: `/Users/{userId}/Authenticate`
        public let path: String

        /// Authenticates a user.
        public func post(pw: String, password: String? = nil) -> Request<JellyfinAPI.AuthenticationResult> {
            .post(path, query: makePostQuery(pw, password))
        }

        private func makePostQuery(_ pw: String, _ password: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pw, forKey: "pw")
            encoder.encode(password, forKey: "password")
            return encoder.items
        }
    }
}

extension Paths.Dlna.WithServerID {
    public var mediaReceiverRegistrar: MediaReceiverRegistrar {
        MediaReceiverRegistrar(path: path + "/MediaReceiverRegistrar")
    }

    public struct MediaReceiverRegistrar {
        /// Path: `/Dlna/{serverId}/MediaReceiverRegistrar`
        public let path: String

        /// Gets Dlna media receiver registrar xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var branding: Branding {
        Branding(path: "/Branding")
    }

    public struct Branding {
        /// Path: `/Branding`
        public let path: String
    }
}

extension Paths.Branding {
    public var configuration: Configuration {
        Configuration(path: path + "/Configuration")
    }

    public struct Configuration {
        /// Path: `/Branding/Configuration`
        public let path: String

        /// Gets branding configuration.
        public var get: Request<JellyfinAPI.BrandingOptions> {
            .get(path)
        }
    }
}

extension Paths.LiveTv.Tuners {
    public func tunerID(_ tunerID: String) -> WithTunerID {
        WithTunerID(path: "\(path)/\(tunerID)")
    }

    public struct WithTunerID {
        /// Path: `/LiveTv/Tuners/{tunerId}`
        public let path: String
    }
}

extension Paths.LiveTv.Tuners.WithTunerID {
    public var reset: Reset {
        Reset(path: path + "/Reset")
    }

    public struct Reset {
        /// Path: `/LiveTv/Tuners/{tunerId}/Reset`
        public let path: String

        /// Resets a tv tuner.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths {
    public static var localization: Localization {
        Localization(path: "/Localization")
    }

    public struct Localization {
        /// Path: `/Localization`
        public let path: String
    }
}

extension Paths.Localization {
    public var parentalRatings: ParentalRatings {
        ParentalRatings(path: path + "/ParentalRatings")
    }

    public struct ParentalRatings {
        /// Path: `/Localization/ParentalRatings`
        public let path: String

        /// Gets known parental ratings.
        public var get: Request<[JellyfinAPI.ParentalRating]> {
            .get(path)
        }
    }
}

extension Paths.Items.WithItemID {
    public var themeVideos: ThemeVideos {
        ThemeVideos(path: path + "/ThemeVideos")
    }

    public struct ThemeVideos {
        /// Path: `/Items/{itemId}/ThemeVideos`
        public let path: String

        /// Get theme videos for an item.
        public func get(userID: String? = nil, isInheritFromParent: Bool? = nil) -> Request<JellyfinAPI.ThemeMediaResult> {
            .get(path, query: makeGetQuery(userID, isInheritFromParent))
        }

        private func makeGetQuery(_ userID: String?, _ isInheritFromParent: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(isInheritFromParent, forKey: "inheritFromParent")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var items: Items {
        Items(path: path + "/Items")
    }

    public struct Items {
        /// Path: `/Users/{userId}/Items`
        public let path: String

        /// Gets items based on a query.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
            public var maxOfficialRating: String?
            /// Optional filter by items with theme songs.
            public var hasThemeSong: Bool?
            /// Optional filter by items with theme videos.
            public var hasThemeVideo: Bool?
            /// Optional filter by items with subtitles.
            public var hasSubtitles: Bool?
            /// Optional filter by items with special features.
            public var hasSpecialFeature: Bool?
            /// Optional filter by items with trailers.
            public var hasTrailer: Bool?
            /// Optional. Return items that are siblings of a supplied item.
            public var adjacentTo: String?
            /// Optional filter by parent index number.
            public var parentIndexNumber: Int?
            /// Optional filter by items that have or do not have a parental rating.
            public var hasParentalRating: Bool?
            /// Optional filter by items that are HD or not.
            public var isHd: Bool?
            /// Optional filter by items that are 4K or not.
            public var isIs4K: Bool?
            /// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
            public var locationTypes: [JellyfinAPI.LocationType]?
            /// Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
            public var excludeLocationTypes: [JellyfinAPI.LocationType]?
            /// Optional filter by items that are missing episodes or not.
            public var isMissing: Bool?
            /// Optional filter by items that are unaired episodes or not.
            public var isUnaired: Bool?
            /// Optional filter by minimum community rating.
            public var minCommunityRating: Double?
            /// Optional filter by minimum critic rating.
            public var minCriticRating: Double?
            /// Optional. The minimum premiere date. Format = ISO.
            public var minPremiereDate: Date?
            /// Optional. The minimum last saved date. Format = ISO.
            public var minDateLastSaved: Date?
            /// Optional. The minimum last saved date for the current user. Format = ISO.
            public var minDateLastSavedForUser: Date?
            /// Optional. The maximum premiere date. Format = ISO.
            public var maxPremiereDate: Date?
            /// Optional filter by items that have an overview or not.
            public var hasOverview: Bool?
            /// Optional filter by items that have an imdb id or not.
            public var hasImdbID: Bool?
            /// Optional filter by items that have a tmdb id or not.
            public var hasTmdbID: Bool?
            /// Optional filter by items that have a tvdb id or not.
            public var hasTvdbID: Bool?
            /// Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
            public var excludeItemIDs: [String]?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// When searching within folders, this determines whether or not the search will be recursive. true/false.
            public var isRecursive: Bool?
            /// Optional. Filter based on a search term.
            public var searchTerm: String?
            /// Sort Order - Ascending,Descending.
            public var sortOrder: [JellyfinAPI.SortOrder]?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
            public var excludeItemTypes: [String]?
            /// Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
            public var includeItemTypes: [String]?
            /// Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
            public var filters: [JellyfinAPI.ItemFilter]?
            /// Optional filter by items that are marked as favorite, or not.
            public var isFavorite: Bool?
            /// Optional filter by MediaType. Allows multiple, comma delimited.
            public var mediaTypes: [String]?
            /// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
            public var imageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
            public var sortBy: [String]?
            /// Optional filter by items that are played, or not.
            public var isPlayed: Bool?
            /// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
            public var genres: [String]?
            /// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
            public var officialRatings: [String]?
            /// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
            public var tags: [String]?
            /// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
            public var years: [Int]?
            /// Optional, include user data.
            public var enableUserData: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. If specified, results will be filtered to include only those containing the specified person.
            public var person: String?
            /// Optional. If specified, results will be filtered to include only those containing the specified person id.
            public var personIDs: [String]?
            /// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
            public var personTypes: [String]?
            /// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
            public var studios: [String]?
            /// Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
            public var artists: [String]?
            /// Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
            public var excludeArtistIDs: [String]?
            /// Optional. If specified, results will be filtered to include only those containing the specified artist id.
            public var artistIDs: [String]?
            /// Optional. If specified, results will be filtered to include only those containing the specified album artist id.
            public var albumArtistIDs: [String]?
            /// Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
            public var contributingArtistIDs: [String]?
            /// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
            public var albums: [String]?
            /// Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
            public var albumIDs: [String]?
            /// Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
            public var ids: [String]?
            /// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
            public var videoTypes: [JellyfinAPI.VideoType]?
            /// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
            public var minOfficialRating: String?
            /// Optional filter by items that are locked.
            public var isLocked: Bool?
            /// Optional filter by items that are placeholders.
            public var isPlaceHolder: Bool?
            /// Optional filter by items that have official ratings.
            public var hasOfficialRating: Bool?
            /// Whether or not to hide items behind their boxsets.
            public var isCollapseBoxSetItems: Bool?
            /// Optional. Filter by the minimum width of the item.
            public var minWidth: Int?
            /// Optional. Filter by the minimum height of the item.
            public var minHeight: Int?
            /// Optional. Filter by the maximum width of the item.
            public var maxWidth: Int?
            /// Optional. Filter by the maximum height of the item.
            public var maxHeight: Int?
            /// Optional filter by items that are 3D, or not.
            public var isIs3D: Bool?
            /// Optional filter by Series Status. Allows multiple, comma delimeted.
            public var seriesStatus: [JellyfinAPI.SeriesStatus]?
            /// Optional filter by items whose name is sorted equally or greater than a given input string.
            public var nameStartsWithOrGreater: String?
            /// Optional filter by items whose name is sorted equally than a given input string.
            public var nameStartsWith: String?
            /// Optional filter by items whose name is equally or lesser than a given input string.
            public var nameLessThan: String?
            /// Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
            public var studioIDs: [String]?
            /// Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
            public var genreIDs: [String]?
            /// Optional. Enable the total record count.
            public var enableTotalRecordCount: Bool?
            /// Optional, include image information in output.
            public var enableImages: Bool?

            public init(maxOfficialRating: String? = nil, hasThemeSong: Bool? = nil, hasThemeVideo: Bool? = nil, hasSubtitles: Bool? = nil, hasSpecialFeature: Bool? = nil, hasTrailer: Bool? = nil, adjacentTo: String? = nil, parentIndexNumber: Int? = nil, hasParentalRating: Bool? = nil, isHd: Bool? = nil, isIs4K: Bool? = nil, locationTypes: [JellyfinAPI.LocationType]? = nil, excludeLocationTypes: [JellyfinAPI.LocationType]? = nil, isMissing: Bool? = nil, isUnaired: Bool? = nil, minCommunityRating: Double? = nil, minCriticRating: Double? = nil, minPremiereDate: Date? = nil, minDateLastSaved: Date? = nil, minDateLastSavedForUser: Date? = nil, maxPremiereDate: Date? = nil, hasOverview: Bool? = nil, hasImdbID: Bool? = nil, hasTmdbID: Bool? = nil, hasTvdbID: Bool? = nil, excludeItemIDs: [String]? = nil, startIndex: Int? = nil, limit: Int? = nil, isRecursive: Bool? = nil, searchTerm: String? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, imageTypes: [JellyfinAPI.ImageType]? = nil, sortBy: [String]? = nil, isPlayed: Bool? = nil, genres: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, artists: [String]? = nil, excludeArtistIDs: [String]? = nil, artistIDs: [String]? = nil, albumArtistIDs: [String]? = nil, contributingArtistIDs: [String]? = nil, albums: [String]? = nil, albumIDs: [String]? = nil, ids: [String]? = nil, videoTypes: [JellyfinAPI.VideoType]? = nil, minOfficialRating: String? = nil, isLocked: Bool? = nil, isPlaceHolder: Bool? = nil, hasOfficialRating: Bool? = nil, isCollapseBoxSetItems: Bool? = nil, minWidth: Int? = nil, minHeight: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, isIs3D: Bool? = nil, seriesStatus: [JellyfinAPI.SeriesStatus]? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, studioIDs: [String]? = nil, genreIDs: [String]? = nil, enableTotalRecordCount: Bool? = nil, enableImages: Bool? = nil) {
                self.maxOfficialRating = maxOfficialRating
                self.hasThemeSong = hasThemeSong
                self.hasThemeVideo = hasThemeVideo
                self.hasSubtitles = hasSubtitles
                self.hasSpecialFeature = hasSpecialFeature
                self.hasTrailer = hasTrailer
                self.adjacentTo = adjacentTo
                self.parentIndexNumber = parentIndexNumber
                self.hasParentalRating = hasParentalRating
                self.isHd = isHd
                self.isIs4K = isIs4K
                self.locationTypes = locationTypes
                self.excludeLocationTypes = excludeLocationTypes
                self.isMissing = isMissing
                self.isUnaired = isUnaired
                self.minCommunityRating = minCommunityRating
                self.minCriticRating = minCriticRating
                self.minPremiereDate = minPremiereDate
                self.minDateLastSaved = minDateLastSaved
                self.minDateLastSavedForUser = minDateLastSavedForUser
                self.maxPremiereDate = maxPremiereDate
                self.hasOverview = hasOverview
                self.hasImdbID = hasImdbID
                self.hasTmdbID = hasTmdbID
                self.hasTvdbID = hasTvdbID
                self.excludeItemIDs = excludeItemIDs
                self.startIndex = startIndex
                self.limit = limit
                self.isRecursive = isRecursive
                self.searchTerm = searchTerm
                self.sortOrder = sortOrder
                self.parentID = parentID
                self.fields = fields
                self.excludeItemTypes = excludeItemTypes
                self.includeItemTypes = includeItemTypes
                self.filters = filters
                self.isFavorite = isFavorite
                self.mediaTypes = mediaTypes
                self.imageTypes = imageTypes
                self.sortBy = sortBy
                self.isPlayed = isPlayed
                self.genres = genres
                self.officialRatings = officialRatings
                self.tags = tags
                self.years = years
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.person = person
                self.personIDs = personIDs
                self.personTypes = personTypes
                self.studios = studios
                self.artists = artists
                self.excludeArtistIDs = excludeArtistIDs
                self.artistIDs = artistIDs
                self.albumArtistIDs = albumArtistIDs
                self.contributingArtistIDs = contributingArtistIDs
                self.albums = albums
                self.albumIDs = albumIDs
                self.ids = ids
                self.videoTypes = videoTypes
                self.minOfficialRating = minOfficialRating
                self.isLocked = isLocked
                self.isPlaceHolder = isPlaceHolder
                self.hasOfficialRating = hasOfficialRating
                self.isCollapseBoxSetItems = isCollapseBoxSetItems
                self.minWidth = minWidth
                self.minHeight = minHeight
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.isIs3D = isIs3D
                self.seriesStatus = seriesStatus
                self.nameStartsWithOrGreater = nameStartsWithOrGreater
                self.nameStartsWith = nameStartsWith
                self.nameLessThan = nameLessThan
                self.studioIDs = studioIDs
                self.genreIDs = genreIDs
                self.enableTotalRecordCount = enableTotalRecordCount
                self.enableImages = enableImages
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(maxOfficialRating, forKey: "maxOfficialRating")
                encoder.encode(hasThemeSong, forKey: "hasThemeSong")
                encoder.encode(hasThemeVideo, forKey: "hasThemeVideo")
                encoder.encode(hasSubtitles, forKey: "hasSubtitles")
                encoder.encode(hasSpecialFeature, forKey: "hasSpecialFeature")
                encoder.encode(hasTrailer, forKey: "hasTrailer")
                encoder.encode(adjacentTo, forKey: "adjacentTo")
                encoder.encode(parentIndexNumber, forKey: "parentIndexNumber")
                encoder.encode(hasParentalRating, forKey: "hasParentalRating")
                encoder.encode(isHd, forKey: "isHd")
                encoder.encode(isIs4K, forKey: "is4K")
                encoder.encode(locationTypes, forKey: "locationTypes")
                encoder.encode(excludeLocationTypes, forKey: "excludeLocationTypes")
                encoder.encode(isMissing, forKey: "isMissing")
                encoder.encode(isUnaired, forKey: "isUnaired")
                encoder.encode(minCommunityRating, forKey: "minCommunityRating")
                encoder.encode(minCriticRating, forKey: "minCriticRating")
                encoder.encode(minPremiereDate, forKey: "minPremiereDate")
                encoder.encode(minDateLastSaved, forKey: "minDateLastSaved")
                encoder.encode(minDateLastSavedForUser, forKey: "minDateLastSavedForUser")
                encoder.encode(maxPremiereDate, forKey: "maxPremiereDate")
                encoder.encode(hasOverview, forKey: "hasOverview")
                encoder.encode(hasImdbID, forKey: "hasImdbId")
                encoder.encode(hasTmdbID, forKey: "hasTmdbId")
                encoder.encode(hasTvdbID, forKey: "hasTvdbId")
                encoder.encode(excludeItemIDs, forKey: "excludeItemIds")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isRecursive, forKey: "recursive")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(sortOrder, forKey: "sortOrder")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(filters, forKey: "filters")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(mediaTypes, forKey: "mediaTypes")
                encoder.encode(imageTypes, forKey: "imageTypes")
                encoder.encode(sortBy, forKey: "sortBy")
                encoder.encode(isPlayed, forKey: "isPlayed")
                encoder.encode(genres, forKey: "genres")
                encoder.encode(officialRatings, forKey: "officialRatings")
                encoder.encode(tags, forKey: "tags")
                encoder.encode(years, forKey: "years")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(person, forKey: "person")
                encoder.encode(personIDs, forKey: "personIds")
                encoder.encode(personTypes, forKey: "personTypes")
                encoder.encode(studios, forKey: "studios")
                encoder.encode(artists, forKey: "artists")
                encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
                encoder.encode(artistIDs, forKey: "artistIds")
                encoder.encode(albumArtistIDs, forKey: "albumArtistIds")
                encoder.encode(contributingArtistIDs, forKey: "contributingArtistIds")
                encoder.encode(albums, forKey: "albums")
                encoder.encode(albumIDs, forKey: "albumIds")
                encoder.encode(ids, forKey: "ids")
                encoder.encode(videoTypes, forKey: "videoTypes")
                encoder.encode(minOfficialRating, forKey: "minOfficialRating")
                encoder.encode(isLocked, forKey: "isLocked")
                encoder.encode(isPlaceHolder, forKey: "isPlaceHolder")
                encoder.encode(hasOfficialRating, forKey: "hasOfficialRating")
                encoder.encode(isCollapseBoxSetItems, forKey: "collapseBoxSetItems")
                encoder.encode(minWidth, forKey: "minWidth")
                encoder.encode(minHeight, forKey: "minHeight")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(isIs3D, forKey: "is3D")
                encoder.encode(seriesStatus, forKey: "seriesStatus")
                encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
                encoder.encode(nameStartsWith, forKey: "nameStartsWith")
                encoder.encode(nameLessThan, forKey: "nameLessThan")
                encoder.encode(studioIDs, forKey: "studioIds")
                encoder.encode(genreIDs, forKey: "genreIds")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                encoder.encode(enableImages, forKey: "enableImages")
                return encoder.items
            }
        }
    }
}

extension Paths.Library {
    public var series: Series {
        Series(path: path + "/Series")
    }

    public struct Series {
        /// Path: `/Library/Series`
        public let path: String
    }
}

extension Paths.Library.Series {
    public var added: Added {
        Added(path: path + "/Added")
    }

    public struct Added {
        /// Path: `/Library/Series/Added`
        public let path: String

        /// Reports that new episodes of a series have been added by an external source.
        public func post(tvdbID: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(tvdbID))
        }

        private func makePostQuery(_ tvdbID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tvdbID, forKey: "tvdbId")
            return encoder.items
        }
    }
}

extension Paths.Startup {
    public var user: User {
        User(path: path + "/User")
    }

    public struct User {
        /// Path: `/Startup/User`
        public let path: String

        /// Gets the first user.
        public var get: Request<JellyfinAPI.StartupUserDto> {
            .get(path)
        }

        /// Sets the user name and password.
        public func post(_ body: JellyfinAPI.StartupUserDto? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Sessions.WithSessionID {
    public var command: Command {
        Command(path: path + "/Command")
    }

    public struct Command {
        /// Path: `/Sessions/{sessionId}/Command`
        public let path: String

        /// Issues a full general command to a client.
        public func post(_ body: JellyfinAPI.GeneralCommand) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Notifications.WithUserID {
    public var summary: Summary {
        Summary(path: path + "/Summary")
    }

    public struct Summary {
        /// Path: `/Notifications/{userId}/Summary`
        public let path: String

        /// Gets a user's notification summary.
        public var get: Request<JellyfinAPI.NotificationsSummaryDto> {
            .get(path)
        }
    }
}

extension Paths.Devices {
    public var info: Info {
        Info(path: path + "/Info")
    }

    public struct Info {
        /// Path: `/Devices/Info`
        public let path: String

        /// Get info for a device.
        public func get(id: String) -> Request<JellyfinAPI.DeviceInfo> {
            .get(path, query: [("id", id)])
        }
    }
}

extension Paths.Videos.WithItemID {
    public var hls1: Hls1 {
        Hls1(path: path + "/hls1")
    }

    public struct Hls1 {
        /// Path: `/Videos/{itemId}/hls1`
        public let path: String
    }
}

extension Paths.Videos.WithItemID.Hls1 {
    public func playlistID(_ playlistID: String) -> WithPlaylistID {
        WithPlaylistID(path: "\(path)/\(playlistID)")
    }

    public struct WithPlaylistID {
        /// Path: `/Videos/{itemId}/hls1/{playlistId}`
        public let path: String
    }
}

extension Paths.Videos.WithItemID.Hls1.WithPlaylistID {
    public func segmentID(_ segmentID: Int) -> WithContainer {
        WithContainer(path: "\(path)/\(segmentID).{container}")
    }

    public struct WithContainer {
        /// Path: `/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}`
        public let path: String

        /// Gets a video stream using HTTP live streaming.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment lenght.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var plugins: Plugins {
        Plugins(path: "/Plugins")
    }

    public struct Plugins {
        /// Path: `/Plugins`
        public let path: String

        /// Gets a list of currently installed plugins.
        public var get: Request<[JellyfinAPI.PluginInfo]> {
            .get(path)
        }
    }
}

extension Paths.MusicGenres {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/MusicGenres/{name}`
        public let path: String
    }
}

extension Paths.MusicGenres.WithName {
    public var images: Images {
        Images(path: path + "/Images")
    }

    public struct Images {
        /// Path: `/MusicGenres/{name}/Images`
        public let path: String
    }
}

extension Paths.MusicGenres.WithName.Images.WithImageType {
    public func imageIndex(_ imageIndex: Int) -> WithImageIndex {
        WithImageIndex(path: "\(path)/\(imageIndex)")
    }

    public struct WithImageIndex {
        /// Path: `/MusicGenres/{name}/Images/{imageType}/{imageIndex}`
        public let path: String

        /// Get music genre image by name.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }

        /// Get music genre image by name.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }
    }
}

extension Paths.Genres {
    public func genreName(_ genreName: String) -> WithGenreName {
        WithGenreName(path: "\(path)/\(genreName)")
    }

    public struct WithGenreName {
        /// Path: `/Genres/{genreName}`
        public let path: String

        /// Gets a genre, by name.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.Users {
    public var forgotPassword: ForgotPassword {
        ForgotPassword(path: path + "/ForgotPassword")
    }

    public struct ForgotPassword {
        /// Path: `/Users/ForgotPassword`
        public let path: String

        /// Initiates the forgot password process for a local user.
        public func post(_ body: JellyfinAPI.ForgotPasswordDto) -> Request<JellyfinAPI.ForgotPasswordResult> {
            .post(path, body: body)
        }
    }
}

extension Paths.Genres {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/Genres/{name}`
        public let path: String
    }
}

extension Paths.Genres.WithName {
    public var images: Images {
        Images(path: path + "/Images")
    }

    public struct Images {
        /// Path: `/Genres/{name}/Images`
        public let path: String
    }
}

extension Paths.Genres.WithName.Images {
    public func imageType(_ imageType: String) -> WithImageType {
        WithImageType(path: "\(path)/\(imageType)")
    }

    public struct WithImageType {
        /// Path: `/Genres/{name}/Images/{imageType}`
        public let path: String

        /// Get genre image by name.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }

        /// Get genre image by name.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }
    }
}

extension Paths.Dlna.WithServerID {
    public var icons: Icons {
        Icons(path: path + "/icons")
    }

    public struct Icons {
        /// Path: `/Dlna/{serverId}/icons`
        public let path: String
    }
}

extension Paths.Dlna.WithServerID.Icons {
    public func fileName(_ fileName: String) -> WithFileName {
        WithFileName(path: "\(path)/\(fileName)")
    }

    public struct WithFileName {
        /// Path: `/Dlna/{serverId}/icons/{fileName}`
        public let path: String

        /// Gets a server icon.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Audio.WithItemID {
    public var masterM3u8: MasterM3u8 {
        MasterM3u8(path: path + "/master.m3u8")
    }

    public struct MasterM3u8 {
        /// Path: `/Audio/{itemId}/master.m3u8`
        public let path: String

        /// Gets an audio hls playlist stream.
        public func get(parameters: GetParameters) -> Request<Data> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. The maximum streaming bitrate.
            public var maxStreamingBitrate: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?
            /// Enable adaptive bitrate streaming.
            public var enableAdaptiveBitrateStreaming: Bool?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, enableAdaptiveBitrateStreaming: Bool? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.maxStreamingBitrate = maxStreamingBitrate
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
                self.enableAdaptiveBitrateStreaming = enableAdaptiveBitrateStreaming
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                encoder.encode(enableAdaptiveBitrateStreaming, forKey: "enableAdaptiveBitrateStreaming")
                return encoder.items
            }
        }

        /// Gets an audio hls playlist stream.
        public func head(parameters: HeadParameters) -> Request<Data> {
            .head(path, query: parameters.asQuery)
        }

        public struct HeadParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. The maximum streaming bitrate.
            public var maxStreamingBitrate: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?
            /// Enable adaptive bitrate streaming.
            public var enableAdaptiveBitrateStreaming: Bool?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, enableAdaptiveBitrateStreaming: Bool? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.maxStreamingBitrate = maxStreamingBitrate
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
                self.enableAdaptiveBitrateStreaming = enableAdaptiveBitrateStreaming
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                encoder.encode(enableAdaptiveBitrateStreaming, forKey: "enableAdaptiveBitrateStreaming")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithUserID.Items.WithItemID {
    public var localTrailers: LocalTrailers {
        LocalTrailers(path: path + "/LocalTrailers")
    }

    public struct LocalTrailers {
        /// Path: `/Users/{userId}/Items/{itemId}/LocalTrailers`
        public let path: String

        /// Gets local trailers for an item.
        public var get: Request<[JellyfinAPI.BaseItemDto]> {
            .get(path)
        }
    }
}

extension Paths.Sessions.WithSessionID.Command {
    public func command(_ command: String) -> WithCommand {
        WithCommand(path: "\(path)/\(command)")
    }

    public struct WithCommand {
        /// Path: `/Sessions/{sessionId}/Command/{command}`
        public let path: String

        /// Issues a general command to a client.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var policy: Policy {
        Policy(path: path + "/Policy")
    }

    public struct Policy {
        /// Path: `/Users/{userId}/Policy`
        public let path: String

        /// Updates a user policy.
        public func post(_ body: JellyfinAPI.UserPolicy) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Items.WithItemID {
    public var ancestors: Ancestors {
        Ancestors(path: path + "/Ancestors")
    }

    public struct Ancestors {
        /// Path: `/Items/{itemId}/Ancestors`
        public let path: String

        /// Gets all parents of an item.
        public func get(userID: String? = nil) -> Request<[JellyfinAPI.BaseItemDto]> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.LiveTv.Recordings {
    public var series: Series {
        Series(path: path + "/Series")
    }

    public struct Series {
        /// Path: `/LiveTv/Recordings/Series`
        public let path: String

        /// Gets live tv recording series.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by channel id.
            public var channelID: String?
            /// Optional. Filter by user and attach user data.
            public var userID: String?
            /// Optional. Filter by recording group.
            public var groupID: String?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Filter by recording status.
            public var status: Status?
            /// Optional. Filter by recordings that are in progress, or not.
            public var isInProgress: Bool?
            /// Optional. Filter by recordings belonging to a series timer.
            public var seriesTimerID: String?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. Return total record count.
            public var enableTotalRecordCount: Bool?

            public typealias Status = JellyfinAPI.RecordingStatus

            public init(channelID: String? = nil, userID: String? = nil, groupID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, status: Status? = nil, isInProgress: Bool? = nil, seriesTimerID: String? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableUserData: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
                self.channelID = channelID
                self.userID = userID
                self.groupID = groupID
                self.startIndex = startIndex
                self.limit = limit
                self.status = status
                self.isInProgress = isInProgress
                self.seriesTimerID = seriesTimerID
                self.enableImages = enableImages
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.fields = fields
                self.enableUserData = enableUserData
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(channelID, forKey: "channelId")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(groupID, forKey: "groupId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(status, forKey: "status")
                encoder.encode(isInProgress, forKey: "isInProgress")
                encoder.encode(seriesTimerID, forKey: "seriesTimerId")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var auth: Auth {
        Auth(path: "/Auth")
    }

    public struct Auth {
        /// Path: `/Auth`
        public let path: String
    }
}

extension Paths.Auth {
    public var keys: Keys {
        Keys(path: path + "/Keys")
    }

    public struct Keys {
        /// Path: `/Auth/Keys`
        public let path: String

        /// Get all keys.
        public var get: Request<JellyfinAPI.AuthenticationInfoQueryResult> {
            .get(path)
        }

        /// Create a new api key.
        public func post(app: String) -> Request<Void> {
            .post(path, query: [("app", app)])
        }
    }
}

extension Paths.Notifications {
    public var types: Types {
        Types(path: path + "/Types")
    }

    public struct Types {
        /// Path: `/Notifications/Types`
        public let path: String

        /// Gets notification types.
        public var get: Request<[JellyfinAPI.NotificationTypeInfo]> {
            .get(path)
        }
    }
}

extension Paths.Users {
    public var `public`: Public {
        Public(path: path + "/Public")
    }

    public struct Public {
        /// Path: `/Users/Public`
        public let path: String

        /// Gets a list of publicly visible users for display on a login screen.
        public var get: Request<[JellyfinAPI.UserDto]> {
            .get(path)
        }
    }
}

extension Paths.Plugins.WithPluginID {
    public var configuration: Configuration {
        Configuration(path: path + "/Configuration")
    }

    public struct Configuration {
        /// Path: `/Plugins/{pluginId}/Configuration`
        public let path: String

        /// Gets plugin configuration.
        public var get: Request<Void> {
            .get(path)
        }

        /// Updates plugin configuration.
        ///
        /// Accepts plugin configuration as JSON body.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.System {
    public var ping: Ping {
        Ping(path: path + "/Ping")
    }

    public struct Ping {
        /// Path: `/System/Ping`
        public let path: String

        /// Pings the system.
        public var get: Request<String> {
            .get(path)
        }

        /// Pings the system.
        public var post: Request<String> {
            .post(path)
        }
    }
}

extension Paths.Dlna.WithServerID.ContentDirectory {
    public var contentDirectory: ContentDirectory {
        ContentDirectory(path: path + "/ContentDirectory")
    }

    public struct ContentDirectory {
        /// Path: `/Dlna/{serverId}/ContentDirectory/ContentDirectory`
        public let path: String

        /// Gets Dlna content directory xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Dlna.WithServerID.ConnectionManager {
    public var connectionManagerXml: ConnectionManagerXml {
        ConnectionManagerXml(path: path + "/ConnectionManager.xml")
    }

    public struct ConnectionManagerXml {
        /// Path: `/Dlna/{serverId}/ConnectionManager/ConnectionManager.xml`
        public let path: String

        /// Gets Dlna media receiver registrar xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Videos {
    public var mergeVersions: MergeVersions {
        MergeVersions(path: path + "/MergeVersions")
    }

    public struct MergeVersions {
        /// Path: `/Videos/MergeVersions`
        public let path: String

        /// Merges videos into a single record.
        public func post(ids: [String]) -> Request<Void> {
            .post(path, query: makePostQuery(ids))
        }

        private func makePostQuery(_ ids: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ids, forKey: "ids")
            return encoder.items
        }
    }
}

extension Paths.Channels {
    public var items: Items {
        Items(path: path + "/Items")
    }

    public struct Items {
        /// Path: `/Channels/Items`
        public let path: String
    }
}

extension Paths.Channels.Items {
    public var latest: Latest {
        Latest(path: path + "/Latest")
    }

    public struct Latest {
        /// Path: `/Channels/Items/Latest`
        public let path: String

        /// Gets latest channel items.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. User Id.
            public var userID: String?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional filters to apply.
            public var filters: [JellyfinAPI.ItemFilter]?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Specify one or more channel id's, comma delimited.
            public var channelIDs: [String]?

            public init(userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, channelIDs: [String]? = nil) {
                self.userID = userID
                self.startIndex = startIndex
                self.limit = limit
                self.filters = filters
                self.fields = fields
                self.channelIDs = channelIDs
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(filters, forKey: "filters")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(channelIDs, forKey: "channelIds")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var musicGenres: MusicGenres {
        MusicGenres(path: "/MusicGenres")
    }

    public struct MusicGenres {
        /// Path: `/MusicGenres`
        public let path: String

        /// Gets all music genres from a given item, folder, or the entire library.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// The search term.
            public var searchTerm: String?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
            public var excludeItemTypes: [String]?
            /// Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional filter by items that are marked as favorite, or not.
            public var isFavorite: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// User id.
            public var userID: String?
            /// Optional filter by items whose name is sorted equally or greater than a given input string.
            public var nameStartsWithOrGreater: String?
            /// Optional filter by items whose name is sorted equally than a given input string.
            public var nameStartsWith: String?
            /// Optional filter by items whose name is equally or lesser than a given input string.
            public var nameLessThan: String?
            /// Optional, include image information in output.
            public var enableImages: Bool?
            /// Optional. Include total record count.
            public var enableTotalRecordCount: Bool?

            public init(startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, isFavorite: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
                self.startIndex = startIndex
                self.limit = limit
                self.searchTerm = searchTerm
                self.parentID = parentID
                self.fields = fields
                self.excludeItemTypes = excludeItemTypes
                self.includeItemTypes = includeItemTypes
                self.isFavorite = isFavorite
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.userID = userID
                self.nameStartsWithOrGreater = nameStartsWithOrGreater
                self.nameStartsWith = nameStartsWith
                self.nameLessThan = nameLessThan
                self.enableImages = enableImages
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
                encoder.encode(nameStartsWith, forKey: "nameStartsWith")
                encoder.encode(nameLessThan, forKey: "nameLessThan")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public var authenticateByName: AuthenticateByName {
        AuthenticateByName(path: path + "/AuthenticateByName")
    }

    public struct AuthenticateByName {
        /// Path: `/Users/AuthenticateByName`
        public let path: String

        /// Authenticates a user by name.
        public func post(_ body: JellyfinAPI.AuthenticateUserByName) -> Request<JellyfinAPI.AuthenticationResult> {
            .post(path, body: body)
        }
    }
}

extension Paths.Items.WithItemID {
    public var metadataEditor: MetadataEditor {
        MetadataEditor(path: path + "/MetadataEditor")
    }

    public struct MetadataEditor {
        /// Path: `/Items/{itemId}/MetadataEditor`
        public let path: String

        /// Gets metadata editor info for an item.
        public var get: Request<JellyfinAPI.MetadataEditorInfo> {
            .get(path)
        }
    }
}

extension Paths.Packages {
    public var installed: Installed {
        Installed(path: path + "/Installed")
    }

    public struct Installed {
        /// Path: `/Packages/Installed`
        public let path: String
    }
}

extension Paths.Packages.Installed {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/Packages/Installed/{name}`
        public let path: String

        /// Installs a package.
        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            /// GUID of the associated assembly.
            public var assemblyGuid: String?
            /// Optional version. Defaults to latest version.
            public var version: String?
            /// Optional. Specify the repository to install from.
            public var repositoryURL: String?

            public init(assemblyGuid: String? = nil, version: String? = nil, repositoryURL: String? = nil) {
                self.assemblyGuid = assemblyGuid
                self.version = version
                self.repositoryURL = repositoryURL
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(assemblyGuid, forKey: "assemblyGuid")
                encoder.encode(version, forKey: "version")
                encoder.encode(repositoryURL, forKey: "repositoryUrl")
                return encoder.items
            }
        }
    }
}

extension Paths.SyncPlay {
    public var join: Join {
        Join(path: path + "/Join")
    }

    public struct Join {
        /// Path: `/SyncPlay/Join`
        public let path: String

        /// Join an existing SyncPlay group.
        public func post(_ body: JellyfinAPI.JoinGroupRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.System.Configuration {
    public func key(_ key: String) -> WithKey {
        WithKey(path: "\(path)/\(key)")
    }

    public struct WithKey {
        /// Path: `/System/Configuration/{key}`
        public let path: String

        /// Gets a named configuration.
        public var get: Request<String> {
            .get(path)
        }

        /// Updates named configuration.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Localization {
    public var options: Options {
        Options(path: path + "/Options")
    }

    public struct Options {
        /// Path: `/Localization/Options`
        public let path: String

        /// Gets localization options.
        public var get: Request<[JellyfinAPI.LocalizationOption]> {
            .get(path)
        }
    }
}

extension Paths.Items.WithItemID {
    public var externalIDInfos: ExternalIDInfos {
        ExternalIDInfos(path: path + "/ExternalIdInfos")
    }

    public struct ExternalIDInfos {
        /// Path: `/Items/{itemId}/ExternalIdInfos`
        public let path: String

        /// Get the item's external id info.
        public var get: Request<[JellyfinAPI.ExternalIDInfo]> {
            .get(path)
        }
    }
}

extension Paths.Plugins.WithPluginID.WithVersion {
    public var image: Image {
        Image(path: path + "/Image")
    }

    public struct Image {
        /// Path: `/Plugins/{pluginId}/{version}/Image`
        public let path: String

        /// Gets a plugin's image.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Playlists {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/Playlists/{id}`
        public let path: String
    }
}

extension Paths.Playlists.WithID {
    public var instantMix: InstantMix {
        InstantMix(path: path + "/InstantMix")
    }

    public struct InstantMix {
        /// Path: `/Playlists/{id}/InstantMix`
        public let path: String

        /// Creates an instant playlist based on a given playlist.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.userID = userID
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }
    }
}

extension Paths.Videos.WithItemID.Subtitles {
    public func index(_ index: Int) -> WithIndex {
        WithIndex(path: "\(path)/\(index)")
    }

    public struct WithIndex {
        /// Path: `/Videos/{itemId}/Subtitles/{index}`
        public let path: String

        /// Deletes an external subtitle file.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.ForgotPassword {
    public var pin: Pin {
        Pin(path: path + "/Pin")
    }

    public struct Pin {
        /// Path: `/Users/ForgotPassword/Pin`
        public let path: String

        /// Redeems a forgot password pin.
        public func post(_ body: JellyfinAPI.ForgotPasswordPinDto) -> Request<JellyfinAPI.PinRedeemResult> {
            .post(path, body: body)
        }
    }
}

extension Paths.Notifications {
    public var services: Services {
        Services(path: path + "/Services")
    }

    public struct Services {
        /// Path: `/Notifications/Services`
        public let path: String

        /// Gets notification services.
        public var get: Request<[JellyfinAPI.NameIDPair]> {
            .get(path)
        }
    }
}

extension Paths.SyncPlay {
    public var pause: Pause {
        Pause(path: path + "/Pause")
    }

    public struct Pause {
        /// Path: `/SyncPlay/Pause`
        public let path: String

        /// Request pause in SyncPlay group.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Items.WithItemID.Images.WithImageType {
    public func imageIndex(_ imageIndex: Int) -> WithImageIndex {
        WithImageIndex(path: "\(path)/\(imageIndex)")
    }

    public struct WithImageIndex {
        /// Path: `/Items/{itemId}/Images/{imageType}/{imageIndex}`
        public let path: String

        /// Gets the item's image.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
            public var format: Format?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(maxWidth: Int? = nil, maxHeight: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, tag: String? = nil, isCropWhitespace: Bool? = nil, format: Format? = nil, isAddPlayedIndicator: Bool? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.tag = tag
                self.isCropWhitespace = isCropWhitespace
                self.format = format
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(format, forKey: "format")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }

        /// Set item image.
        public func post(_ body: Data? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Delete an item's image.
        public var delete: Request<Void> {
            .delete(path)
        }

        /// Gets the item's image.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
            public var format: Format?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(maxWidth: Int? = nil, maxHeight: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, tag: String? = nil, isCropWhitespace: Bool? = nil, format: Format? = nil, isAddPlayedIndicator: Bool? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.tag = tag
                self.isCropWhitespace = isCropWhitespace
                self.format = format
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(format, forKey: "format")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/Users/{userId}`
        public let path: String

        /// Gets a user by Id.
        public var get: Request<JellyfinAPI.UserDto> {
            .get(path)
        }

        /// Updates a user.
        public func post(_ body: JellyfinAPI.UserDto) -> Request<Void> {
            .post(path, body: body)
        }

        /// Deletes a user.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Studios.WithName {
    public var images: Images {
        Images(path: path + "/Images")
    }

    public struct Images {
        /// Path: `/Studios/{name}/Images`
        public let path: String
    }
}

extension Paths.Studios.WithName.Images.WithImageType {
    public func imageIndex(_ imageIndex: Int) -> WithImageIndex {
        WithImageIndex(path: "\(path)/\(imageIndex)")
    }

    public struct WithImageIndex {
        /// Path: `/Studios/{name}/Images/{imageType}/{imageIndex}`
        public let path: String

        /// Get studio image by name.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }

        /// Get studio image by name.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }
    }
}

extension Paths.Dlna.WithServerID.ConnectionManager {
    public var connectionManager: ConnectionManager {
        ConnectionManager(path: path + "/ConnectionManager")
    }

    public struct ConnectionManager {
        /// Path: `/Dlna/{serverId}/ConnectionManager/ConnectionManager`
        public let path: String

        /// Gets Dlna media receiver registrar xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Items.WithItemID {
    public var criticReviews: CriticReviews {
        CriticReviews(path: path + "/CriticReviews")
    }

    public struct CriticReviews {
        /// Path: `/Items/{itemId}/CriticReviews`
        public let path: String

        /// Gets critic review for an item.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path)
        }
    }
}

extension Paths.Items.RemoteSearch {
    public var musicArtist: MusicArtist {
        MusicArtist(path: path + "/MusicArtist")
    }

    public struct MusicArtist {
        /// Path: `/Items/RemoteSearch/MusicArtist`
        public let path: String

        /// Get music artist remote search.
        public func post(_ body: JellyfinAPI.ArtistInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Audio.WithItemID {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/Audio/{itemId}/stream`
        public let path: String

        /// Gets an audio stream.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The audio container.
            public var container: String?
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.container = container
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(container, forKey: "container")
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }

        /// Gets an audio stream.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// The audio container.
            public var container: String?
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.container = container
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(container, forKey: "container")
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var quickConnect: QuickConnect {
        QuickConnect(path: "/QuickConnect")
    }

    public struct QuickConnect {
        /// Path: `/QuickConnect`
        public let path: String
    }
}

extension Paths.QuickConnect {
    public var available: Available {
        Available(path: path + "/Available")
    }

    public struct Available {
        /// Path: `/QuickConnect/Available`
        public let path: String

        /// Enables or disables quick connect.
        public func post(status: Status? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(status))
        }

        private func makePostQuery(_ status: Status?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(status, forKey: "status")
            return encoder.items
        }

        public typealias Status = JellyfinAPI.QuickConnectState
    }
}

extension Paths.Videos.WithItemID {
    public func container(_ container: String) -> WithStream {
        WithStream(path: "\(path)/stream.\(container)")
    }

    public struct WithStream {
        /// Path: `/Videos/{itemId}/stream.{container}`
        public let path: String

        /// Gets a video stream.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. The maximum horizontal resolution of the encoded video.
            public var maxWidth: Int?
            /// Optional. The maximum vertical resolution of the encoded video.
            public var maxHeight: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }

        /// Gets a video stream.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. The maximum horizontal resolution of the encoded video.
            public var maxWidth: Int?
            /// Optional. The maximum vertical resolution of the encoded video.
            public var maxHeight: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }
    }
}

extension Paths.Channels {
    public func channelID(_ channelID: String) -> WithChannelID {
        WithChannelID(path: "\(path)/\(channelID)")
    }

    public struct WithChannelID {
        /// Path: `/Channels/{channelId}`
        public let path: String
    }
}

extension Paths.Channels.WithChannelID {
    public var items: Items {
        Items(path: path + "/Items")
    }

    public struct Items {
        /// Path: `/Channels/{channelId}/Items`
        public let path: String

        /// Get channel items.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Folder Id.
            public var folderID: String?
            /// Optional. User Id.
            public var userID: String?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Sort Order - Ascending,Descending.
            public var sortOrder: [JellyfinAPI.SortOrder]?
            /// Optional. Specify additional filters to apply.
            public var filters: [JellyfinAPI.ItemFilter]?
            /// Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
            public var sortBy: [String]?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?

            public init(folderID: String? = nil, userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, sortBy: [String]? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
                self.folderID = folderID
                self.userID = userID
                self.startIndex = startIndex
                self.limit = limit
                self.sortOrder = sortOrder
                self.filters = filters
                self.sortBy = sortBy
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(folderID, forKey: "folderId")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(sortOrder, forKey: "sortOrder")
                encoder.encode(filters, forKey: "filters")
                encoder.encode(sortBy, forKey: "sortBy")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.SyncPlay {
    public var unpause: Unpause {
        Unpause(path: path + "/Unpause")
    }

    public struct Unpause {
        /// Path: `/SyncPlay/Unpause`
        public let path: String

        /// Request unpause in SyncPlay group.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Devices {
    public var options: Options {
        Options(path: path + "/Options")
    }

    public struct Options {
        /// Path: `/Devices/Options`
        public let path: String

        /// Get options for a device.
        public func get(id: String) -> Request<JellyfinAPI.DeviceOptions> {
            .get(path, query: [("id", id)])
        }

        /// Update device options.
        public func post(id: String, _ body: JellyfinAPI.DeviceOptions) -> Request<Void> {
            .post(path, query: [("id", id)], body: body)
        }
    }
}

extension Paths.Videos {
    public func routeItemID(_ routeItemID: String) -> WithRouteItemID {
        WithRouteItemID(path: "\(path)/\(routeItemID)")
    }

    public struct WithRouteItemID {
        /// Path: `/Videos/{routeItemId}`
        public let path: String
    }
}

extension Paths.Videos.WithRouteItemID {
    public func routeMediaSourceID(_ routeMediaSourceID: String) -> WithRouteMediaSourceID {
        WithRouteMediaSourceID(path: "\(path)/\(routeMediaSourceID)")
    }

    public struct WithRouteMediaSourceID {
        /// Path: `/Videos/{routeItemId}/{routeMediaSourceId}`
        public let path: String
    }
}

extension Paths.Videos.WithRouteItemID.WithRouteMediaSourceID {
    public var subtitles: Subtitles {
        Subtitles(path: path + "/Subtitles")
    }

    public struct Subtitles {
        /// Path: `/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles`
        public let path: String
    }
}

extension Paths.Videos.WithRouteItemID.WithRouteMediaSourceID.Subtitles {
    public func routeIndex(_ routeIndex: Int) -> WithRouteIndex {
        WithRouteIndex(path: "\(path)/\(routeIndex)")
    }

    public struct WithRouteIndex {
        /// Path: `/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}`
        public let path: String
    }
}

extension Paths.Videos.WithRouteItemID.WithRouteMediaSourceID.Subtitles.WithRouteIndex {
    public func routeStartPositionTicks(_ routeStartPositionTicks: Int) -> WithRouteStartPositionTicks {
        WithRouteStartPositionTicks(path: "\(path)/\(routeStartPositionTicks)")
    }

    public struct WithRouteStartPositionTicks {
        /// Path: `/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/{routeStartPositionTicks}`
        public let path: String
    }
}

extension Paths.Videos.WithRouteItemID.WithRouteMediaSourceID.Subtitles.WithRouteIndex.WithRouteStartPositionTicks {
    public func routeFormat(_ routeFormat: String) -> WithStream {
        WithStream(path: "\(path)/Stream.\(routeFormat)")
    }

    public struct WithStream {
        /// Path: `/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/{routeStartPositionTicks}/Stream.{routeFormat}`
        public let path: String

        /// Gets subtitles in a specified format.
        public func get(parameters: GetParameters? = nil) -> Request<String> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The item id.
            public var itemID: String?
            /// The media source id.
            public var mediaSourceID: String?
            /// The subtitle stream index.
            public var index: Int?
            /// The start position of the subtitle in ticks.
            public var startPositionTicks: Int?
            /// The format of the returned subtitle.
            public var format: String?
            /// Optional. The end position of the subtitle in ticks.
            public var endPositionTicks: Int?
            /// Optional. Whether to copy the timestamps.
            public var isCopyTimestamps: Bool?
            /// Optional. Whether to add a VTT time map.
            public var isAddVttTimeMap: Bool?

            public init(itemID: String? = nil, mediaSourceID: String? = nil, index: Int? = nil, startPositionTicks: Int? = nil, format: String? = nil, endPositionTicks: Int? = nil, isCopyTimestamps: Bool? = nil, isAddVttTimeMap: Bool? = nil) {
                self.itemID = itemID
                self.mediaSourceID = mediaSourceID
                self.index = index
                self.startPositionTicks = startPositionTicks
                self.format = format
                self.endPositionTicks = endPositionTicks
                self.isCopyTimestamps = isCopyTimestamps
                self.isAddVttTimeMap = isAddVttTimeMap
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(itemID, forKey: "itemId")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(index, forKey: "index")
                encoder.encode(startPositionTicks, forKey: "startPositionTicks")
                encoder.encode(format, forKey: "format")
                encoder.encode(endPositionTicks, forKey: "endPositionTicks")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(isAddVttTimeMap, forKey: "addVttTimeMap")
                return encoder.items
            }
        }
    }
}

extension Paths.Library {
    public var refresh: Refresh {
        Refresh(path: path + "/Refresh")
    }

    public struct Refresh {
        /// Path: `/Library/Refresh`
        public let path: String

        /// Starts a library scan.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Notifications {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/Notifications/{userId}`
        public let path: String

        /// Gets a user's notifications.
        public var get: Request<JellyfinAPI.NotificationResultDto> {
            .get(path)
        }
    }
}

extension Paths.SyncPlay {
    public var setShuffleMode: SetShuffleMode {
        SetShuffleMode(path: path + "/SetShuffleMode")
    }

    public struct SetShuffleMode {
        /// Path: `/SyncPlay/SetShuffleMode`
        public let path: String

        /// Request to set shuffle mode in SyncPlay group.
        public func post(_ body: JellyfinAPI.SetShuffleModeRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users {
    public var new: New {
        New(path: path + "/New")
    }

    public struct New {
        /// Path: `/Users/New`
        public let path: String

        /// Creates a user.
        public func post(_ body: JellyfinAPI.CreateUserByName) -> Request<JellyfinAPI.UserDto> {
            .post(path, body: body)
        }
    }
}

extension Paths.LiveTv {
    public var listingProviders: ListingProviders {
        ListingProviders(path: path + "/ListingProviders")
    }

    public struct ListingProviders {
        /// Path: `/LiveTv/ListingProviders`
        public let path: String

        /// Adds a listings provider.
        public func post(parameters: PostParameters? = nil, _ body: JellyfinAPI.ListingsProviderInfo? = nil) -> Request<JellyfinAPI.ListingsProviderInfo> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            /// Password.
            public var pw: String?
            /// Validate listings.
            public var isValidateListings: Bool?
            /// Validate login.
            public var isValidateLogin: Bool?

            public init(pw: String? = nil, isValidateListings: Bool? = nil, isValidateLogin: Bool? = nil) {
                self.pw = pw
                self.isValidateListings = isValidateListings
                self.isValidateLogin = isValidateLogin
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pw, forKey: "pw")
                encoder.encode(isValidateListings, forKey: "validateListings")
                encoder.encode(isValidateLogin, forKey: "validateLogin")
                return encoder.items
            }
        }

        /// Delete listing provider.
        public func delete(id: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(id))
        }

        private func makeDeleteQuery(_ id: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            return encoder.items
        }
    }
}

extension Paths {
    public static var web: Web {
        Web(path: "/web")
    }

    public struct Web {
        /// Path: `/web`
        public let path: String
    }
}

extension Paths.Web {
    public var configurationPage: ConfigurationPage {
        ConfigurationPage(path: path + "/ConfigurationPage")
    }

    public struct ConfigurationPage {
        /// Path: `/web/ConfigurationPage`
        public let path: String

        /// Gets a dashboard configuration page.
        public func get(name: String? = nil) -> Request<String> {
            .get(path, query: makeGetQuery(name))
        }

        private func makeGetQuery(_ name: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(name, forKey: "name")
            return encoder.items
        }
    }
}

extension Paths.Videos.WithItemID {
    public var masterM3u8: MasterM3u8 {
        MasterM3u8(path: path + "/master.m3u8")
    }

    public struct MasterM3u8 {
        /// Path: `/Videos/{itemId}/master.m3u8`
        public let path: String

        /// Gets a video hls playlist stream.
        public func get(parameters: GetParameters) -> Request<Data> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?
            /// Enable adaptive bitrate streaming.
            public var enableAdaptiveBitrateStreaming: Bool?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, enableAdaptiveBitrateStreaming: Bool? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
                self.enableAdaptiveBitrateStreaming = enableAdaptiveBitrateStreaming
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                encoder.encode(enableAdaptiveBitrateStreaming, forKey: "enableAdaptiveBitrateStreaming")
                return encoder.items
            }
        }

        /// Gets a video hls playlist stream.
        public func head(parameters: HeadParameters) -> Request<Data> {
            .head(path, query: parameters.asQuery)
        }

        public struct HeadParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?
            /// Enable adaptive bitrate streaming.
            public var enableAdaptiveBitrateStreaming: Bool?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, enableAdaptiveBitrateStreaming: Bool? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
                self.enableAdaptiveBitrateStreaming = enableAdaptiveBitrateStreaming
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                encoder.encode(enableAdaptiveBitrateStreaming, forKey: "enableAdaptiveBitrateStreaming")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var artists: Artists {
        Artists(path: "/Artists")
    }

    public struct Artists {
        /// Path: `/Artists`
        public let path: String

        /// Gets all artists from a given item, folder, or the entire library.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional filter by minimum community rating.
            public var minCommunityRating: Double?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Search term.
            public var searchTerm: String?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
            public var excludeItemTypes: [String]?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional. Specify additional filters to apply.
            public var filters: [JellyfinAPI.ItemFilter]?
            /// Optional filter by items that are marked as favorite, or not.
            public var isFavorite: Bool?
            /// Optional filter by MediaType. Allows multiple, comma delimited.
            public var mediaTypes: [String]?
            /// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
            public var genres: [String]?
            /// Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
            public var genreIDs: [String]?
            /// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
            public var officialRatings: [String]?
            /// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
            public var tags: [String]?
            /// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
            public var years: [Int]?
            /// Optional, include user data.
            public var enableUserData: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. If specified, results will be filtered to include only those containing the specified person.
            public var person: String?
            /// Optional. If specified, results will be filtered to include only those containing the specified person ids.
            public var personIDs: [String]?
            /// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
            public var personTypes: [String]?
            /// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
            public var studios: [String]?
            /// Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
            public var studioIDs: [String]?
            /// User id.
            public var userID: String?
            /// Optional filter by items whose name is sorted equally or greater than a given input string.
            public var nameStartsWithOrGreater: String?
            /// Optional filter by items whose name is sorted equally than a given input string.
            public var nameStartsWith: String?
            /// Optional filter by items whose name is equally or lesser than a given input string.
            public var nameLessThan: String?
            /// Optional, include image information in output.
            public var enableImages: Bool?
            /// Total record count.
            public var enableTotalRecordCount: Bool?

            public init(minCommunityRating: Double? = nil, startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, genres: [String]? = nil, genreIDs: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, studioIDs: [String]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
                self.minCommunityRating = minCommunityRating
                self.startIndex = startIndex
                self.limit = limit
                self.searchTerm = searchTerm
                self.parentID = parentID
                self.fields = fields
                self.excludeItemTypes = excludeItemTypes
                self.includeItemTypes = includeItemTypes
                self.filters = filters
                self.isFavorite = isFavorite
                self.mediaTypes = mediaTypes
                self.genres = genres
                self.genreIDs = genreIDs
                self.officialRatings = officialRatings
                self.tags = tags
                self.years = years
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.person = person
                self.personIDs = personIDs
                self.personTypes = personTypes
                self.studios = studios
                self.studioIDs = studioIDs
                self.userID = userID
                self.nameStartsWithOrGreater = nameStartsWithOrGreater
                self.nameStartsWith = nameStartsWith
                self.nameLessThan = nameLessThan
                self.enableImages = enableImages
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(minCommunityRating, forKey: "minCommunityRating")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(filters, forKey: "filters")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(mediaTypes, forKey: "mediaTypes")
                encoder.encode(genres, forKey: "genres")
                encoder.encode(genreIDs, forKey: "genreIds")
                encoder.encode(officialRatings, forKey: "officialRatings")
                encoder.encode(tags, forKey: "tags")
                encoder.encode(years, forKey: "years")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(person, forKey: "person")
                encoder.encode(personIDs, forKey: "personIds")
                encoder.encode(personTypes, forKey: "personTypes")
                encoder.encode(studios, forKey: "studios")
                encoder.encode(studioIDs, forKey: "studioIds")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
                encoder.encode(nameStartsWith, forKey: "nameStartsWith")
                encoder.encode(nameLessThan, forKey: "nameLessThan")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var repositories: Repositories {
        Repositories(path: "/Repositories")
    }

    public struct Repositories {
        /// Path: `/Repositories`
        public let path: String

        /// Gets all package repositories.
        public var get: Request<[JellyfinAPI.RepositoryInfo]> {
            .get(path)
        }

        /// Sets the enabled and existing package repositories.
        public func post(_ body: [JellyfinAPI.RepositoryInfo]) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.QuickConnect {
    public var activate: Activate {
        Activate(path: path + "/Activate")
    }

    public struct Activate {
        /// Path: `/QuickConnect/Activate`
        public let path: String

        /// Temporarily activates quick connect for five minutes.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths {
    public static var albums: Albums {
        Albums(path: "/Albums")
    }

    public struct Albums {
        /// Path: `/Albums`
        public let path: String
    }
}

extension Paths.Albums {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Albums/{itemId}`
        public let path: String
    }
}

extension Paths.Albums.WithItemID {
    public var similar: Similar {
        Similar(path: path + "/Similar")
    }

    public struct Similar {
        /// Path: `/Albums/{itemId}/Similar`
        public let path: String

        /// Gets similar items.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Exclude artist ids.
            public var excludeArtistIDs: [String]?
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
            public var fields: [JellyfinAPI.ItemFields]?

            public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
                self.excludeArtistIDs = excludeArtistIDs
                self.userID = userID
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Startup {
    public var complete: Complete {
        Complete(path: path + "/Complete")
    }

    public struct Complete {
        /// Path: `/Startup/Complete`
        public let path: String

        /// Completes the startup wizard.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Plugins {
    public var securityInfo: SecurityInfo {
        SecurityInfo(path: path + "/SecurityInfo")
    }

    public struct SecurityInfo {
        /// Path: `/Plugins/SecurityInfo`
        public let path: String

        /// Updates plugin security info.
        @available(*, deprecated, message: "Deprecated")
        public func post(_ body: JellyfinAPI.PluginSecurityInfo) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Dlna.WithServerID.MediaReceiverRegistrar {
    public var control: Control {
        Control(path: path + "/Control")
    }

    public struct Control {
        /// Path: `/Dlna/{serverId}/MediaReceiverRegistrar/Control`
        public let path: String

        /// Process a media receiver registrar control request.
        public var post: Request<String> {
            .post(path)
        }
    }
}

extension Paths {
    public static var shows: Shows {
        Shows(path: "/Shows")
    }

    public struct Shows {
        /// Path: `/Shows`
        public let path: String
    }
}

extension Paths.Shows {
    public func seriesID(_ seriesID: String) -> WithSeriesID {
        WithSeriesID(path: "\(path)/\(seriesID)")
    }

    public struct WithSeriesID {
        /// Path: `/Shows/{seriesId}`
        public let path: String
    }
}

extension Paths.Shows.WithSeriesID {
    public var seasons: Seasons {
        Seasons(path: path + "/Seasons")
    }

    public struct Seasons {
        /// Path: `/Shows/{seriesId}/Seasons`
        public let path: String

        /// Gets seasons for a tv series.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The user id.
            public var userID: String?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Filter by special season.
            public var isSpecialSeason: Bool?
            /// Optional. Filter by items that are missing episodes or not.
            public var isMissing: Bool?
            /// Optional. Return items that are siblings of a supplied item.
            public var adjacentTo: String?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Include user data.
            public var enableUserData: Bool?

            public init(userID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, isSpecialSeason: Bool? = nil, isMissing: Bool? = nil, adjacentTo: String? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil) {
                self.userID = userID
                self.fields = fields
                self.isSpecialSeason = isSpecialSeason
                self.isMissing = isMissing
                self.adjacentTo = adjacentTo
                self.enableImages = enableImages
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.enableUserData = enableUserData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(isSpecialSeason, forKey: "isSpecialSeason")
                encoder.encode(isMissing, forKey: "isMissing")
                encoder.encode(adjacentTo, forKey: "adjacentTo")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(enableUserData, forKey: "enableUserData")
                return encoder.items
            }
        }
    }
}

extension Paths.LiveTv {
    public var liveStreamFiles: LiveStreamFiles {
        LiveStreamFiles(path: path + "/LiveStreamFiles")
    }

    public struct LiveStreamFiles {
        /// Path: `/LiveTv/LiveStreamFiles`
        public let path: String
    }
}

extension Paths.LiveTv.LiveStreamFiles {
    public func streamID(_ streamID: String) -> WithStreamID {
        WithStreamID(path: "\(path)/\(streamID)")
    }

    public struct WithStreamID {
        /// Path: `/LiveTv/LiveStreamFiles/{streamId}`
        public let path: String
    }
}

extension Paths.LiveTv.LiveStreamFiles.WithStreamID {
    public func container(_ container: String) -> WithStream {
        WithStream(path: "\(path)/stream.\(container)")
    }

    public struct WithStream {
        /// Path: `/LiveTv/LiveStreamFiles/{streamId}/stream.{container}`
        public let path: String

        /// Gets a live tv channel stream.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Artists {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/Artists/{id}`
        public let path: String
    }
}

extension Paths.Artists.WithID {
    public var instantMix: InstantMix {
        InstantMix(path: path + "/InstantMix")
    }

    public struct InstantMix {
        /// Path: `/Artists/{id}/InstantMix`
        public let path: String

        /// Creates an instant playlist based on a given artist.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.userID = userID
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }
    }
}

extension Paths.System {
    public var shutdown: Shutdown {
        Shutdown(path: path + "/Shutdown")
    }

    public struct Shutdown {
        /// Path: `/System/Shutdown`
        public let path: String

        /// Shuts down the application.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.LiveTv {
    public var tunerHosts: TunerHosts {
        TunerHosts(path: path + "/TunerHosts")
    }

    public struct TunerHosts {
        /// Path: `/LiveTv/TunerHosts`
        public let path: String

        /// Adds a tuner host.
        public func post(_ body: JellyfinAPI.TunerHostInfo? = nil) -> Request<JellyfinAPI.TunerHostInfo> {
            .post(path, body: body)
        }

        /// Deletes a tuner host.
        public func delete(id: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(id))
        }

        private func makeDeleteQuery(_ id: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            return encoder.items
        }
    }
}

extension Paths.Library.Movies {
    public var updated: Updated {
        Updated(path: path + "/Updated")
    }

    public struct Updated {
        /// Path: `/Library/Movies/Updated`
        public let path: String

        /// Reports that new movies have been added by an external source.
        public func post(tmdbID: String? = nil, imdbID: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(tmdbID, imdbID))
        }

        private func makePostQuery(_ tmdbID: String?, _ imdbID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tmdbID, forKey: "tmdbId")
            encoder.encode(imdbID, forKey: "imdbId")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var password: Password {
        Password(path: path + "/Password")
    }

    public struct Password {
        /// Path: `/Users/{userId}/Password`
        public let path: String

        /// Updates a user's password.
        public func post(_ body: JellyfinAPI.UpdateUserPassword) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Dlna.WithServerID {
    public var contentDirectory: ContentDirectory {
        ContentDirectory(path: path + "/ContentDirectory")
    }

    public struct ContentDirectory {
        /// Path: `/Dlna/{serverId}/ContentDirectory`
        public let path: String

        /// Gets Dlna content directory xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.LiveTv.Tuners {
    public var discover: Discover {
        Discover(path: path + "/Discover")
    }

    public struct Discover {
        /// Path: `/LiveTv/Tuners/Discover`
        public let path: String

        /// Discover tuners.
        public func get(isNewDevicesOnly: Bool? = nil) -> Request<[JellyfinAPI.TunerHostInfo]> {
            .get(path, query: makeGetQuery(isNewDevicesOnly))
        }

        private func makeGetQuery(_ isNewDevicesOnly: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isNewDevicesOnly, forKey: "newDevicesOnly")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var easyPassword: EasyPassword {
        EasyPassword(path: path + "/EasyPassword")
    }

    public struct EasyPassword {
        /// Path: `/Users/{userId}/EasyPassword`
        public let path: String

        /// Updates a user's easy password.
        public func post(_ body: JellyfinAPI.UpdateUserEasyPassword) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.SyncPlay {
    public var previousItem: PreviousItem {
        PreviousItem(path: path + "/PreviousItem")
    }

    public struct PreviousItem {
        /// Path: `/SyncPlay/PreviousItem`
        public let path: String

        /// Request previous item in SyncPlay group.
        public func post(_ body: JellyfinAPI.PreviousItemRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var liveStreams: LiveStreams {
        LiveStreams(path: "/LiveStreams")
    }

    public struct LiveStreams {
        /// Path: `/LiveStreams`
        public let path: String
    }
}

extension Paths.LiveStreams {
    public var close: Close {
        Close(path: path + "/Close")
    }

    public struct Close {
        /// Path: `/LiveStreams/Close`
        public let path: String

        /// Closes a media source.
        public func post(liveStreamID: String) -> Request<Void> {
            .post(path, query: [("liveStreamId", liveStreamID)])
        }
    }
}

extension Paths {
    public static var collections: Collections {
        Collections(path: "/Collections")
    }

    public struct Collections {
        /// Path: `/Collections`
        public let path: String

        /// Creates a new collection.
        public func post(parameters: PostParameters? = nil) -> Request<JellyfinAPI.CollectionCreationResult> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            /// The name of the collection.
            public var name: String?
            /// Item Ids to add to the collection.
            public var ids: [String]?
            /// Optional. Create the collection within a specific folder.
            public var parentID: String?
            /// Whether or not to lock the new collection.
            public var isLocked: Bool?

            public init(name: String? = nil, ids: [String]? = nil, parentID: String? = nil, isLocked: Bool? = nil) {
                self.name = name
                self.ids = ids
                self.parentID = parentID
                self.isLocked = isLocked
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(ids, forKey: "ids")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(isLocked, forKey: "isLocked")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithUserID.PlayingItems {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Users/{userId}/PlayingItems/{itemId}`
        public let path: String

        /// Reports that a user has begun playing an item.
        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            /// The id of the MediaSource.
            public var mediaSourceID: String?
            /// The audio stream index.
            public var audioStreamIndex: Int?
            /// The subtitle stream index.
            public var subtitleStreamIndex: Int?
            /// The play method.
            public var playMethod: PlayMethod?
            /// The live stream id.
            public var liveStreamID: String?
            /// The play session id.
            public var playSessionID: String?
            /// Indicates if the client can seek.
            public var canSeek: Bool?

            public typealias PlayMethod = JellyfinAPI.PlayMethod

            public init(mediaSourceID: String? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, playMethod: PlayMethod? = nil, liveStreamID: String? = nil, playSessionID: String? = nil, canSeek: Bool? = nil) {
                self.mediaSourceID = mediaSourceID
                self.audioStreamIndex = audioStreamIndex
                self.subtitleStreamIndex = subtitleStreamIndex
                self.playMethod = playMethod
                self.liveStreamID = liveStreamID
                self.playSessionID = playSessionID
                self.canSeek = canSeek
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(playMethod, forKey: "playMethod")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(canSeek, forKey: "canSeek")
                return encoder.items
            }
        }

        /// Reports that a user has stopped playing an item.
        public func delete(parameters: DeleteParameters? = nil) -> Request<Void> {
            .delete(path, query: parameters?.asQuery)
        }

        public struct DeleteParameters {
            /// The id of the MediaSource.
            public var mediaSourceID: String?
            /// The next media type that will play.
            public var nextMediaType: String?
            /// Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms.
            public var positionTicks: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// The play session id.
            public var playSessionID: String?

            public init(mediaSourceID: String? = nil, nextMediaType: String? = nil, positionTicks: Int? = nil, liveStreamID: String? = nil, playSessionID: String? = nil) {
                self.mediaSourceID = mediaSourceID
                self.nextMediaType = nextMediaType
                self.positionTicks = positionTicks
                self.liveStreamID = liveStreamID
                self.playSessionID = playSessionID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(nextMediaType, forKey: "nextMediaType")
                encoder.encode(positionTicks, forKey: "positionTicks")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                return encoder.items
            }
        }
    }
}

extension Paths.Shows {
    public var upcoming: Upcoming {
        Upcoming(path: path + "/Upcoming")
    }

    public struct Upcoming {
        /// Path: `/Shows/Upcoming`
        public let path: String

        /// Gets a list of upcoming episodes.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The user id of the user to get the upcoming episodes for.
            public var userID: String?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Include image information in output.
            public var enableImges: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Include user data.
            public var enableUserData: Bool?

            public init(userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, parentID: String? = nil, enableImges: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil) {
                self.userID = userID
                self.startIndex = startIndex
                self.limit = limit
                self.fields = fields
                self.parentID = parentID
                self.enableImges = enableImges
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.enableUserData = enableUserData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(enableImges, forKey: "enableImges")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(enableUserData, forKey: "enableUserData")
                return encoder.items
            }
        }
    }
}

extension Paths.Dlna.WithServerID {
    public var connectionManager: ConnectionManager {
        ConnectionManager(path: path + "/ConnectionManager")
    }

    public struct ConnectionManager {
        /// Path: `/Dlna/{serverId}/ConnectionManager`
        public let path: String

        /// Gets Dlna media receiver registrar xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Videos.WithItemID {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/Videos/{itemId}/stream`
        public let path: String

        /// Gets a video stream.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
            public var container: String?
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. The maximum horizontal resolution of the encoded video.
            public var maxWidth: Int?
            /// Optional. The maximum vertical resolution of the encoded video.
            public var maxHeight: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.container = container
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(container, forKey: "container")
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }

        /// Gets a video stream.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
            public var container: String?
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. The maximum horizontal resolution of the encoded video.
            public var maxWidth: Int?
            /// Optional. The maximum vertical resolution of the encoded video.
            public var maxHeight: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.container = container
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(container, forKey: "container")
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithItemID {
    public var remoteImages: RemoteImages {
        RemoteImages(path: path + "/RemoteImages")
    }

    public struct RemoteImages {
        /// Path: `/Items/{itemId}/RemoteImages`
        public let path: String

        /// Gets available remote images for an item.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.RemoteImageResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The image type.
            public var type: `Type`?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. The image provider to use.
            public var providerName: String?
            /// Optional. Include all languages.
            public var isIncludeAllLanguages: Bool?

            public typealias `Type` = JellyfinAPI.ImageType

            public init(type: `Type`? = nil, startIndex: Int? = nil, limit: Int? = nil, providerName: String? = nil, isIncludeAllLanguages: Bool? = nil) {
                self.type = type
                self.startIndex = startIndex
                self.limit = limit
                self.providerName = providerName
                self.isIncludeAllLanguages = isIncludeAllLanguages
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(providerName, forKey: "providerName")
                encoder.encode(isIncludeAllLanguages, forKey: "includeAllLanguages")
                return encoder.items
            }
        }
    }
}

extension Paths.Library {
    public var mediaFolders: MediaFolders {
        MediaFolders(path: path + "/MediaFolders")
    }

    public struct MediaFolders {
        /// Path: `/Library/MediaFolders`
        public let path: String

        /// Gets all user media folders.
        public func get(isHidden: Bool? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: makeGetQuery(isHidden))
        }

        private func makeGetQuery(_ isHidden: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isHidden, forKey: "isHidden")
            return encoder.items
        }
    }
}

extension Paths.Items.RemoteSearch {
    public var book: Book {
        Book(path: path + "/Book")
    }

    public struct Book {
        /// Path: `/Items/RemoteSearch/Book`
        public let path: String

        /// Get book remote search.
        public func post(_ body: JellyfinAPI.BookInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Shows {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Shows/{itemId}`
        public let path: String
    }
}

extension Paths.Shows.WithItemID {
    public var similar: Similar {
        Similar(path: path + "/Similar")
    }

    public struct Similar {
        /// Path: `/Shows/{itemId}/Similar`
        public let path: String

        /// Gets similar items.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Exclude artist ids.
            public var excludeArtistIDs: [String]?
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
            public var fields: [JellyfinAPI.ItemFields]?

            public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
                self.excludeArtistIDs = excludeArtistIDs
                self.userID = userID
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Dlna.WithServerID {
    public var description: Description {
        Description(path: path + "/description")
    }

    public struct Description {
        /// Path: `/Dlna/{serverId}/description`
        public let path: String

        /// Get Description Xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Sessions.WithSessionID {
    public var system: System {
        System(path: path + "/System")
    }

    public struct System {
        /// Path: `/Sessions/{sessionId}/System`
        public let path: String
    }
}

extension Paths.Sessions.WithSessionID.System {
    public func command(_ command: String) -> WithCommand {
        WithCommand(path: "\(path)/\(command)")
    }

    public struct WithCommand {
        /// Path: `/Sessions/{sessionId}/System/{command}`
        public let path: String

        /// Issues a system command to a client.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.LiveTv.ListingProviders {
    public var schedulesDirect: SchedulesDirect {
        SchedulesDirect(path: path + "/SchedulesDirect")
    }

    public struct SchedulesDirect {
        /// Path: `/LiveTv/ListingProviders/SchedulesDirect`
        public let path: String
    }
}

extension Paths.LiveTv.ListingProviders.SchedulesDirect {
    public var countries: Countries {
        Countries(path: path + "/Countries")
    }

    public struct Countries {
        /// Path: `/LiveTv/ListingProviders/SchedulesDirect/Countries`
        public let path: String

        /// Gets available countries.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var favoriteItems: FavoriteItems {
        FavoriteItems(path: path + "/FavoriteItems")
    }

    public struct FavoriteItems {
        /// Path: `/Users/{userId}/FavoriteItems`
        public let path: String
    }
}

extension Paths.Users.WithUserID.FavoriteItems {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Users/{userId}/FavoriteItems/{itemId}`
        public let path: String

        /// Marks an item as a favorite.
        public var post: Request<JellyfinAPI.UserItemDataDto> {
            .post(path)
        }

        /// Unmarks item as a favorite.
        public var delete: Request<JellyfinAPI.UserItemDataDto> {
            .delete(path)
        }
    }
}

extension Paths.Packages {
    public var installing: Installing {
        Installing(path: path + "/Installing")
    }

    public struct Installing {
        /// Path: `/Packages/Installing`
        public let path: String
    }
}

extension Paths.Packages.Installing {
    public func packageID(_ packageID: String) -> WithPackageID {
        WithPackageID(path: "\(path)/\(packageID)")
    }

    public struct WithPackageID {
        /// Path: `/Packages/Installing/{packageId}`
        public let path: String

        /// Cancels a package installation.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Items.WithItemID {
    public var playbackInfo: PlaybackInfo {
        PlaybackInfo(path: path + "/PlaybackInfo")
    }

    public struct PlaybackInfo {
        /// Path: `/Items/{itemId}/PlaybackInfo`
        public let path: String

        /// Gets live playback media info for an item.
        public func get(userID: String) -> Request<JellyfinAPI.PlaybackInfoResponse> {
            .get(path, query: [("userId", userID)])
        }

        /// Gets live playback media info for an item.
        ///
        /// For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
Query parameters are obsolete.
        public func post(parameters: PostParameters? = nil, _ body: JellyfinAPI.PlaybackInfoDto? = nil) -> Request<JellyfinAPI.PlaybackInfoResponse> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            /// The user id.
            public var userID: String?
            /// The maximum streaming bitrate.
            public var maxStreamingBitrate: Int?
            /// The start time in ticks.
            public var startTimeTicks: Int?
            /// The audio stream index.
            public var audioStreamIndex: Int?
            /// The subtitle stream index.
            public var subtitleStreamIndex: Int?
            /// The maximum number of audio channels.
            public var maxAudioChannels: Int?
            /// The media source id.
            public var mediaSourceID: String?
            /// The livestream id.
            public var liveStreamID: String?
            /// Whether to auto open the livestream.
            public var isAutoOpenLiveStream: Bool?
            /// Whether to enable direct play. Default: true.
            public var enableDirectPlay: Bool?
            /// Whether to enable direct stream. Default: true.
            public var enableDirectStream: Bool?
            /// Whether to enable transcoding. Default: true.
            public var enableTranscoding: Bool?
            /// Whether to allow to copy the video stream. Default: true.
            public var allowVideoStreamCopy: Bool?
            /// Whether to allow to copy the audio stream. Default: true.
            public var allowAudioStreamCopy: Bool?

            public init(userID: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, mediaSourceID: String? = nil, liveStreamID: String? = nil, isAutoOpenLiveStream: Bool? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, enableTranscoding: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil) {
                self.userID = userID
                self.maxStreamingBitrate = maxStreamingBitrate
                self.startTimeTicks = startTimeTicks
                self.audioStreamIndex = audioStreamIndex
                self.subtitleStreamIndex = subtitleStreamIndex
                self.maxAudioChannels = maxAudioChannels
                self.mediaSourceID = mediaSourceID
                self.liveStreamID = liveStreamID
                self.isAutoOpenLiveStream = isAutoOpenLiveStream
                self.enableDirectPlay = enableDirectPlay
                self.enableDirectStream = enableDirectStream
                self.enableTranscoding = enableTranscoding
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(isAutoOpenLiveStream, forKey: "autoOpenLiveStream")
                encoder.encode(enableDirectPlay, forKey: "enableDirectPlay")
                encoder.encode(enableDirectStream, forKey: "enableDirectStream")
                encoder.encode(enableTranscoding, forKey: "enableTranscoding")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                return encoder.items
            }
        }
    }
}

extension Paths.LiveTv.Timers {
    public func timerID(_ timerID: String) -> WithTimerID {
        WithTimerID(path: "\(path)/\(timerID)")
    }

    public struct WithTimerID {
        /// Path: `/LiveTv/Timers/{timerId}`
        public let path: String

        /// Gets a timer.
        public var get: Request<JellyfinAPI.TimerInfoDto> {
            .get(path)
        }

        /// Updates a live tv timer.
        public func post(_ body: JellyfinAPI.TimerInfoDto? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Cancels a live tv timer.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Videos.WithItemID {
    public var alternateSources: AlternateSources {
        AlternateSources(path: path + "/AlternateSources")
    }

    public struct AlternateSources {
        /// Path: `/Videos/{itemId}/AlternateSources`
        public let path: String

        /// Removes alternate video sources.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.SyncPlay {
    public var setPlaylistItem: SetPlaylistItem {
        SetPlaylistItem(path: path + "/SetPlaylistItem")
    }

    public struct SetPlaylistItem {
        /// Path: `/SyncPlay/SetPlaylistItem`
        public let path: String

        /// Request to change playlist item in SyncPlay group.
        public func post(_ body: JellyfinAPI.SetPlaylistItemRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Sessions {
    public var viewing: Viewing {
        Viewing(path: path + "/Viewing")
    }

    public struct Viewing {
        /// Path: `/Sessions/Viewing`
        public let path: String

        /// Reports that a session is viewing an item.
        public func post(sessionID: String? = nil, itemID: String) -> Request<Void> {
            .post(path, query: makePostQuery(sessionID, itemID))
        }

        private func makePostQuery(_ sessionID: String?, _ itemID: String) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(sessionID, forKey: "sessionId")
            encoder.encode(itemID, forKey: "itemId")
            return encoder.items
        }
    }
}

extension Paths.Auth.Keys {
    public func key(_ key: String) -> WithKey {
        WithKey(path: "\(path)/\(key)")
    }

    public struct WithKey {
        /// Path: `/Auth/Keys/{key}`
        public let path: String

        /// Remove an api key.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.SyncPlay {
    public var buffering: Buffering {
        Buffering(path: path + "/Buffering")
    }

    public struct Buffering {
        /// Path: `/SyncPlay/Buffering`
        public let path: String

        /// Notify SyncPlay group that member is buffering.
        public func post(_ body: JellyfinAPI.BufferRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Items.RemoteSearch {
    public var apply: Apply {
        Apply(path: path + "/Apply")
    }

    public struct Apply {
        /// Path: `/Items/RemoteSearch/Apply`
        public let path: String
    }
}

extension Paths.Items.RemoteSearch.Apply {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Items/RemoteSearch/Apply/{itemId}`
        public let path: String

        /// Applies search criteria to an item and refreshes metadata.
        public func post(isReplaceAllImages: Bool? = nil, _ body: JellyfinAPI.RemoteSearchResult) -> Request<Void> {
            .post(path, query: makePostQuery(isReplaceAllImages), body: body)
        }

        private func makePostQuery(_ isReplaceAllImages: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isReplaceAllImages, forKey: "replaceAllImages")
            return encoder.items
        }
    }
}

extension Paths.Sessions {
    public var logout: Logout {
        Logout(path: path + "/Logout")
    }

    public struct Logout {
        /// Path: `/Sessions/Logout`
        public let path: String

        /// Reports that a session has ended.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Images {
    public var ratings: Ratings {
        Ratings(path: path + "/Ratings")
    }

    public struct Ratings {
        /// Path: `/Images/Ratings`
        public let path: String

        /// Get all general images.
        public var get: Request<[JellyfinAPI.ImageByNameInfo]> {
            .get(path)
        }
    }
}

extension Paths.SyncPlay {
    public var new: New {
        New(path: path + "/New")
    }

    public struct New {
        /// Path: `/SyncPlay/New`
        public let path: String

        /// Create a new SyncPlay group.
        public func post(_ body: JellyfinAPI.NewGroupRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Items.RemoteSearch {
    public var trailer: Trailer {
        Trailer(path: path + "/Trailer")
    }

    public struct Trailer {
        /// Path: `/Items/RemoteSearch/Trailer`
        public let path: String

        /// Get trailer remote search.
        public func post(_ body: JellyfinAPI.TrailerInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Persons.WithName {
    public var images: Images {
        Images(path: path + "/Images")
    }

    public struct Images {
        /// Path: `/Persons/{name}/Images`
        public let path: String
    }
}

extension Paths.Persons.WithName.Images {
    public func imageType(_ imageType: String) -> WithImageType {
        WithImageType(path: "\(path)/\(imageType)")
    }

    public struct WithImageType {
        /// Path: `/Persons/{name}/Images/{imageType}`
        public let path: String

        /// Get person image by name.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }

        /// Get person image by name.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }
    }
}

extension Paths.Videos {
    public var activeEncodings: ActiveEncodings {
        ActiveEncodings(path: path + "/ActiveEncodings")
    }

    public struct ActiveEncodings {
        /// Path: `/Videos/ActiveEncodings`
        public let path: String

        /// Stops an active encoding.
        public func delete(deviceID: String, playSessionID: String) -> Request<Void> {
            .delete(path, query: [("deviceId", deviceID), ("playSessionId", playSessionID)])
        }
    }
}

extension Paths.Artists {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/Artists/{name}`
        public let path: String

        /// Gets an artist by name.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.LiveTv.Recordings {
    public var groups: Groups {
        Groups(path: path + "/Groups")
    }

    public struct Groups {
        /// Path: `/LiveTv/Recordings/Groups`
        public let path: String

        /// Gets live tv recording groups.
        @available(*, deprecated, message: "Deprecated")
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.Dlna {
    public var profiles: Profiles {
        Profiles(path: path + "/Profiles")
    }

    public struct Profiles {
        /// Path: `/Dlna/Profiles`
        public let path: String

        /// Creates a profile.
        public func post(_ body: JellyfinAPI.DeviceProfile? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Audio.WithItemID {
    public var mainM3u8: MainM3u8 {
        MainM3u8(path: path + "/main.m3u8")
    }

    public struct MainM3u8 {
        /// Path: `/Audio/{itemId}/main.m3u8`
        public let path: String

        /// Gets an audio stream using HTTP live streaming.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment length.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. The maximum streaming bitrate.
            public var maxStreamingBitrate: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.maxStreamingBitrate = maxStreamingBitrate
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithItemID {
    public var themeSongs: ThemeSongs {
        ThemeSongs(path: path + "/ThemeSongs")
    }

    public struct ThemeSongs {
        /// Path: `/Items/{itemId}/ThemeSongs`
        public let path: String

        /// Get theme songs for an item.
        public func get(userID: String? = nil, isInheritFromParent: Bool? = nil) -> Request<JellyfinAPI.ThemeMediaResult> {
            .get(path, query: makeGetQuery(userID, isInheritFromParent))
        }

        private func makeGetQuery(_ userID: String?, _ isInheritFromParent: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(isInheritFromParent, forKey: "inheritFromParent")
            return encoder.items
        }
    }
}

extension Paths {
    public static var channels: Channels {
        Channels(path: "/Channels")
    }

    public struct Channels {
        /// Path: `/Channels`
        public let path: String

        /// Gets available channels.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// User Id to filter by. Use System.Guid.Empty to not filter by user.
            public var userID: String?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Filter by channels that support getting latest items.
            public var isSupportsLatestItems: Bool?
            /// Optional. Filter by channels that support media deletion.
            public var isSupportsMediaDeletion: Bool?
            /// Optional. Filter by channels that are favorite.
            public var isFavorite: Bool?

            public init(userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, isSupportsLatestItems: Bool? = nil, isSupportsMediaDeletion: Bool? = nil, isFavorite: Bool? = nil) {
                self.userID = userID
                self.startIndex = startIndex
                self.limit = limit
                self.isSupportsLatestItems = isSupportsLatestItems
                self.isSupportsMediaDeletion = isSupportsMediaDeletion
                self.isFavorite = isFavorite
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isSupportsLatestItems, forKey: "supportsLatestItems")
                encoder.encode(isSupportsMediaDeletion, forKey: "supportsMediaDeletion")
                encoder.encode(isFavorite, forKey: "isFavorite")
                return encoder.items
            }
        }
    }
}

extension Paths.Channels {
    public var features: Features {
        Features(path: path + "/Features")
    }

    public struct Features {
        /// Path: `/Channels/Features`
        public let path: String

        /// Get all channel features.
        public var get: Request<[JellyfinAPI.ChannelFeatures]> {
            .get(path)
        }
    }
}

extension Paths.Dlna {
    public var profileInfos: ProfileInfos {
        ProfileInfos(path: path + "/ProfileInfos")
    }

    public struct ProfileInfos {
        /// Path: `/Dlna/ProfileInfos`
        public let path: String

        /// Get profile infos.
        public var get: Request<[JellyfinAPI.DeviceProfileInfo]> {
            .get(path)
        }
    }
}

extension Paths.Items {
    public var filters: Filters {
        Filters(path: path + "/Filters")
    }

    public struct Filters {
        /// Path: `/Items/Filters`
        public let path: String

        /// Gets legacy query filters.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.QueryFiltersLegacy> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. User id.
            public var userID: String?
            /// Optional. Parent id.
            public var parentID: String?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional. Filter by MediaType. Allows multiple, comma delimited.
            public var mediaTypes: [String]?

            public init(userID: String? = nil, parentID: String? = nil, includeItemTypes: [String]? = nil, mediaTypes: [String]? = nil) {
                self.userID = userID
                self.parentID = parentID
                self.includeItemTypes = includeItemTypes
                self.mediaTypes = mediaTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(mediaTypes, forKey: "mediaTypes")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var years: Years {
        Years(path: "/Years")
    }

    public struct Years {
        /// Path: `/Years`
        public let path: String

        /// Get years.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Skips over a given number of items within the results. Use for paging.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Sort Order - Ascending,Descending.
            public var sortOrder: [JellyfinAPI.SortOrder]?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
            public var excludeItemTypes: [String]?
            /// Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional. Filter by MediaType. Allows multiple, comma delimited.
            public var mediaTypes: [String]?
            /// Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
            public var sortBy: [String]?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// User Id.
            public var userID: String?
            /// Search recursively.
            public var isRecursive: Bool?
            /// Optional. Include image information in output.
            public var enableImages: Bool?

            public init(startIndex: Int? = nil, limit: Int? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, mediaTypes: [String]? = nil, sortBy: [String]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, userID: String? = nil, isRecursive: Bool? = nil, enableImages: Bool? = nil) {
                self.startIndex = startIndex
                self.limit = limit
                self.sortOrder = sortOrder
                self.parentID = parentID
                self.fields = fields
                self.excludeItemTypes = excludeItemTypes
                self.includeItemTypes = includeItemTypes
                self.mediaTypes = mediaTypes
                self.sortBy = sortBy
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.userID = userID
                self.isRecursive = isRecursive
                self.enableImages = enableImages
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(sortOrder, forKey: "sortOrder")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(mediaTypes, forKey: "mediaTypes")
                encoder.encode(sortBy, forKey: "sortBy")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(isRecursive, forKey: "recursive")
                encoder.encode(enableImages, forKey: "enableImages")
                return encoder.items
            }
        }
    }
}

extension Paths.Notifications.WithUserID {
    public var unread: Unread {
        Unread(path: path + "/Unread")
    }

    public struct Unread {
        /// Path: `/Notifications/{userId}/Unread`
        public let path: String

        /// Sets notifications as unread.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Items.WithItemID {
    public var download: Download {
        Download(path: path + "/Download")
    }

    public struct Download {
        /// Path: `/Items/{itemId}/Download`
        public let path: String

        /// Downloads item media.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.LiveTv {
    public var liveRecordings: LiveRecordings {
        LiveRecordings(path: path + "/LiveRecordings")
    }

    public struct LiveRecordings {
        /// Path: `/LiveTv/LiveRecordings`
        public let path: String
    }
}

extension Paths.LiveTv.LiveRecordings {
    public func recordingID(_ recordingID: String) -> WithRecordingID {
        WithRecordingID(path: "\(path)/\(recordingID)")
    }

    public struct WithRecordingID {
        /// Path: `/LiveTv/LiveRecordings/{recordingId}`
        public let path: String
    }
}

extension Paths.LiveTv.LiveRecordings.WithRecordingID {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/LiveTv/LiveRecordings/{recordingId}/stream`
        public let path: String

        /// Gets a live tv recording stream.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.SyncPlay {
    public var seek: Seek {
        Seek(path: path + "/Seek")
    }

    public struct Seek {
        /// Path: `/SyncPlay/Seek`
        public let path: String

        /// Request seek in SyncPlay group.
        public func post(_ body: JellyfinAPI.SeekRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithUserID {
    public var groupingOptions: GroupingOptions {
        GroupingOptions(path: path + "/GroupingOptions")
    }

    public struct GroupingOptions {
        /// Path: `/Users/{userId}/GroupingOptions`
        public let path: String

        /// Get user view grouping options.
        public var get: Request<[JellyfinAPI.SpecialViewOptionDto]> {
            .get(path)
        }
    }
}

extension Paths.Branding {
    public var cssCss: CssCss {
        CssCss(path: path + "/Css.css")
    }

    public struct CssCss {
        /// Path: `/Branding/Css.css`
        public let path: String

        /// Gets branding css.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Playlists {
    public func playlistID(_ playlistID: String) -> WithPlaylistID {
        WithPlaylistID(path: "\(path)/\(playlistID)")
    }

    public struct WithPlaylistID {
        /// Path: `/Playlists/{playlistId}`
        public let path: String
    }
}

extension Paths.Playlists.WithPlaylistID.Items {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Playlists/{playlistId}/Items/{itemId}`
        public let path: String
    }
}

extension Paths.Playlists.WithPlaylistID.Items.WithItemID {
    public var move: Move {
        Move(path: path + "/Move")
    }

    public struct Move {
        /// Path: `/Playlists/{playlistId}/Items/{itemId}/Move`
        public let path: String
    }
}

extension Paths.Playlists.WithPlaylistID.Items.WithItemID.Move {
    public func newIndex(_ newIndex: Int) -> WithNewIndex {
        WithNewIndex(path: "\(path)/\(newIndex)")
    }

    public struct WithNewIndex {
        /// Path: `/Playlists/{playlistId}/Items/{itemId}/Move/{newIndex}`
        public let path: String

        /// Moves a playlist item.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.SyncPlay {
    public var nextItem: NextItem {
        NextItem(path: path + "/NextItem")
    }

    public struct NextItem {
        /// Path: `/SyncPlay/NextItem`
        public let path: String

        /// Request next item in SyncPlay group.
        public func post(_ body: JellyfinAPI.NextItemRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Sessions.Playing {
    public var ping: Ping {
        Ping(path: path + "/Ping")
    }

    public struct Ping {
        /// Path: `/Sessions/Playing/Ping`
        public let path: String

        /// Pings a playback session.
        public func post(playSessionID: String) -> Request<Void> {
            .post(path, query: [("playSessionId", playSessionID)])
        }
    }
}

extension Paths {
    public static var songs: Songs {
        Songs(path: "/Songs")
    }

    public struct Songs {
        /// Path: `/Songs`
        public let path: String
    }
}

extension Paths.Songs {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/Songs/{id}`
        public let path: String
    }
}

extension Paths.Songs.WithID {
    public var instantMix: InstantMix {
        InstantMix(path: path + "/InstantMix")
    }

    public struct InstantMix {
        /// Path: `/Songs/{id}/InstantMix`
        public let path: String

        /// Creates an instant playlist based on a given song.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.userID = userID
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }
    }
}

extension Paths.Videos.WithItemID {
    public var liveM3u8: LiveM3u8 {
        LiveM3u8(path: path + "/live.m3u8")
    }

    public struct LiveM3u8 {
        /// Path: `/Videos/{itemId}/live.m3u8`
        public let path: String

        /// Gets a hls live stream.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The audio container.
            public var container: String?
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment lenght.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamorphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?
            /// Optional. The max width.
            public var maxWidth: Int?
            /// Optional. The max height.
            public var maxHeight: Int?
            /// Optional. Whether to enable subtitles in the manifest.
            public var enableSubtitlesInManifest: Bool?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, enableSubtitlesInManifest: Bool? = nil) {
                self.container = container
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.enableSubtitlesInManifest = enableSubtitlesInManifest
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(container, forKey: "container")
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(enableSubtitlesInManifest, forKey: "enableSubtitlesInManifest")
                return encoder.items
            }
        }
    }
}

extension Paths.System.Configuration {
    public var metadataOptions: MetadataOptions {
        MetadataOptions(path: path + "/MetadataOptions")
    }

    public struct MetadataOptions {
        /// Path: `/System/Configuration/MetadataOptions`
        public let path: String
    }
}

extension Paths.System.Configuration.MetadataOptions {
    public var `default`: Default {
        Default(path: path + "/Default")
    }

    public struct Default {
        /// Path: `/System/Configuration/MetadataOptions/Default`
        public let path: String

        /// Gets a default MetadataOptions object.
        public var get: Request<JellyfinAPI.MetadataOptions> {
            .get(path)
        }
    }
}

extension Paths.MusicGenres.WithName {
    public var instantMix: InstantMix {
        InstantMix(path: path + "/InstantMix")
    }

    public struct InstantMix {
        /// Path: `/MusicGenres/{name}/InstantMix`
        public let path: String

        /// Creates an instant playlist based on a given genre.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.userID = userID
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }
    }
}

extension Paths.Audio.WithItemID {
    public var universal: Universal {
        Universal(path: path + "/universal")
    }

    public struct Universal {
        /// Path: `/Audio/{itemId}/universal`
        public let path: String

        /// Gets an audio stream.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. The audio container.
            public var container: [String]?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. The user id.
            public var userID: String?
            /// Optional. The audio codec to transcode to.
            public var audioCodec: String?
            /// Optional. The maximum number of audio channels.
            public var maxAudioChannels: Int?
            /// Optional. The number of how many audio channels to transcode to.
            public var transcodingAudioChannels: Int?
            /// Optional. The maximum streaming bitrate.
            public var maxStreamingBitrate: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The container to transcode to.
            public var transcodingContainer: String?
            /// Optional. The transcoding protocol.
            public var transcodingProtocol: String?
            /// Optional. The maximum audio sample rate.
            public var maxAudioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Whether to enable remote media.
            public var enableRemoteMedia: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Whether to enable redirection. Defaults to true.
            public var enableRedirection: Bool?

            public init(container: [String]? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, userID: String? = nil, audioCodec: String? = nil, maxAudioChannels: Int? = nil, transcodingAudioChannels: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, startTimeTicks: Int? = nil, transcodingContainer: String? = nil, transcodingProtocol: String? = nil, maxAudioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, enableRemoteMedia: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, enableRedirection: Bool? = nil) {
                self.container = container
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.userID = userID
                self.audioCodec = audioCodec
                self.maxAudioChannels = maxAudioChannels
                self.transcodingAudioChannels = transcodingAudioChannels
                self.maxStreamingBitrate = maxStreamingBitrate
                self.audioBitRate = audioBitRate
                self.startTimeTicks = startTimeTicks
                self.transcodingContainer = transcodingContainer
                self.transcodingProtocol = transcodingProtocol
                self.maxAudioSampleRate = maxAudioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.enableRemoteMedia = enableRemoteMedia
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.enableRedirection = enableRedirection
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(container, forKey: "container")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(transcodingAudioChannels, forKey: "transcodingAudioChannels")
                encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(transcodingContainer, forKey: "transcodingContainer")
                encoder.encode(transcodingProtocol, forKey: "transcodingProtocol")
                encoder.encode(maxAudioSampleRate, forKey: "maxAudioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(enableRemoteMedia, forKey: "enableRemoteMedia")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(enableRedirection, forKey: "enableRedirection")
                return encoder.items
            }
        }

        /// Gets an audio stream.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. The audio container.
            public var container: [String]?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. The user id.
            public var userID: String?
            /// Optional. The audio codec to transcode to.
            public var audioCodec: String?
            /// Optional. The maximum number of audio channels.
            public var maxAudioChannels: Int?
            /// Optional. The number of how many audio channels to transcode to.
            public var transcodingAudioChannels: Int?
            /// Optional. The maximum streaming bitrate.
            public var maxStreamingBitrate: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The container to transcode to.
            public var transcodingContainer: String?
            /// Optional. The transcoding protocol.
            public var transcodingProtocol: String?
            /// Optional. The maximum audio sample rate.
            public var maxAudioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Whether to enable remote media.
            public var enableRemoteMedia: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Whether to enable redirection. Defaults to true.
            public var enableRedirection: Bool?

            public init(container: [String]? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, userID: String? = nil, audioCodec: String? = nil, maxAudioChannels: Int? = nil, transcodingAudioChannels: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, startTimeTicks: Int? = nil, transcodingContainer: String? = nil, transcodingProtocol: String? = nil, maxAudioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, enableRemoteMedia: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, enableRedirection: Bool? = nil) {
                self.container = container
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.userID = userID
                self.audioCodec = audioCodec
                self.maxAudioChannels = maxAudioChannels
                self.transcodingAudioChannels = transcodingAudioChannels
                self.maxStreamingBitrate = maxStreamingBitrate
                self.audioBitRate = audioBitRate
                self.startTimeTicks = startTimeTicks
                self.transcodingContainer = transcodingContainer
                self.transcodingProtocol = transcodingProtocol
                self.maxAudioSampleRate = maxAudioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.enableRemoteMedia = enableRemoteMedia
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.enableRedirection = enableRedirection
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(container, forKey: "container")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(transcodingAudioChannels, forKey: "transcodingAudioChannels")
                encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(transcodingContainer, forKey: "transcodingContainer")
                encoder.encode(transcodingProtocol, forKey: "transcodingProtocol")
                encoder.encode(maxAudioSampleRate, forKey: "maxAudioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(enableRemoteMedia, forKey: "enableRemoteMedia")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(enableRedirection, forKey: "enableRedirection")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithItemID {
    public var file: File {
        File(path: path + "/File")
    }

    public struct File {
        /// Path: `/Items/{itemId}/File`
        public let path: String

        /// Get the original file of an item.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Items {
    public var filters2: Filters2 {
        Filters2(path: path + "/Filters2")
    }

    public struct Filters2 {
        /// Path: `/Items/Filters2`
        public let path: String

        /// Gets query filters.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.QueryFilters> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. User id.
            public var userID: String?
            /// Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional. Is item airing.
            public var isAiring: Bool?
            /// Optional. Is item movie.
            public var isMovie: Bool?
            /// Optional. Is item sports.
            public var isSports: Bool?
            /// Optional. Is item kids.
            public var isKids: Bool?
            /// Optional. Is item news.
            public var isNews: Bool?
            /// Optional. Is item series.
            public var isSeries: Bool?
            /// Optional. Search recursive.
            public var isRecursive: Bool?

            public init(userID: String? = nil, parentID: String? = nil, includeItemTypes: [String]? = nil, isAiring: Bool? = nil, isMovie: Bool? = nil, isSports: Bool? = nil, isKids: Bool? = nil, isNews: Bool? = nil, isSeries: Bool? = nil, isRecursive: Bool? = nil) {
                self.userID = userID
                self.parentID = parentID
                self.includeItemTypes = includeItemTypes
                self.isAiring = isAiring
                self.isMovie = isMovie
                self.isSports = isSports
                self.isKids = isKids
                self.isNews = isNews
                self.isSeries = isSeries
                self.isRecursive = isRecursive
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(isAiring, forKey: "isAiring")
                encoder.encode(isMovie, forKey: "isMovie")
                encoder.encode(isSports, forKey: "isSports")
                encoder.encode(isKids, forKey: "isKids")
                encoder.encode(isNews, forKey: "isNews")
                encoder.encode(isSeries, forKey: "isSeries")
                encoder.encode(isRecursive, forKey: "recursive")
                return encoder.items
            }
        }
    }
}

extension Paths.Studios {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/Studios/{name}`
        public let path: String

        /// Gets a studio by name.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.Images {
    public var mediaInfo: MediaInfo {
        MediaInfo(path: path + "/MediaInfo")
    }

    public struct MediaInfo {
        /// Path: `/Images/MediaInfo`
        public let path: String

        /// Get all media info images.
        public var get: Request<[JellyfinAPI.ImageByNameInfo]> {
            .get(path)
        }
    }
}

extension Paths.Dlna {
    public var icons: Icons {
        Icons(path: path + "/icons")
    }

    public struct Icons {
        /// Path: `/Dlna/icons`
        public let path: String
    }
}

extension Paths.Dlna.Icons {
    public func fileName(_ fileName: String) -> WithFileName {
        WithFileName(path: "\(path)/\(fileName)")
    }

    public struct WithFileName {
        /// Path: `/Dlna/icons/{fileName}`
        public let path: String

        /// Gets a server icon.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.MusicGenres {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/MusicGenres/{id}`
        public let path: String
    }
}

extension Paths.MusicGenres.WithID {
    public var instantMix: InstantMix {
        InstantMix(path: path + "/InstantMix")
    }

    public struct InstantMix {
        /// Path: `/MusicGenres/{id}/InstantMix`
        public let path: String

        /// Creates an instant playlist based on a given genre.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.userID = userID
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }
    }
}

extension Paths.System {
    public var endpoint: Endpoint {
        Endpoint(path: path + "/Endpoint")
    }

    public struct Endpoint {
        /// Path: `/System/Endpoint`
        public let path: String

        /// Gets information about the request endpoint.
        public var get: Request<JellyfinAPI.EndPointInfo> {
            .get(path)
        }
    }
}

extension Paths.System {
    public var info: Info {
        Info(path: path + "/Info")
    }

    public struct Info {
        /// Path: `/System/Info`
        public let path: String

        /// Gets information about the server.
        public var get: Request<JellyfinAPI.SystemInfo> {
            .get(path)
        }
    }
}

extension Paths.Items {
    public var counts: Counts {
        Counts(path: path + "/Counts")
    }

    public struct Counts {
        /// Path: `/Items/Counts`
        public let path: String

        /// Get item counts.
        public func get(userID: String? = nil, isFavorite: Bool? = nil) -> Request<JellyfinAPI.ItemCounts> {
            .get(path, query: makeGetQuery(userID, isFavorite))
        }

        private func makeGetQuery(_ userID: String?, _ isFavorite: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(isFavorite, forKey: "isFavorite")
            return encoder.items
        }
    }
}

extension Paths {
    public static var genres: Genres {
        Genres(path: "/Genres")
    }

    public struct Genres {
        /// Path: `/Genres`
        public let path: String

        /// Gets all genres from a given item, folder, or the entire library.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// The search term.
            public var searchTerm: String?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
            public var excludeItemTypes: [String]?
            /// Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional filter by items that are marked as favorite, or not.
            public var isFavorite: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// User id.
            public var userID: String?
            /// Optional filter by items whose name is sorted equally or greater than a given input string.
            public var nameStartsWithOrGreater: String?
            /// Optional filter by items whose name is sorted equally than a given input string.
            public var nameStartsWith: String?
            /// Optional filter by items whose name is equally or lesser than a given input string.
            public var nameLessThan: String?
            /// Optional, include image information in output.
            public var enableImages: Bool?
            /// Optional. Include total record count.
            public var enableTotalRecordCount: Bool?

            public init(startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, isFavorite: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
                self.startIndex = startIndex
                self.limit = limit
                self.searchTerm = searchTerm
                self.parentID = parentID
                self.fields = fields
                self.excludeItemTypes = excludeItemTypes
                self.includeItemTypes = includeItemTypes
                self.isFavorite = isFavorite
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.userID = userID
                self.nameStartsWithOrGreater = nameStartsWithOrGreater
                self.nameStartsWith = nameStartsWith
                self.nameLessThan = nameLessThan
                self.enableImages = enableImages
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
                encoder.encode(nameStartsWith, forKey: "nameStartsWith")
                encoder.encode(nameLessThan, forKey: "nameLessThan")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }
    }
}

extension Paths.LiveTv.Recordings {
    public var folders: Folders {
        Folders(path: path + "/Folders")
    }

    public struct Folders {
        /// Path: `/LiveTv/Recordings/Folders`
        public let path: String

        /// Gets recording folders.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.Sessions.WithSessionID {
    public var playing: Playing {
        Playing(path: path + "/Playing")
    }

    public struct Playing {
        /// Path: `/Sessions/{sessionId}/Playing`
        public let path: String

        /// Instructs a session to play an item.
        public func post(parameters: PostParameters) -> Request<Void> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            /// The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
            public var playCommand: PlayCommand
            /// The ids of the items to play, comma delimited.
            public var itemIDs: [String]
            /// The starting position of the first item.
            public var startPositionTicks: Int?
            /// Optional. The media source id.
            public var mediaSourceID: String?
            /// Optional. The index of the audio stream to play.
            public var audioStreamIndex: Int?
            /// Optional. The index of the subtitle stream to play.
            public var subtitleStreamIndex: Int?
            /// Optional. The start index.
            public var startIndex: Int?

            public typealias PlayCommand = JellyfinAPI.PlayCommand

            public init(playCommand: PlayCommand, itemIDs: [String], startPositionTicks: Int? = nil, mediaSourceID: String? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, startIndex: Int? = nil) {
                self.playCommand = playCommand
                self.itemIDs = itemIDs
                self.startPositionTicks = startPositionTicks
                self.mediaSourceID = mediaSourceID
                self.audioStreamIndex = audioStreamIndex
                self.subtitleStreamIndex = subtitleStreamIndex
                self.startIndex = startIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(playCommand, forKey: "playCommand")
                encoder.encode(itemIDs, forKey: "itemIds")
                encoder.encode(startPositionTicks, forKey: "startPositionTicks")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(startIndex, forKey: "startIndex")
                return encoder.items
            }
        }
    }
}

extension Paths.Playlists.WithPlaylistID {
    public var items: Items {
        Items(path: path + "/Items")
    }

    public struct Items {
        /// Path: `/Playlists/{playlistId}/Items`
        public let path: String

        /// Gets the original items of a playlist.
        public func get(parameters: GetParameters) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// User id.
            public var userID: String
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(userID: String, startIndex: Int? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.userID = userID
                self.startIndex = startIndex
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }

        /// Adds items to a playlist.
        public func post(ids: [String]? = nil, userID: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(ids, userID))
        }

        private func makePostQuery(_ ids: [String]?, _ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ids, forKey: "ids")
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }

        /// Removes items from a playlist.
        public func delete(entryIDs: [String]? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(entryIDs))
        }

        private func makeDeleteQuery(_ entryIDs: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(entryIDs, forKey: "entryIds")
            return encoder.items
        }
    }
}

extension Paths.LiveTv {
    public var guideInfo: GuideInfo {
        GuideInfo(path: path + "/GuideInfo")
    }

    public struct GuideInfo {
        /// Path: `/LiveTv/GuideInfo`
        public let path: String

        /// Get guid info.
        public var get: Request<JellyfinAPI.GuideInfo> {
            .get(path)
        }
    }
}

extension Paths.Sessions.WithSessionID.Playing {
    public func command(_ command: String) -> WithCommand {
        WithCommand(path: "\(path)/\(command)")
    }

    public struct WithCommand {
        /// Path: `/Sessions/{sessionId}/Playing/{command}`
        public let path: String

        /// Issues a playstate command to a client.
        public func post(seekPositionTicks: Int? = nil, controllingUserID: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(seekPositionTicks, controllingUserID))
        }

        private func makePostQuery(_ seekPositionTicks: Int?, _ controllingUserID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(seekPositionTicks, forKey: "seekPositionTicks")
            encoder.encode(controllingUserID, forKey: "controllingUserId")
            return encoder.items
        }
    }
}

extension Paths.Items.WithItemID {
    public var refresh: Refresh {
        Refresh(path: path + "/Refresh")
    }

    public struct Refresh {
        /// Path: `/Items/{itemId}/Refresh`
        public let path: String

        /// Refreshes metadata for an item.
        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            /// (Optional) Specifies the metadata refresh mode.
            public var metadataRefreshMode: MetadataRefreshMode?
            /// (Optional) Specifies the image refresh mode.
            public var imageRefreshMode: ImageRefreshMode?
            /// (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
            public var isReplaceAllMetadata: Bool?
            /// (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
            public var isReplaceAllImages: Bool?

            public typealias MetadataRefreshMode = JellyfinAPI.MetadataRefreshMode

            public typealias ImageRefreshMode = JellyfinAPI.MetadataRefreshMode

            public init(metadataRefreshMode: MetadataRefreshMode? = nil, imageRefreshMode: ImageRefreshMode? = nil, isReplaceAllMetadata: Bool? = nil, isReplaceAllImages: Bool? = nil) {
                self.metadataRefreshMode = metadataRefreshMode
                self.imageRefreshMode = imageRefreshMode
                self.isReplaceAllMetadata = isReplaceAllMetadata
                self.isReplaceAllImages = isReplaceAllImages
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(metadataRefreshMode, forKey: "metadataRefreshMode")
                encoder.encode(imageRefreshMode, forKey: "imageRefreshMode")
                encoder.encode(isReplaceAllMetadata, forKey: "replaceAllMetadata")
                encoder.encode(isReplaceAllImages, forKey: "replaceAllImages")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithUserID.Items.WithItemID {
    public var specialFeatures: SpecialFeatures {
        SpecialFeatures(path: path + "/SpecialFeatures")
    }

    public struct SpecialFeatures {
        /// Path: `/Users/{userId}/Items/{itemId}/SpecialFeatures`
        public let path: String

        /// Gets special features for an item.
        public var get: Request<[JellyfinAPI.BaseItemDto]> {
            .get(path)
        }
    }
}

extension Paths.QuickConnect {
    public var status: Status {
        Status(path: path + "/Status")
    }

    public struct Status {
        /// Path: `/QuickConnect/Status`
        public let path: String

        /// Gets the current quick connect state.
        public var get: Request<JellyfinAPI.QuickConnectState> {
            .get(path)
        }
    }
}

extension Paths.LiveTv.Timers {
    public var defaults: Defaults {
        Defaults(path: path + "/Defaults")
    }

    public struct Defaults {
        /// Path: `/LiveTv/Timers/Defaults`
        public let path: String

        /// Gets the default values for a new timer.
        public func get(programID: String? = nil) -> Request<JellyfinAPI.SeriesTimerInfoDto> {
            .get(path, query: makeGetQuery(programID))
        }

        private func makeGetQuery(_ programID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(programID, forKey: "programId")
            return encoder.items
        }
    }
}

extension Paths.Items.WithItemID {
    public var images: Images {
        Images(path: path + "/Images")
    }

    public struct Images {
        /// Path: `/Items/{itemId}/Images`
        public let path: String

        /// Get item image infos.
        public var get: Request<[JellyfinAPI.ImageInfo]> {
            .get(path)
        }
    }
}

extension Paths {
    public static var environment: Environment {
        Environment(path: "/Environment")
    }

    public struct Environment {
        /// Path: `/Environment`
        public let path: String
    }
}

extension Paths.Environment {
    public var parentPath: ParentPath {
        ParentPath(path: path + "/ParentPath")
    }

    public struct ParentPath {
        /// Path: `/Environment/ParentPath`
        public let path: String

        /// Gets the parent path of a given path.
        public func get(path: String) -> Request<String> {
            .get(self.path, query: [("path", path)])
        }
    }
}

extension Paths.Trailers {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Trailers/{itemId}`
        public let path: String
    }
}

extension Paths.Trailers.WithItemID {
    public var similar: Similar {
        Similar(path: path + "/Similar")
    }

    public struct Similar {
        /// Path: `/Trailers/{itemId}/Similar`
        public let path: String

        /// Gets similar items.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Exclude artist ids.
            public var excludeArtistIDs: [String]?
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
            public var fields: [JellyfinAPI.ItemFields]?

            public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
                self.excludeArtistIDs = excludeArtistIDs
                self.userID = userID
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.RemoteSearch {
    public var series: Series {
        Series(path: path + "/Series")
    }

    public struct Series {
        /// Path: `/Items/RemoteSearch/Series`
        public let path: String

        /// Get series remote search.
        public func post(_ body: JellyfinAPI.SeriesInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithUserID {
    public var images: Images {
        Images(path: path + "/Images")
    }

    public struct Images {
        /// Path: `/Users/{userId}/Images`
        public let path: String
    }
}

extension Paths.Users.WithUserID.Images.WithImageType {
    public func index(_ index: Int) -> WithIndex {
        WithIndex(path: "\(path)/\(index)")
    }

    public struct WithIndex {
        /// Path: `/Users/{userId}/Images/{imageType}/{index}`
        public let path: String

        /// Sets the user image.
        public func post(_ body: Data? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Delete the user's image.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.System {
    public var configuration: Configuration {
        Configuration(path: path + "/Configuration")
    }

    public struct Configuration {
        /// Path: `/System/Configuration`
        public let path: String

        /// Gets application configuration.
        public var get: Request<JellyfinAPI.ServerConfiguration> {
            .get(path)
        }

        /// Updates application configuration.
        public func post(_ body: JellyfinAPI.ServerConfiguration) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.QuickConnect {
    public var deauthorize: Deauthorize {
        Deauthorize(path: path + "/Deauthorize")
    }

    public struct Deauthorize {
        /// Path: `/QuickConnect/Deauthorize`
        public let path: String

        /// Deauthorize all quick connect devices for the current user.
        public var post: Request<Int> {
            .post(path)
        }
    }
}

extension Paths.System {
    public var activityLog: ActivityLog {
        ActivityLog(path: path + "/ActivityLog")
    }

    public struct ActivityLog {
        /// Path: `/System/ActivityLog`
        public let path: String
    }
}

extension Paths.System.ActivityLog {
    public var entries: Entries {
        Entries(path: path + "/Entries")
    }

    public struct Entries {
        /// Path: `/System/ActivityLog/Entries`
        public let path: String

        /// Gets activity log entries.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.ActivityLogEntryQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. The minimum date. Format = ISO.
            public var minDate: Date?
            /// Optional. Filter log entries if it has user id, or not.
            public var hasUserID: Bool?

            public init(startIndex: Int? = nil, limit: Int? = nil, minDate: Date? = nil, hasUserID: Bool? = nil) {
                self.startIndex = startIndex
                self.limit = limit
                self.minDate = minDate
                self.hasUserID = hasUserID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(minDate, forKey: "minDate")
                encoder.encode(hasUserID, forKey: "hasUserId")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithItemID {
    public var remoteSearch: RemoteSearch {
        RemoteSearch(path: path + "/RemoteSearch")
    }

    public struct RemoteSearch {
        /// Path: `/Items/{itemId}/RemoteSearch`
        public let path: String
    }
}

extension Paths.Items.WithItemID.RemoteSearch {
    public var subtitles: Subtitles {
        Subtitles(path: path + "/Subtitles")
    }

    public struct Subtitles {
        /// Path: `/Items/{itemId}/RemoteSearch/Subtitles`
        public let path: String
    }
}

extension Paths.Items.WithItemID.RemoteSearch.Subtitles {
    public func language(_ language: String) -> WithLanguage {
        WithLanguage(path: "\(path)/\(language)")
    }

    public struct WithLanguage {
        /// Path: `/Items/{itemId}/RemoteSearch/Subtitles/{language}`
        public let path: String

        /// Search remote subtitles.
        public func get(isPerfectMatch: Bool? = nil) -> Request<[JellyfinAPI.RemoteSubtitleInfo]> {
            .get(path, query: makeGetQuery(isPerfectMatch))
        }

        private func makeGetQuery(_ isPerfectMatch: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isPerfectMatch, forKey: "isPerfectMatch")
            return encoder.items
        }
    }
}

extension Paths.Persons.WithName.Images.WithImageType {
    public func imageIndex(_ imageIndex: Int) -> WithImageIndex {
        WithImageIndex(path: "\(path)/\(imageIndex)")
    }

    public struct WithImageIndex {
        /// Path: `/Persons/{name}/Images/{imageType}/{imageIndex}`
        public let path: String

        /// Get person image by name.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }

        /// Get person image by name.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }
    }
}

extension Paths.LiveTv {
    public var info: Info {
        Info(path: path + "/Info")
    }

    public struct Info {
        /// Path: `/LiveTv/Info`
        public let path: String

        /// Gets available live tv services.
        public var get: Request<JellyfinAPI.LiveTvInfo> {
            .get(path)
        }
    }
}

extension Paths.Shows.WithSeriesID {
    public var episodes: Episodes {
        Episodes(path: path + "/Episodes")
    }

    public struct Episodes {
        /// Path: `/Shows/{seriesId}/Episodes`
        public let path: String

        /// Gets episodes for a tv season.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The user id.
            public var userID: String?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional filter by season number.
            public var season: Int?
            /// Optional. Filter by season id.
            public var seasonID: String?
            /// Optional. Filter by items that are missing episodes or not.
            public var isMissing: Bool?
            /// Optional. Return items that are siblings of a supplied item.
            public var adjacentTo: String?
            /// Optional. Skip through the list until a given item is found.
            public var startItemID: String?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional, include image information in output.
            public var enableImages: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
            public var sortBy: String?

            public init(userID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, season: Int? = nil, seasonID: String? = nil, isMissing: Bool? = nil, adjacentTo: String? = nil, startItemID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil, sortBy: String? = nil) {
                self.userID = userID
                self.fields = fields
                self.season = season
                self.seasonID = seasonID
                self.isMissing = isMissing
                self.adjacentTo = adjacentTo
                self.startItemID = startItemID
                self.startIndex = startIndex
                self.limit = limit
                self.enableImages = enableImages
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.enableUserData = enableUserData
                self.sortBy = sortBy
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(season, forKey: "season")
                encoder.encode(seasonID, forKey: "seasonId")
                encoder.encode(isMissing, forKey: "isMissing")
                encoder.encode(adjacentTo, forKey: "adjacentTo")
                encoder.encode(startItemID, forKey: "startItemId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(sortBy, forKey: "sortBy")
                return encoder.items
            }
        }
    }
}

extension Paths.SyncPlay {
    public var movePlaylistItem: MovePlaylistItem {
        MovePlaylistItem(path: path + "/MovePlaylistItem")
    }

    public struct MovePlaylistItem {
        /// Path: `/SyncPlay/MovePlaylistItem`
        public let path: String

        /// Request to move an item in the playlist in SyncPlay group.
        public func post(_ body: JellyfinAPI.MovePlaylistItemRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Items.WithItemID {
    public var similar: Similar {
        Similar(path: path + "/Similar")
    }

    public struct Similar {
        /// Path: `/Items/{itemId}/Similar`
        public let path: String

        /// Gets similar items.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Exclude artist ids.
            public var excludeArtistIDs: [String]?
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
            public var fields: [JellyfinAPI.ItemFields]?

            public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
                self.excludeArtistIDs = excludeArtistIDs
                self.userID = userID
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Library.VirtualFolders.Paths {
    public var update: Update {
        Update(path: path + "/Update")
    }

    public struct Update {
        /// Path: `/Library/VirtualFolders/Paths/Update`
        public let path: String

        /// Updates a media path.
        public func post(_ body: JellyfinAPI.UpdateMediaPathRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Sessions {
    public var playing: Playing {
        Playing(path: path + "/Playing")
    }

    public struct Playing {
        /// Path: `/Sessions/Playing`
        public let path: String

        /// Reports playback has started within a session.
        public func post(_ body: JellyfinAPI.PlaybackStartInfo? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithUserID.Items {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Users/{userId}/Items/{itemId}`
        public let path: String

        /// Gets an item from a user's library.
        public var get: Request<JellyfinAPI.BaseItemDto> {
            .get(path)
        }
    }
}

extension Paths.Library.VirtualFolders {
    public var libraryOptions: LibraryOptions {
        LibraryOptions(path: path + "/LibraryOptions")
    }

    public struct LibraryOptions {
        /// Path: `/Library/VirtualFolders/LibraryOptions`
        public let path: String

        /// Update library options.
        public func post(_ body: JellyfinAPI.UpdateLibraryOptionsDto? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Environment {
    public var drives: Drives {
        Drives(path: path + "/Drives")
    }

    public struct Drives {
        /// Path: `/Environment/Drives`
        public let path: String

        /// Gets available drives from the server's file system.
        public var get: Request<[JellyfinAPI.FileSystemEntryInfo]> {
            .get(path)
        }
    }
}

extension Paths.SyncPlay {
    public var setRepeatMode: SetRepeatMode {
        SetRepeatMode(path: path + "/SetRepeatMode")
    }

    public struct SetRepeatMode {
        /// Path: `/SyncPlay/SetRepeatMode`
        public let path: String

        /// Request to set repeat mode in SyncPlay group.
        public func post(_ body: JellyfinAPI.SetRepeatModeRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithUserID.Items.WithItemID {
    public var intros: Intros {
        Intros(path: path + "/Intros")
    }

    public struct Intros {
        /// Path: `/Users/{userId}/Items/{itemId}/Intros`
        public let path: String

        /// Gets intros to play before the main media item plays.
        public var get: Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path)
        }
    }
}

extension Paths.Web {
    public var configurationPages: ConfigurationPages {
        ConfigurationPages(path: path + "/ConfigurationPages")
    }

    public struct ConfigurationPages {
        /// Path: `/web/ConfigurationPages`
        public let path: String

        /// Gets the configuration pages.
        public func get(enableInMainMenu: Bool? = nil, pageType: PageType? = nil) -> Request<[JellyfinAPI.ConfigurationPageInfo]> {
            .get(path, query: makeGetQuery(enableInMainMenu, pageType))
        }

        private func makeGetQuery(_ enableInMainMenu: Bool?, _ pageType: PageType?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(enableInMainMenu, forKey: "enableInMainMenu")
            encoder.encode(pageType, forKey: "pageType")
            return encoder.items
        }

        public typealias PageType = JellyfinAPI.ConfigurationPageType
    }
}

extension Paths.Items.WithItemID {
    public var themeMedia: ThemeMedia {
        ThemeMedia(path: path + "/ThemeMedia")
    }

    public struct ThemeMedia {
        /// Path: `/Items/{itemId}/ThemeMedia`
        public let path: String

        /// Get theme songs and videos for an item.
        public func get(userID: String? = nil, isInheritFromParent: Bool? = nil) -> Request<JellyfinAPI.AllThemeMediaResult> {
            .get(path, query: makeGetQuery(userID, isInheritFromParent))
        }

        private func makeGetQuery(_ userID: String?, _ isInheritFromParent: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(isInheritFromParent, forKey: "inheritFromParent")
            return encoder.items
        }
    }
}

extension Paths.Videos.WithItemID {
    public var hls: Hls {
        Hls(path: path + "/hls")
    }

    public struct Hls {
        /// Path: `/Videos/{itemId}/hls`
        public let path: String
    }
}

extension Paths.Videos.WithItemID.Hls {
    public func playlistID(_ playlistID: String) -> WithPlaylistID {
        WithPlaylistID(path: "\(path)/\(playlistID)")
    }

    public struct WithPlaylistID {
        /// Path: `/Videos/{itemId}/hls/{playlistId}`
        public let path: String
    }
}

extension Paths.Videos.WithItemID.Hls.WithPlaylistID {
    public var streamM3u8: StreamM3u8 {
        StreamM3u8(path: path + "/stream.m3u8")
    }

    public struct StreamM3u8 {
        /// Path: `/Videos/{itemId}/hls/{playlistId}/stream.m3u8`
        public let path: String

        /// Gets a hls video playlist.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Items.WithItemID.Images.WithImageType.WithImageIndex {
    public var index: Index {
        Index(path: path + "/Index")
    }

    public struct Index {
        /// Path: `/Items/{itemId}/Images/{imageType}/{imageIndex}/Index`
        public let path: String

        /// Updates the index for an item image.
        public func post(newIndex: Int) -> Request<Void> {
            .post(path, query: [("newIndex", String(newIndex))])
        }
    }
}

extension Paths.Genres.WithName.Images.WithImageType {
    public func imageIndex(_ imageIndex: Int) -> WithImageIndex {
        WithImageIndex(path: "\(path)/\(imageIndex)")
    }

    public struct WithImageIndex {
        /// Path: `/Genres/{name}/Images/{imageType}/{imageIndex}`
        public let path: String

        /// Get genre image by name.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }

        /// Get genre image by name.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }
    }
}

extension Paths.QuickConnect {
    public var initiate: Initiate {
        Initiate(path: path + "/Initiate")
    }

    public struct Initiate {
        /// Path: `/QuickConnect/Initiate`
        public let path: String

        /// Initiate a new quick connect request.
        public var get: Request<JellyfinAPI.QuickConnectResult> {
            .get(path)
        }
    }
}

extension Paths.ScheduledTasks {
    public var running: Running {
        Running(path: path + "/Running")
    }

    public struct Running {
        /// Path: `/ScheduledTasks/Running`
        public let path: String
    }
}

extension Paths.ScheduledTasks.Running {
    public func taskID(_ taskID: String) -> WithTaskID {
        WithTaskID(path: "\(path)/\(taskID)")
    }

    public struct WithTaskID {
        /// Path: `/ScheduledTasks/Running/{taskId}`
        public let path: String

        /// Start specified task.
        public var post: Request<Void> {
            .post(path)
        }

        /// Stop specified task.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.LiveTv {
    public var channelMappingOptions: ChannelMappingOptions {
        ChannelMappingOptions(path: path + "/ChannelMappingOptions")
    }

    public struct ChannelMappingOptions {
        /// Path: `/LiveTv/ChannelMappingOptions`
        public let path: String

        /// Get channel mapping options.
        public func get(providerID: String? = nil) -> Request<JellyfinAPI.ChannelMappingOptionsDto> {
            .get(path, query: makeGetQuery(providerID))
        }

        private func makeGetQuery(_ providerID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(providerID, forKey: "providerId")
            return encoder.items
        }
    }
}

extension Paths.QuickConnect {
    public var connect: Connect {
        Connect(path: path + "/Connect")
    }

    public struct Connect {
        /// Path: `/QuickConnect/Connect`
        public let path: String

        /// Attempts to retrieve authentication information.
        public func get(secret: String) -> Request<JellyfinAPI.QuickConnectResult> {
            .get(path, query: [("secret", secret)])
        }
    }
}

extension Paths {
    public static var movies: Movies {
        Movies(path: "/Movies")
    }

    public struct Movies {
        /// Path: `/Movies`
        public let path: String
    }
}

extension Paths.Movies {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Movies/{itemId}`
        public let path: String
    }
}

extension Paths.Movies.WithItemID {
    public var similar: Similar {
        Similar(path: path + "/Similar")
    }

    public struct Similar {
        /// Path: `/Movies/{itemId}/Similar`
        public let path: String

        /// Gets similar items.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Exclude artist ids.
            public var excludeArtistIDs: [String]?
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
            public var fields: [JellyfinAPI.ItemFields]?

            public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
                self.excludeArtistIDs = excludeArtistIDs
                self.userID = userID
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Images.MediaInfo {
    public func theme(_ theme: String) -> WithTheme {
        WithTheme(path: "\(path)/\(theme)")
    }

    public struct WithTheme {
        /// Path: `/Images/MediaInfo/{theme}`
        public let path: String
    }
}

extension Paths.Images.MediaInfo.WithTheme {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/Images/MediaInfo/{theme}/{name}`
        public let path: String

        /// Get media info image.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.MusicGenres.WithName.Images {
    public func imageType(_ imageType: String) -> WithImageType {
        WithImageType(path: "\(path)/\(imageType)")
    }

    public struct WithImageType {
        /// Path: `/MusicGenres/{name}/Images/{imageType}`
        public let path: String

        /// Get music genre image by name.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }

        /// Get music genre image by name.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var playedItems: PlayedItems {
        PlayedItems(path: path + "/PlayedItems")
    }

    public struct PlayedItems {
        /// Path: `/Users/{userId}/PlayedItems`
        public let path: String
    }
}

extension Paths.Users.WithUserID.PlayedItems {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/Users/{userId}/PlayedItems/{itemId}`
        public let path: String

        /// Marks an item as played for user.
        public func post(datePlayed: Date? = nil) -> Request<JellyfinAPI.UserItemDataDto> {
            .post(path, query: makePostQuery(datePlayed))
        }

        private func makePostQuery(_ datePlayed: Date?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(datePlayed, forKey: "datePlayed")
            return encoder.items
        }

        /// Marks an item as unplayed for user.
        public var delete: Request<JellyfinAPI.UserItemDataDto> {
            .delete(path)
        }
    }
}

extension Paths.Sessions.Playing {
    public var progress: Progress {
        Progress(path: path + "/Progress")
    }

    public struct Progress {
        /// Path: `/Sessions/Playing/Progress`
        public let path: String

        /// Reports playback progress within a session.
        public func post(_ body: JellyfinAPI.PlaybackProgressInfo? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.System.Logs {
    public var log: Log {
        Log(path: path + "/Log")
    }

    public struct Log {
        /// Path: `/System/Logs/Log`
        public let path: String

        /// Gets a log file.
        public func get(name: String) -> Request<String> {
            .get(path, query: [("name", name)])
        }
    }
}

extension Paths.Dlna.WithServerID {
    public var descriptionXml: DescriptionXml {
        DescriptionXml(path: path + "/description.xml")
    }

    public struct DescriptionXml {
        /// Path: `/Dlna/{serverId}/description.xml`
        public let path: String

        /// Get Description Xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Videos.WithItemID {
    public func mediaSourceID(_ mediaSourceID: String) -> WithMediaSourceID {
        WithMediaSourceID(path: "\(path)/\(mediaSourceID)")
    }

    public struct WithMediaSourceID {
        /// Path: `/Videos/{itemId}/{mediaSourceId}`
        public let path: String
    }
}

extension Paths.Videos.WithItemID.WithMediaSourceID {
    public var subtitles: Subtitles {
        Subtitles(path: path + "/Subtitles")
    }

    public struct Subtitles {
        /// Path: `/Videos/{itemId}/{mediaSourceId}/Subtitles`
        public let path: String
    }
}

extension Paths.Videos.WithItemID.WithMediaSourceID.Subtitles {
    public func index(_ index: Int) -> WithIndex {
        WithIndex(path: "\(path)/\(index)")
    }

    public struct WithIndex {
        /// Path: `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}`
        public let path: String
    }
}

extension Paths.Videos.WithItemID.WithMediaSourceID.Subtitles.WithIndex {
    public var subtitlesM3u8: SubtitlesM3u8 {
        SubtitlesM3u8(path: path + "/subtitles.m3u8")
    }

    public struct SubtitlesM3u8 {
        /// Path: `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8`
        public let path: String

        /// Gets an HLS subtitle playlist.
        public func get(segmentLength: Int) -> Request<Data> {
            .get(path, query: [("segmentLength", String(segmentLength))])
        }
    }
}

extension Paths.Items.RemoteSearch {
    public var musicAlbum: MusicAlbum {
        MusicAlbum(path: path + "/MusicAlbum")
    }

    public struct MusicAlbum {
        /// Path: `/Items/RemoteSearch/MusicAlbum`
        public let path: String

        /// Get music album remote search.
        public func post(_ body: JellyfinAPI.AlbumInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.System.Info {
    public var `public`: Public {
        Public(path: path + "/Public")
    }

    public struct Public {
        /// Path: `/System/Info/Public`
        public let path: String

        /// Gets public information about the server.
        public var get: Request<JellyfinAPI.PublicSystemInfo> {
            .get(path)
        }
    }
}

extension Paths.Movies {
    public var recommendations: Recommendations {
        Recommendations(path: path + "/Recommendations")
    }

    public struct Recommendations {
        /// Path: `/Movies/Recommendations`
        public let path: String

        /// Gets movie recommendations.
        public func get(parameters: GetParameters? = nil) -> Request<[JellyfinAPI.RecommendationDto]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. The fields to return.
            public var fields: [JellyfinAPI.ItemFields]?
            /// The max number of categories to return.
            public var categoryLimit: Int?
            /// The max number of items to return per category.
            public var itemLimit: Int?

            public init(userID: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, categoryLimit: Int? = nil, itemLimit: Int? = nil) {
                self.userID = userID
                self.parentID = parentID
                self.fields = fields
                self.categoryLimit = categoryLimit
                self.itemLimit = itemLimit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(categoryLimit, forKey: "categoryLimit")
                encoder.encode(itemLimit, forKey: "itemLimit")
                return encoder.items
            }
        }
    }
}

extension Paths.Environment {
    public var validatePath: ValidatePath {
        ValidatePath(path: path + "/ValidatePath")
    }

    public struct ValidatePath {
        /// Path: `/Environment/ValidatePath`
        public let path: String

        /// Validates path.
        public func post(_ body: JellyfinAPI.ValidatePathDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var displayPreferences: DisplayPreferences {
        DisplayPreferences(path: "/DisplayPreferences")
    }

    public struct DisplayPreferences {
        /// Path: `/DisplayPreferences`
        public let path: String
    }
}

extension Paths.DisplayPreferences {
    public func displayPreferencesID(_ displayPreferencesID: String) -> WithDisplayPreferencesID {
        WithDisplayPreferencesID(path: "\(path)/\(displayPreferencesID)")
    }

    public struct WithDisplayPreferencesID {
        /// Path: `/DisplayPreferences/{displayPreferencesId}`
        public let path: String

        /// Get Display Preferences.
        public func get(userID: String, client: String) -> Request<JellyfinAPI.DisplayPreferencesDto> {
            .get(path, query: [("userId", userID), ("client", client)])
        }

        /// Update Display Preferences.
        public func post(userID: String, client: String, _ body: JellyfinAPI.DisplayPreferencesDto) -> Request<Void> {
            .post(path, query: [("userId", userID), ("client", client)], body: body)
        }
    }
}

extension Paths.LiveTv.ListingProviders {
    public var lineups: Lineups {
        Lineups(path: path + "/Lineups")
    }

    public struct Lineups {
        /// Path: `/LiveTv/ListingProviders/Lineups`
        public let path: String

        /// Gets available lineups.
        public func get(parameters: GetParameters? = nil) -> Request<[JellyfinAPI.NameIDPair]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Provider id.
            public var id: String?
            /// Provider type.
            public var type: String?
            /// Location.
            public var location: String?
            /// Country.
            public var country: String?

            public init(id: String? = nil, type: String? = nil, location: String? = nil, country: String? = nil) {
                self.id = id
                self.type = type
                self.location = location
                self.country = country
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(id, forKey: "id")
                encoder.encode(type, forKey: "type")
                encoder.encode(location, forKey: "location")
                encoder.encode(country, forKey: "country")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithItemID.Images.WithImageType.WithImageIndex {
    public func tag(_ tag: String) -> WithTag {
        WithTag(path: "\(path)/\(tag)")
    }

    public struct WithTag {
        /// Path: `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}`
        public let path: String
    }
}

extension Paths.Items.WithItemID.Images.WithImageType.WithImageIndex.WithTag {
    public func format(_ format: String) -> WithFormat {
        WithFormat(path: "\(path)/\(format)")
    }

    public struct WithFormat {
        /// Path: `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}`
        public let path: String
    }
}

extension Paths.Items.WithItemID.Images.WithImageType.WithImageIndex.WithTag.WithFormat {
    public func maxWidth(_ maxWidth: Int) -> WithMaxWidth {
        WithMaxWidth(path: "\(path)/\(maxWidth)")
    }

    public struct WithMaxWidth {
        /// Path: `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}`
        public let path: String
    }
}

extension Paths.Items.WithItemID.Images.WithImageType.WithImageIndex.WithTag.WithFormat.WithMaxWidth {
    public func maxHeight(_ maxHeight: Int) -> WithMaxHeight {
        WithMaxHeight(path: "\(path)/\(maxHeight)")
    }

    public struct WithMaxHeight {
        /// Path: `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}`
        public let path: String
    }
}

extension Paths.Items.WithItemID.Images.WithImageType.WithImageIndex.WithTag.WithFormat.WithMaxWidth.WithMaxHeight {
    public func percentPlayed(_ percentPlayed: String) -> WithPercentPlayed {
        WithPercentPlayed(path: "\(path)/\(percentPlayed)")
    }

    public struct WithPercentPlayed {
        /// Path: `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}`
        public let path: String
    }
}

extension Paths.Items.WithItemID.Images.WithImageType.WithImageIndex.WithTag.WithFormat.WithMaxWidth.WithMaxHeight.WithPercentPlayed {
    public func unplayedCount(_ unplayedCount: Int) -> WithUnplayedCount {
        WithUnplayedCount(path: "\(path)/\(unplayedCount)")
    }

    public struct WithUnplayedCount {
        /// Path: `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}`
        public let path: String

        /// Gets the item's image.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public init(width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }

        /// Gets the item's image.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public init(width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }
    }
}

extension Paths.LiveTv.Programs {
    public var recommended: Recommended {
        Recommended(path: path + "/Recommended")
    }

    public struct Recommended {
        /// Path: `/LiveTv/Programs/Recommended`
        public let path: String

        /// Gets recommended live tv epgs.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. filter by user id.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Filter by programs that are currently airing, or not.
            public var isAiring: Bool?
            /// Optional. Filter by programs that have completed airing, or not.
            public var hasAired: Bool?
            /// Optional. Filter for series.
            public var isSeries: Bool?
            /// Optional. Filter for movies.
            public var isMovie: Bool?
            /// Optional. Filter for news.
            public var isNews: Bool?
            /// Optional. Filter for kids.
            public var isKids: Bool?
            /// Optional. Filter for sports.
            public var isSports: Bool?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// The genres to return guide information for.
            public var genreIDs: [String]?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. include user data.
            public var enableUserData: Bool?
            /// Retrieve total record count.
            public var enableTotalRecordCount: Bool?

            public init(userID: String? = nil, limit: Int? = nil, isAiring: Bool? = nil, hasAired: Bool? = nil, isSeries: Bool? = nil, isMovie: Bool? = nil, isNews: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, genreIDs: [String]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableUserData: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
                self.userID = userID
                self.limit = limit
                self.isAiring = isAiring
                self.hasAired = hasAired
                self.isSeries = isSeries
                self.isMovie = isMovie
                self.isNews = isNews
                self.isKids = isKids
                self.isSports = isSports
                self.enableImages = enableImages
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.genreIDs = genreIDs
                self.fields = fields
                self.enableUserData = enableUserData
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isAiring, forKey: "isAiring")
                encoder.encode(hasAired, forKey: "hasAired")
                encoder.encode(isSeries, forKey: "isSeries")
                encoder.encode(isMovie, forKey: "isMovie")
                encoder.encode(isNews, forKey: "isNews")
                encoder.encode(isKids, forKey: "isKids")
                encoder.encode(isSports, forKey: "isSports")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(genreIDs, forKey: "genreIds")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var studios: Studios {
        Studios(path: "/Studios")
    }

    public struct Studios {
        /// Path: `/Studios`
        public let path: String

        /// Gets all studios from a given item, folder, or the entire library.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Search term.
            public var searchTerm: String?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
            public var excludeItemTypes: [String]?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional filter by items that are marked as favorite, or not.
            public var isFavorite: Bool?
            /// Optional, include user data.
            public var enableUserData: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// User id.
            public var userID: String?
            /// Optional filter by items whose name is sorted equally or greater than a given input string.
            public var nameStartsWithOrGreater: String?
            /// Optional filter by items whose name is sorted equally than a given input string.
            public var nameStartsWith: String?
            /// Optional filter by items whose name is equally or lesser than a given input string.
            public var nameLessThan: String?
            /// Optional, include image information in output.
            public var enableImages: Bool?
            /// Total record count.
            public var enableTotalRecordCount: Bool?

            public init(startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, isFavorite: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
                self.startIndex = startIndex
                self.limit = limit
                self.searchTerm = searchTerm
                self.parentID = parentID
                self.fields = fields
                self.excludeItemTypes = excludeItemTypes
                self.includeItemTypes = includeItemTypes
                self.isFavorite = isFavorite
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.userID = userID
                self.nameStartsWithOrGreater = nameStartsWithOrGreater
                self.nameStartsWith = nameStartsWith
                self.nameLessThan = nameLessThan
                self.enableImages = enableImages
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
                encoder.encode(nameStartsWith, forKey: "nameStartsWith")
                encoder.encode(nameLessThan, forKey: "nameLessThan")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }
    }
}

extension Paths.LiveTv {
    public var recordings: Recordings {
        Recordings(path: path + "/Recordings")
    }

    public struct Recordings {
        /// Path: `/LiveTv/Recordings`
        public let path: String

        /// Gets live tv recordings.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by channel id.
            public var channelID: String?
            /// Optional. Filter by user and attach user data.
            public var userID: String?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Filter by recording status.
            public var status: Status?
            /// Optional. Filter by recordings that are in progress, or not.
            public var isInProgress: Bool?
            /// Optional. Filter by recordings belonging to a series timer.
            public var seriesTimerID: String?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. Filter for movies.
            public var isMovie: Bool?
            /// Optional. Filter for series.
            public var isSeries: Bool?
            /// Optional. Filter for kids.
            public var isKids: Bool?
            /// Optional. Filter for sports.
            public var isSports: Bool?
            /// Optional. Filter for news.
            public var isNews: Bool?
            /// Optional. Filter for is library item.
            public var isLibraryItem: Bool?
            /// Optional. Return total record count.
            public var enableTotalRecordCount: Bool?

            public typealias Status = JellyfinAPI.RecordingStatus

            public init(channelID: String? = nil, userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, status: Status? = nil, isInProgress: Bool? = nil, seriesTimerID: String? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableUserData: Bool? = nil, isMovie: Bool? = nil, isSeries: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, isNews: Bool? = nil, isLibraryItem: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
                self.channelID = channelID
                self.userID = userID
                self.startIndex = startIndex
                self.limit = limit
                self.status = status
                self.isInProgress = isInProgress
                self.seriesTimerID = seriesTimerID
                self.enableImages = enableImages
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.fields = fields
                self.enableUserData = enableUserData
                self.isMovie = isMovie
                self.isSeries = isSeries
                self.isKids = isKids
                self.isSports = isSports
                self.isNews = isNews
                self.isLibraryItem = isLibraryItem
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(channelID, forKey: "channelId")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(status, forKey: "status")
                encoder.encode(isInProgress, forKey: "isInProgress")
                encoder.encode(seriesTimerID, forKey: "seriesTimerId")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(isMovie, forKey: "isMovie")
                encoder.encode(isSeries, forKey: "isSeries")
                encoder.encode(isKids, forKey: "isKids")
                encoder.encode(isSports, forKey: "isSports")
                encoder.encode(isNews, forKey: "isNews")
                encoder.encode(isLibraryItem, forKey: "isLibraryItem")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.RemoteSearch {
    public var movie: Movie {
        Movie(path: path + "/Movie")
    }

    public struct Movie {
        /// Path: `/Items/RemoteSearch/Movie`
        public let path: String

        /// Get movie remote search.
        public func post(_ body: JellyfinAPI.MovieInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.LiveTv.Programs {
    public func programID(_ programID: String) -> WithProgramID {
        WithProgramID(path: "\(path)/\(programID)")
    }

    public struct WithProgramID {
        /// Path: `/LiveTv/Programs/{programId}`
        public let path: String

        /// Gets a live tv program.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.Years {
    public func year(_ year: Int) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/Years/{year}`
        public let path: String

        /// Gets a year.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.Localization {
    public var countries: Countries {
        Countries(path: path + "/Countries")
    }

    public struct Countries {
        /// Path: `/Localization/Countries`
        public let path: String

        /// Gets known countries.
        public var get: Request<[JellyfinAPI.CountryInfo]> {
            .get(path)
        }
    }
}

extension Paths.Audio.WithItemID {
    public var hls: Hls {
        Hls(path: path + "/hls")
    }

    public struct Hls {
        /// Path: `/Audio/{itemId}/hls`
        public let path: String
    }
}

extension Paths.Audio.WithItemID.Hls {
    public func segmentID(_ segmentID: String) -> WithSegmentID {
        WithSegmentID(path: "\(path)/\(segmentID)")
    }

    public struct WithSegmentID {
        /// Path: `/Audio/{itemId}/hls/{segmentId}`
        public let path: String
    }
}

extension Paths.Audio.WithItemID.Hls.WithSegmentID {
    public var streamAac: StreamAac {
        StreamAac(path: path + "/stream.aac")
    }

    public struct StreamAac {
        /// Path: `/Audio/{itemId}/hls/{segmentId}/stream.aac`
        public let path: String

        /// Gets the specified audio segment for an audio item.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Plugins.WithPluginID.WithVersion {
    public var enable: Enable {
        Enable(path: path + "/Enable")
    }

    public struct Enable {
        /// Path: `/Plugins/{pluginId}/{version}/Enable`
        public let path: String

        /// Enables a disabled plugin.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths {
    public static var fallbackFont: FallbackFont {
        FallbackFont(path: "/FallbackFont")
    }

    public struct FallbackFont {
        /// Path: `/FallbackFont`
        public let path: String
    }
}

extension Paths.FallbackFont.Fonts {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/FallbackFont/Fonts/{name}`
        public let path: String

        /// Gets a fallback font file.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.SyncPlay {
    public var leave: Leave {
        Leave(path: path + "/Leave")
    }

    public struct Leave {
        /// Path: `/SyncPlay/Leave`
        public let path: String

        /// Leave the joined SyncPlay group.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Sessions.WithSessionID {
    public var user: User {
        User(path: path + "/User")
    }

    public struct User {
        /// Path: `/Sessions/{sessionId}/User`
        public let path: String
    }
}

extension Paths.Sessions.WithSessionID.User {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/Sessions/{sessionId}/User/{userId}`
        public let path: String

        /// Adds an additional user to a session.
        public var post: Request<Void> {
            .post(path)
        }

        /// Removes an additional user from a session.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.LiveTv {
    public var seriesTimers: SeriesTimers {
        SeriesTimers(path: path + "/SeriesTimers")
    }

    public struct SeriesTimers {
        /// Path: `/LiveTv/SeriesTimers`
        public let path: String

        /// Gets live tv series timers.
        public func get(sortBy: String? = nil, sortOrder: SortOrder? = nil) -> Request<JellyfinAPI.SeriesTimerInfoDtoQueryResult> {
            .get(path, query: makeGetQuery(sortBy, sortOrder))
        }

        private func makeGetQuery(_ sortBy: String?, _ sortOrder: SortOrder?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(sortBy, forKey: "sortBy")
            encoder.encode(sortOrder, forKey: "sortOrder")
            return encoder.items
        }

        public typealias SortOrder = JellyfinAPI.SortOrder

        /// Creates a live tv series timer.
        public func post(_ body: JellyfinAPI.SeriesTimerInfoDto? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Albums {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/Albums/{id}`
        public let path: String
    }
}

extension Paths.Albums.WithID {
    public var instantMix: InstantMix {
        InstantMix(path: path + "/InstantMix")
    }

    public struct InstantMix {
        /// Path: `/Albums/{id}/InstantMix`
        public let path: String

        /// Creates an instant playlist based on a given album.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by user id, and attach user data.
            public var userID: String?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?

            public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
                self.userID = userID
                self.limit = limit
                self.fields = fields
                self.enableImages = enableImages
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                return encoder.items
            }
        }
    }
}

extension Paths.Environment {
    public var defaultDirectoryBrowser: DefaultDirectoryBrowser {
        DefaultDirectoryBrowser(path: path + "/DefaultDirectoryBrowser")
    }

    public struct DefaultDirectoryBrowser {
        /// Path: `/Environment/DefaultDirectoryBrowser`
        public let path: String

        /// Get Default directory browser.
        public var get: Request<JellyfinAPI.DefaultDirectoryBrowserInfoDto> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUserID.Items {
    public var latest: Latest {
        Latest(path: path + "/Latest")
    }

    public struct Latest {
        /// Path: `/Users/{userId}/Items/Latest`
        public let path: String

        /// Gets latest media.
        public func get(parameters: GetParameters? = nil) -> Request<[JellyfinAPI.BaseItemDto]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Filter by items that are played, or not.
            public var isPlayed: Bool?
            /// Optional. include image information in output.
            public var enableImages: Bool?
            /// Optional. the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. include user data.
            public var enableUserData: Bool?
            /// Return item limit.
            public var limit: Int?
            /// Whether or not to group items into a parent container.
            public var isGroupItems: Bool?

            public init(parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, includeItemTypes: [String]? = nil, isPlayed: Bool? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil, limit: Int? = nil, isGroupItems: Bool? = nil) {
                self.parentID = parentID
                self.fields = fields
                self.includeItemTypes = includeItemTypes
                self.isPlayed = isPlayed
                self.enableImages = enableImages
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.enableUserData = enableUserData
                self.limit = limit
                self.isGroupItems = isGroupItems
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(isPlayed, forKey: "isPlayed")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isGroupItems, forKey: "groupItems")
                return encoder.items
            }
        }
    }
}

extension Paths.LiveTv {
    public var channelMappings: ChannelMappings {
        ChannelMappings(path: path + "/ChannelMappings")
    }

    public struct ChannelMappings {
        /// Path: `/LiveTv/ChannelMappings`
        public let path: String

        /// Set channel mappings.
        public func post(_ body: JellyfinAPI.SetChannelMappingDto) -> Request<JellyfinAPI.TunerChannelMapping> {
            .post(path, body: body)
        }
    }
}

extension Paths.Artists {
    public var albumArtists: AlbumArtists {
        AlbumArtists(path: path + "/AlbumArtists")
    }

    public struct AlbumArtists {
        /// Path: `/Artists/AlbumArtists`
        public let path: String

        /// Gets all album artists from a given item, folder, or the entire library.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional filter by minimum community rating.
            public var minCommunityRating: Double?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Search term.
            public var searchTerm: String?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
            public var excludeItemTypes: [String]?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional. Specify additional filters to apply.
            public var filters: [JellyfinAPI.ItemFilter]?
            /// Optional filter by items that are marked as favorite, or not.
            public var isFavorite: Bool?
            /// Optional filter by MediaType. Allows multiple, comma delimited.
            public var mediaTypes: [String]?
            /// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
            public var genres: [String]?
            /// Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
            public var genreIDs: [String]?
            /// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
            public var officialRatings: [String]?
            /// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
            public var tags: [String]?
            /// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
            public var years: [Int]?
            /// Optional, include user data.
            public var enableUserData: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. If specified, results will be filtered to include only those containing the specified person.
            public var person: String?
            /// Optional. If specified, results will be filtered to include only those containing the specified person ids.
            public var personIDs: [String]?
            /// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
            public var personTypes: [String]?
            /// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
            public var studios: [String]?
            /// Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
            public var studioIDs: [String]?
            /// User id.
            public var userID: String?
            /// Optional filter by items whose name is sorted equally or greater than a given input string.
            public var nameStartsWithOrGreater: String?
            /// Optional filter by items whose name is sorted equally than a given input string.
            public var nameStartsWith: String?
            /// Optional filter by items whose name is equally or lesser than a given input string.
            public var nameLessThan: String?
            /// Optional, include image information in output.
            public var enableImages: Bool?
            /// Total record count.
            public var enableTotalRecordCount: Bool?

            public init(minCommunityRating: Double? = nil, startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, genres: [String]? = nil, genreIDs: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, studioIDs: [String]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
                self.minCommunityRating = minCommunityRating
                self.startIndex = startIndex
                self.limit = limit
                self.searchTerm = searchTerm
                self.parentID = parentID
                self.fields = fields
                self.excludeItemTypes = excludeItemTypes
                self.includeItemTypes = includeItemTypes
                self.filters = filters
                self.isFavorite = isFavorite
                self.mediaTypes = mediaTypes
                self.genres = genres
                self.genreIDs = genreIDs
                self.officialRatings = officialRatings
                self.tags = tags
                self.years = years
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.person = person
                self.personIDs = personIDs
                self.personTypes = personTypes
                self.studios = studios
                self.studioIDs = studioIDs
                self.userID = userID
                self.nameStartsWithOrGreater = nameStartsWithOrGreater
                self.nameStartsWith = nameStartsWith
                self.nameLessThan = nameLessThan
                self.enableImages = enableImages
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(minCommunityRating, forKey: "minCommunityRating")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(filters, forKey: "filters")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(mediaTypes, forKey: "mediaTypes")
                encoder.encode(genres, forKey: "genres")
                encoder.encode(genreIDs, forKey: "genreIds")
                encoder.encode(officialRatings, forKey: "officialRatings")
                encoder.encode(tags, forKey: "tags")
                encoder.encode(years, forKey: "years")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(person, forKey: "person")
                encoder.encode(personIDs, forKey: "personIds")
                encoder.encode(personTypes, forKey: "personTypes")
                encoder.encode(studios, forKey: "studios")
                encoder.encode(studioIDs, forKey: "studioIds")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
                encoder.encode(nameStartsWith, forKey: "nameStartsWith")
                encoder.encode(nameLessThan, forKey: "nameLessThan")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }
    }
}

extension Paths.Audio.WithItemID {
    public func container(_ container: String) -> WithStream {
        WithStream(path: "\(path)/stream.\(container)")
    }

    public struct WithStream {
        /// Path: `/Audio/{itemId}/stream.{container}`
        public let path: String

        /// Gets an audio stream.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment lenght.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamporphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }

        /// Gets an audio stream.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
            public var isStatic: Bool?
            /// The streaming parameters.
            public var params: String?
            /// The tag.
            public var tag: String?
            /// Optional. The dlna device profile id to utilize.
            public var deviceProfileID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The segment container.
            public var segmentContainer: String?
            /// The segment lenght.
            public var segmentLength: Int?
            /// The minimum number of segments.
            public var minSegments: Int?
            /// The media version id, if playing an alternate version.
            public var mediaSourceID: String?
            /// The device id of the client requesting. Used to stop encoding processes when needed.
            public var deviceID: String?
            /// Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
            public var audioCodec: String?
            /// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
            public var enableAutoStreamCopy: Bool?
            /// Whether or not to allow copying of the video stream url.
            public var allowVideoStreamCopy: Bool?
            /// Whether or not to allow copying of the audio stream url.
            public var allowAudioStreamCopy: Bool?
            /// Optional. Whether to break on non key frames.
            public var isBreakOnNonKeyFrames: Bool?
            /// Optional. Specify a specific audio sample rate, e.g. 44100.
            public var audioSampleRate: Int?
            /// Optional. The maximum audio bit depth.
            public var maxAudioBitDepth: Int?
            /// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
            public var audioBitRate: Int?
            /// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
            public var audioChannels: Int?
            /// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
            public var maxAudioChannels: Int?
            /// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
            public var profile: String?
            /// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
            public var level: String?
            /// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var framerate: Double?
            /// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
            public var maxFramerate: Double?
            /// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
            public var isCopyTimestamps: Bool?
            /// Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
            public var startTimeTicks: Int?
            /// Optional. The fixed horizontal resolution of the encoded video.
            public var width: Int?
            /// Optional. The fixed vertical resolution of the encoded video.
            public var height: Int?
            /// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
            public var videoBitRate: Int?
            /// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
            public var subtitleStreamIndex: Int?
            /// Optional. Specify the subtitle delivery method.
            public var subtitleMethod: SubtitleMethod?
            /// Optional.
            public var maxRefFrames: Int?
            /// Optional. The maximum video bit depth.
            public var maxVideoBitDepth: Int?
            /// Optional. Whether to require avc.
            public var requireAvc: Bool?
            /// Optional. Whether to deinterlace the video.
            public var isDeInterlace: Bool?
            /// Optional. Whether to require a non anamporphic stream.
            public var requireNonAnamorphic: Bool?
            /// Optional. The maximum number of audio channels to transcode.
            public var transcodingMaxAudioChannels: Int?
            /// Optional. The limit of how many cpu cores to use.
            public var cpuCoreLimit: Int?
            /// The live stream id.
            public var liveStreamID: String?
            /// Optional. Whether to enable the MpegtsM2Ts mode.
            public var enableMpegtsM2TsMode: Bool?
            /// Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
            public var videoCodec: String?
            /// Optional. Specify a subtitle codec to encode to.
            public var subtitleCodec: String?
            /// Optional. The transcoding reason.
            public var transcodeReasons: String?
            /// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
            public var audioStreamIndex: Int?
            /// Optional. The index of the video stream to use. If omitted the first video stream will be used.
            public var videoStreamIndex: Int?
            /// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
            public var context: Context?
            /// Optional. The streaming options.
            public var streamOptions: StreamOptions?

            public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

            public typealias Context = JellyfinAPI.EncodingContext

            public typealias StreamOptions = [String: String]

            public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
                self.isStatic = isStatic
                self.params = params
                self.tag = tag
                self.deviceProfileID = deviceProfileID
                self.playSessionID = playSessionID
                self.segmentContainer = segmentContainer
                self.segmentLength = segmentLength
                self.minSegments = minSegments
                self.mediaSourceID = mediaSourceID
                self.deviceID = deviceID
                self.audioCodec = audioCodec
                self.enableAutoStreamCopy = enableAutoStreamCopy
                self.allowVideoStreamCopy = allowVideoStreamCopy
                self.allowAudioStreamCopy = allowAudioStreamCopy
                self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
                self.audioSampleRate = audioSampleRate
                self.maxAudioBitDepth = maxAudioBitDepth
                self.audioBitRate = audioBitRate
                self.audioChannels = audioChannels
                self.maxAudioChannels = maxAudioChannels
                self.profile = profile
                self.level = level
                self.framerate = framerate
                self.maxFramerate = maxFramerate
                self.isCopyTimestamps = isCopyTimestamps
                self.startTimeTicks = startTimeTicks
                self.width = width
                self.height = height
                self.videoBitRate = videoBitRate
                self.subtitleStreamIndex = subtitleStreamIndex
                self.subtitleMethod = subtitleMethod
                self.maxRefFrames = maxRefFrames
                self.maxVideoBitDepth = maxVideoBitDepth
                self.requireAvc = requireAvc
                self.isDeInterlace = isDeInterlace
                self.requireNonAnamorphic = requireNonAnamorphic
                self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
                self.cpuCoreLimit = cpuCoreLimit
                self.liveStreamID = liveStreamID
                self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
                self.videoCodec = videoCodec
                self.subtitleCodec = subtitleCodec
                self.transcodeReasons = transcodeReasons
                self.audioStreamIndex = audioStreamIndex
                self.videoStreamIndex = videoStreamIndex
                self.context = context
                self.streamOptions = streamOptions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isStatic, forKey: "static")
                encoder.encode(params, forKey: "params")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(deviceProfileID, forKey: "deviceProfileId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(segmentContainer, forKey: "segmentContainer")
                encoder.encode(segmentLength, forKey: "segmentLength")
                encoder.encode(minSegments, forKey: "minSegments")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(audioCodec, forKey: "audioCodec")
                encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
                encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
                encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
                encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
                encoder.encode(audioSampleRate, forKey: "audioSampleRate")
                encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
                encoder.encode(audioBitRate, forKey: "audioBitRate")
                encoder.encode(audioChannels, forKey: "audioChannels")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(profile, forKey: "profile")
                encoder.encode(level, forKey: "level")
                encoder.encode(framerate, forKey: "framerate")
                encoder.encode(maxFramerate, forKey: "maxFramerate")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(videoBitRate, forKey: "videoBitRate")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(subtitleMethod, forKey: "subtitleMethod")
                encoder.encode(maxRefFrames, forKey: "maxRefFrames")
                encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
                encoder.encode(requireAvc, forKey: "requireAvc")
                encoder.encode(isDeInterlace, forKey: "deInterlace")
                encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
                encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
                encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
                encoder.encode(liveStreamID, forKey: "liveStreamId")
                encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
                encoder.encode(videoCodec, forKey: "videoCodec")
                encoder.encode(subtitleCodec, forKey: "subtitleCodec")
                encoder.encode(transcodeReasons, forKey: "transcodeReasons")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
                encoder.encode(context, forKey: "context")
                encoder.encode(streamOptions, forKey: "streamOptions")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithItemID.RemoteSearch.Subtitles {
    public func subtitleID(_ subtitleID: String) -> WithSubtitleID {
        WithSubtitleID(path: "\(path)/\(subtitleID)")
    }

    public struct WithSubtitleID {
        /// Path: `/Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}`
        public let path: String

        /// Downloads a remote subtitle.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Startup {
    public var firstUser: FirstUser {
        FirstUser(path: path + "/FirstUser")
    }

    public struct FirstUser {
        /// Path: `/Startup/FirstUser`
        public let path: String

        /// Gets the first user.
        public var get: Request<JellyfinAPI.StartupUserDto> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUserID.Images {
    public func imageType(_ imageType: String) -> WithImageType {
        WithImageType(path: "\(path)/\(imageType)")
    }

    public struct WithImageType {
        /// Path: `/Users/{userId}/Images/{imageType}`
        public let path: String

        /// Get user profile image.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }

        /// Sets the user image.
        public func post(index: Int? = nil, _ body: Data? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(index), body: body)
        }

        private func makePostQuery(_ index: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(index, forKey: "index")
            return encoder.items
        }

        /// Delete the user's image.
        public func delete(index: Int? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(index))
        }

        private func makeDeleteQuery(_ index: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(index, forKey: "index")
            return encoder.items
        }

        /// Get user profile image.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var getUtcTime: GetUtcTime {
        GetUtcTime(path: "/GetUtcTime")
    }

    public struct GetUtcTime {
        /// Path: `/GetUtcTime`
        public let path: String

        /// Gets the current UTC time.
        public var get: Request<JellyfinAPI.UtcTimeResponse> {
            .get(path)
        }
    }
}

extension Paths.Sessions {
    public var capabilities: Capabilities {
        Capabilities(path: path + "/Capabilities")
    }

    public struct Capabilities {
        /// Path: `/Sessions/Capabilities`
        public let path: String

        /// Updates capabilities for a device.
        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            /// The session id.
            public var id: String?
            /// A list of playable media types, comma delimited. Audio, Video, Book, Photo.
            public var playableMediaTypes: [String]?
            /// A list of supported remote control commands, comma delimited.
            public var supportedCommands: [JellyfinAPI.GeneralCommandType]?
            /// Determines whether media can be played remotely..
            public var isSupportsMediaControl: Bool?
            /// Determines whether sync is supported.
            public var isSupportsSync: Bool?
            /// Determines whether the device supports a unique identifier.
            public var isSupportsPersistentIdentifier: Bool?

            public init(id: String? = nil, playableMediaTypes: [String]? = nil, supportedCommands: [JellyfinAPI.GeneralCommandType]? = nil, isSupportsMediaControl: Bool? = nil, isSupportsSync: Bool? = nil, isSupportsPersistentIdentifier: Bool? = nil) {
                self.id = id
                self.playableMediaTypes = playableMediaTypes
                self.supportedCommands = supportedCommands
                self.isSupportsMediaControl = isSupportsMediaControl
                self.isSupportsSync = isSupportsSync
                self.isSupportsPersistentIdentifier = isSupportsPersistentIdentifier
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(id, forKey: "id")
                encoder.encode(playableMediaTypes, forKey: "playableMediaTypes")
                encoder.encode(supportedCommands, forKey: "supportedCommands")
                encoder.encode(isSupportsMediaControl, forKey: "supportsMediaControl")
                encoder.encode(isSupportsSync, forKey: "supportsSync")
                encoder.encode(isSupportsPersistentIdentifier, forKey: "supportsPersistentIdentifier")
                return encoder.items
            }
        }
    }
}

extension Paths.Channels.WithChannelID {
    public var features: Features {
        Features(path: path + "/Features")
    }

    public struct Features {
        /// Path: `/Channels/{channelId}/Features`
        public let path: String

        /// Get channel features.
        public var get: Request<JellyfinAPI.ChannelFeatures> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUserID.Items {
    public var root: Root {
        Root(path: path + "/Root")
    }

    public struct Root {
        /// Path: `/Users/{userId}/Items/Root`
        public let path: String

        /// Gets the root folder from a user's library.
        public var get: Request<JellyfinAPI.BaseItemDto> {
            .get(path)
        }
    }
}

extension Paths.LiveTv.Recordings.Groups {
    public func groupID(_ groupID: String) -> WithGroupID {
        WithGroupID(path: "\(path)/\(groupID)")
    }

    public struct WithGroupID {
        /// Path: `/LiveTv/Recordings/Groups/{groupId}`
        public let path: String

        /// Get recording group.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Collections {
    public func collectionID(_ collectionID: String) -> WithCollectionID {
        WithCollectionID(path: "\(path)/\(collectionID)")
    }

    public struct WithCollectionID {
        /// Path: `/Collections/{collectionId}`
        public let path: String
    }
}

extension Paths.Collections.WithCollectionID {
    public var items: Items {
        Items(path: path + "/Items")
    }

    public struct Items {
        /// Path: `/Collections/{collectionId}/Items`
        public let path: String

        /// Adds items to a collection.
        public func post(ids: [String]) -> Request<Void> {
            .post(path, query: makePostQuery(ids))
        }

        private func makePostQuery(_ ids: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ids, forKey: "ids")
            return encoder.items
        }

        /// Removes items from a collection.
        public func delete(ids: [String]) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(ids))
        }

        private func makeDeleteQuery(_ ids: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ids, forKey: "ids")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID.Items {
    public var resume: Resume {
        Resume(path: path + "/Resume")
    }

    public struct Resume {
        /// Path: `/Users/{userId}/Items/Resume`
        public let path: String

        /// Gets items based on a query.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The start index.
            public var startIndex: Int?
            /// The item limit.
            public var limit: Int?
            /// The search term.
            public var searchTerm: String?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Filter by MediaType. Allows multiple, comma delimited.
            public var mediaTypes: [String]?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
            public var excludeItemTypes: [String]?
            /// Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional. Enable the total record count.
            public var enableTotalRecordCount: Bool?
            /// Optional. Include image information in output.
            public var enableImages: Bool?

            public init(startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, mediaTypes: [String]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, enableTotalRecordCount: Bool? = nil, enableImages: Bool? = nil) {
                self.startIndex = startIndex
                self.limit = limit
                self.searchTerm = searchTerm
                self.parentID = parentID
                self.fields = fields
                self.mediaTypes = mediaTypes
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.excludeItemTypes = excludeItemTypes
                self.includeItemTypes = includeItemTypes
                self.enableTotalRecordCount = enableTotalRecordCount
                self.enableImages = enableImages
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(mediaTypes, forKey: "mediaTypes")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                encoder.encode(enableImages, forKey: "enableImages")
                return encoder.items
            }
        }
    }
}

extension Paths.LiveTv.SeriesTimers {
    public func timerID(_ timerID: String) -> WithTimerID {
        WithTimerID(path: "\(path)/\(timerID)")
    }

    public struct WithTimerID {
        /// Path: `/LiveTv/SeriesTimers/{timerId}`
        public let path: String

        /// Gets a live tv series timer.
        public var get: Request<JellyfinAPI.SeriesTimerInfoDto> {
            .get(path)
        }

        /// Updates a live tv series timer.
        public func post(_ body: JellyfinAPI.SeriesTimerInfoDto? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Cancels a live tv series timer.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var sessions: Sessions {
        Sessions(path: "/Sessions")
    }

    public struct Sessions {
        /// Path: `/Sessions`
        public let path: String

        /// Gets a list of sessions.
        public func get(parameters: GetParameters? = nil) -> Request<[JellyfinAPI.SessionInfo]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Filter by sessions that a given user is allowed to remote control.
            public var controllableByUserID: String?
            /// Filter by device Id.
            public var deviceID: String?
            /// Optional. Filter by sessions that were active in the last n seconds.
            public var activeWithinSeconds: Int?

            public init(controllableByUserID: String? = nil, deviceID: String? = nil, activeWithinSeconds: Int? = nil) {
                self.controllableByUserID = controllableByUserID
                self.deviceID = deviceID
                self.activeWithinSeconds = activeWithinSeconds
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(controllableByUserID, forKey: "controllableByUserId")
                encoder.encode(deviceID, forKey: "deviceId")
                encoder.encode(activeWithinSeconds, forKey: "activeWithinSeconds")
                return encoder.items
            }
        }
    }
}

extension Paths.Videos.WithItemID {
    public var additionalParts: AdditionalParts {
        AdditionalParts(path: path + "/AdditionalParts")
    }

    public struct AdditionalParts {
        /// Path: `/Videos/{itemId}/AdditionalParts`
        public let path: String

        /// Gets additional parts for a video.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.Library.Series {
    public var updated: Updated {
        Updated(path: path + "/Updated")
    }

    public struct Updated {
        /// Path: `/Library/Series/Updated`
        public let path: String

        /// Reports that new episodes of a series have been added by an external source.
        public func post(tvdbID: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(tvdbID))
        }

        private func makePostQuery(_ tvdbID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tvdbID, forKey: "tvdbId")
            return encoder.items
        }
    }
}

extension Paths.Plugins.WithPluginID {
    public var manifest: Manifest {
        Manifest(path: path + "/Manifest")
    }

    public struct Manifest {
        /// Path: `/Plugins/{pluginId}/Manifest`
        public let path: String

        /// Gets a plugin's manifest.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Images.Ratings {
    public func theme(_ theme: String) -> WithTheme {
        WithTheme(path: "\(path)/\(theme)")
    }

    public struct WithTheme {
        /// Path: `/Images/Ratings/{theme}`
        public let path: String
    }
}

extension Paths.Images.Ratings.WithTheme {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/Images/Ratings/{theme}/{name}`
        public let path: String

        /// Get rating image.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Videos.WithRouteItemID.WithRouteMediaSourceID.Subtitles.WithRouteIndex {
    public func routeFormat(_ routeFormat: String) -> WithStream {
        WithStream(path: "\(path)/Stream.\(routeFormat)")
    }

    public struct WithStream {
        /// Path: `/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/Stream.{routeFormat}`
        public let path: String

        /// Gets subtitles in a specified format.
        public func get(parameters: GetParameters? = nil) -> Request<String> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The item id.
            public var itemID: String?
            /// The media source id.
            public var mediaSourceID: String?
            /// The subtitle stream index.
            public var index: Int?
            /// The format of the returned subtitle.
            public var format: String?
            /// Optional. The end position of the subtitle in ticks.
            public var endPositionTicks: Int?
            /// Optional. Whether to copy the timestamps.
            public var isCopyTimestamps: Bool?
            /// Optional. Whether to add a VTT time map.
            public var isAddVttTimeMap: Bool?
            /// The start position of the subtitle in ticks.
            public var startPositionTicks: Int?

            public init(itemID: String? = nil, mediaSourceID: String? = nil, index: Int? = nil, format: String? = nil, endPositionTicks: Int? = nil, isCopyTimestamps: Bool? = nil, isAddVttTimeMap: Bool? = nil, startPositionTicks: Int? = nil) {
                self.itemID = itemID
                self.mediaSourceID = mediaSourceID
                self.index = index
                self.format = format
                self.endPositionTicks = endPositionTicks
                self.isCopyTimestamps = isCopyTimestamps
                self.isAddVttTimeMap = isAddVttTimeMap
                self.startPositionTicks = startPositionTicks
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(itemID, forKey: "itemId")
                encoder.encode(mediaSourceID, forKey: "mediaSourceId")
                encoder.encode(index, forKey: "index")
                encoder.encode(format, forKey: "format")
                encoder.encode(endPositionTicks, forKey: "endPositionTicks")
                encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
                encoder.encode(isAddVttTimeMap, forKey: "addVttTimeMap")
                encoder.encode(startPositionTicks, forKey: "startPositionTicks")
                return encoder.items
            }
        }
    }
}

extension Paths.Environment {
    public var directoryContents: DirectoryContents {
        DirectoryContents(path: path + "/DirectoryContents")
    }

    public struct DirectoryContents {
        /// Path: `/Environment/DirectoryContents`
        public let path: String

        /// Gets the contents of a given directory in the file system.
        public func get(parameters: GetParameters) -> Request<[JellyfinAPI.FileSystemEntryInfo]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// The path.
            public var path: String
            /// An optional filter to include or exclude files from the results. true/false.
            public var isIncludeFiles: Bool?
            /// An optional filter to include or exclude folders from the results. true/false.
            public var isIncludeDirectories: Bool?

            public init(path: String, isIncludeFiles: Bool? = nil, isIncludeDirectories: Bool? = nil) {
                self.path = path
                self.isIncludeFiles = isIncludeFiles
                self.isIncludeDirectories = isIncludeDirectories
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(path, forKey: "path")
                encoder.encode(isIncludeFiles, forKey: "includeFiles")
                encoder.encode(isIncludeDirectories, forKey: "includeDirectories")
                return encoder.items
            }
        }
    }
}

extension Paths.Persons {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/Persons/{name}`
        public let path: String

        /// Get person by name.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID.Images.WithImageType {
    public func imageIndex(_ imageIndex: Int) -> WithImageIndex {
        WithImageIndex(path: "\(path)/\(imageIndex)")
    }

    public struct WithImageIndex {
        /// Path: `/Users/{userId}/Images/{imageType}/{imageIndex}`
        public let path: String

        /// Get user profile image.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }

        /// Get user profile image.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/Users")
    }

    public struct Users {
        /// Path: `/Users`
        public let path: String

        /// Gets a list of users.
        public func get(isHidden: Bool? = nil, isDisabled: Bool? = nil) -> Request<[JellyfinAPI.UserDto]> {
            .get(path, query: makeGetQuery(isHidden, isDisabled))
        }

        private func makeGetQuery(_ isHidden: Bool?, _ isDisabled: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isHidden, forKey: "isHidden")
            encoder.encode(isDisabled, forKey: "isDisabled")
            return encoder.items
        }
    }
}

extension Paths.Dlna.WithServerID.MediaReceiverRegistrar {
    public var mediaReceiverRegistrarXml: MediaReceiverRegistrarXml {
        MediaReceiverRegistrarXml(path: path + "/MediaReceiverRegistrar.xml")
    }

    public struct MediaReceiverRegistrarXml {
        /// Path: `/Dlna/{serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar.xml`
        public let path: String

        /// Gets Dlna media receiver registrar xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var devices: Devices {
        Devices(path: "/Devices")
    }

    public struct Devices {
        /// Path: `/Devices`
        public let path: String

        /// Get Devices.
        public func get(isSupportsSync: Bool? = nil, userID: String? = nil) -> Request<JellyfinAPI.DeviceInfoQueryResult> {
            .get(path, query: makeGetQuery(isSupportsSync, userID))
        }

        private func makeGetQuery(_ isSupportsSync: Bool?, _ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isSupportsSync, forKey: "supportsSync")
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }

        /// Deletes a device.
        public func delete(id: String) -> Request<Void> {
            .delete(path, query: [("id", id)])
        }
    }
}

extension Paths {
    public static var libraries: Libraries {
        Libraries(path: "/Libraries")
    }

    public struct Libraries {
        /// Path: `/Libraries`
        public let path: String
    }
}

extension Paths.Libraries {
    public var availableOptions: AvailableOptions {
        AvailableOptions(path: path + "/AvailableOptions")
    }

    public struct AvailableOptions {
        /// Path: `/Libraries/AvailableOptions`
        public let path: String

        /// Gets the library options info.
        public func get(libraryContentType: String? = nil, isNewLibrary: Bool? = nil) -> Request<JellyfinAPI.LibraryOptionsResultDto> {
            .get(path, query: makeGetQuery(libraryContentType, isNewLibrary))
        }

        private func makeGetQuery(_ libraryContentType: String?, _ isNewLibrary: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(libraryContentType, forKey: "libraryContentType")
            encoder.encode(isNewLibrary, forKey: "isNewLibrary")
            return encoder.items
        }
    }
}

extension Paths {
    public static var playlists: Playlists {
        Playlists(path: "/Playlists")
    }

    public struct Playlists {
        /// Path: `/Playlists`
        public let path: String

        /// Creates a new playlist.
        ///
        /// For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
Query parameters are obsolete.
        public func post(parameters: PostParameters? = nil, _ body: JellyfinAPI.CreatePlaylistDto? = nil) -> Request<JellyfinAPI.PlaylistCreationResult> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            /// The playlist name.
            public var name: String?
            /// The item ids.
            public var ids: [String]?
            /// The user id.
            public var userID: String?
            /// The media type.
            public var mediaType: String?

            public init(name: String? = nil, ids: [String]? = nil, userID: String? = nil, mediaType: String? = nil) {
                self.name = name
                self.ids = ids
                self.userID = userID
                self.mediaType = mediaType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(ids, forKey: "ids")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(mediaType, forKey: "mediaType")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.RemoteSearch {
    public var boxSet: BoxSet {
        BoxSet(path: path + "/BoxSet")
    }

    public struct BoxSet {
        /// Path: `/Items/RemoteSearch/BoxSet`
        public let path: String

        /// Get box set remote search.
        public func post(_ body: JellyfinAPI.BoxSetInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Auth {
    public var passwordResetProviders: PasswordResetProviders {
        PasswordResetProviders(path: path + "/PasswordResetProviders")
    }

    public struct PasswordResetProviders {
        /// Path: `/Auth/PasswordResetProviders`
        public let path: String

        /// Get all password reset providers.
        public var get: Request<[JellyfinAPI.NameIDPair]> {
            .get(path)
        }
    }
}

extension Paths.Dlna.WithServerID.ContentDirectory {
    public var control: Control {
        Control(path: path + "/Control")
    }

    public struct Control {
        /// Path: `/Dlna/{serverId}/ContentDirectory/Control`
        public let path: String

        /// Process a content directory control request.
        public var post: Request<String> {
            .post(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var suggestions: Suggestions {
        Suggestions(path: path + "/Suggestions")
    }

    public struct Suggestions {
        /// Path: `/Users/{userId}/Suggestions`
        public let path: String

        /// Gets suggestions.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The media types.
            public var mediaType: [String]?
            /// The type.
            public var type: [String]?
            /// Optional. The start index.
            public var startIndex: Int?
            /// Optional. The limit.
            public var limit: Int?
            /// Whether to enable the total record count.
            public var enableTotalRecordCount: Bool?

            public init(mediaType: [String]? = nil, type: [String]? = nil, startIndex: Int? = nil, limit: Int? = nil, enableTotalRecordCount: Bool? = nil) {
                self.mediaType = mediaType
                self.type = type
                self.startIndex = startIndex
                self.limit = limit
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(mediaType, forKey: "mediaType")
                encoder.encode(type, forKey: "type")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }
    }
}

extension Paths.System {
    public var restart: Restart {
        Restart(path: path + "/Restart")
    }

    public struct Restart {
        /// Path: `/System/Restart`
        public let path: String

        /// Restarts the application.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.LiveTv {
    public var channels: Channels {
        Channels(path: path + "/Channels")
    }

    public struct Channels {
        /// Path: `/LiveTv/Channels`
        public let path: String

        /// Gets available live tv channels.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by channel type.
            public var type: `Type`?
            /// Optional. Filter by user and attach user data.
            public var userID: String?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. Filter for movies.
            public var isMovie: Bool?
            /// Optional. Filter for series.
            public var isSeries: Bool?
            /// Optional. Filter for news.
            public var isNews: Bool?
            /// Optional. Filter for kids.
            public var isKids: Bool?
            /// Optional. Filter for sports.
            public var isSports: Bool?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Filter by channels that are favorites, or not.
            public var isFavorite: Bool?
            /// Optional. Filter by channels that are liked, or not.
            public var isLiked: Bool?
            /// Optional. Filter by channels that are disliked, or not.
            public var isDisliked: Bool?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// "Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. Key to sort by.
            public var sortBy: [String]?
            /// Optional. Sort order.
            public var sortOrder: SortOrder?
            /// Optional. Incorporate favorite and like status into channel sorting.
            public var enableFavoriteSorting: Bool?
            /// Optional. Adds current program info to each channel.
            public var isAddCurrentProgram: Bool?

            public typealias `Type` = JellyfinAPI.ChannelType

            public typealias SortOrder = JellyfinAPI.SortOrder

            public init(type: `Type`? = nil, userID: String? = nil, startIndex: Int? = nil, isMovie: Bool? = nil, isSeries: Bool? = nil, isNews: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, limit: Int? = nil, isFavorite: Bool? = nil, isLiked: Bool? = nil, isDisliked: Bool? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableUserData: Bool? = nil, sortBy: [String]? = nil, sortOrder: SortOrder? = nil, enableFavoriteSorting: Bool? = nil, isAddCurrentProgram: Bool? = nil) {
                self.type = type
                self.userID = userID
                self.startIndex = startIndex
                self.isMovie = isMovie
                self.isSeries = isSeries
                self.isNews = isNews
                self.isKids = isKids
                self.isSports = isSports
                self.limit = limit
                self.isFavorite = isFavorite
                self.isLiked = isLiked
                self.isDisliked = isDisliked
                self.enableImages = enableImages
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.fields = fields
                self.enableUserData = enableUserData
                self.sortBy = sortBy
                self.sortOrder = sortOrder
                self.enableFavoriteSorting = enableFavoriteSorting
                self.isAddCurrentProgram = isAddCurrentProgram
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(isMovie, forKey: "isMovie")
                encoder.encode(isSeries, forKey: "isSeries")
                encoder.encode(isNews, forKey: "isNews")
                encoder.encode(isKids, forKey: "isKids")
                encoder.encode(isSports, forKey: "isSports")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(isLiked, forKey: "isLiked")
                encoder.encode(isDisliked, forKey: "isDisliked")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(sortBy, forKey: "sortBy")
                encoder.encode(sortOrder, forKey: "sortOrder")
                encoder.encode(enableFavoriteSorting, forKey: "enableFavoriteSorting")
                encoder.encode(isAddCurrentProgram, forKey: "addCurrentProgram")
                return encoder.items
            }
        }
    }
}

extension Paths.Dlna.Profiles {
    public var `default`: Default {
        Default(path: path + "/Default")
    }

    public struct Default {
        /// Path: `/Dlna/Profiles/Default`
        public let path: String

        /// Gets the default profile.
        public var get: Request<JellyfinAPI.DeviceProfile> {
            .get(path)
        }
    }
}

extension Paths.Plugins {
    public func pluginID(_ pluginID: String) -> WithPluginID {
        WithPluginID(path: "\(path)/\(pluginID)")
    }

    public struct WithPluginID {
        /// Path: `/Plugins/{pluginId}`
        public let path: String

        /// Uninstalls a plugin.
        @available(*, deprecated, message: "Deprecated")
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.LiveTv {
    public var timers: Timers {
        Timers(path: path + "/Timers")
    }

    public struct Timers {
        /// Path: `/LiveTv/Timers`
        public let path: String

        /// Gets the live tv timers.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.TimerInfoDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Filter by channel id.
            public var channelID: String?
            /// Optional. Filter by timers belonging to a series timer.
            public var seriesTimerID: String?
            /// Optional. Filter by timers that are active.
            public var isActive: Bool?
            /// Optional. Filter by timers that are scheduled.
            public var isScheduled: Bool?

            public init(channelID: String? = nil, seriesTimerID: String? = nil, isActive: Bool? = nil, isScheduled: Bool? = nil) {
                self.channelID = channelID
                self.seriesTimerID = seriesTimerID
                self.isActive = isActive
                self.isScheduled = isScheduled
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(channelID, forKey: "channelId")
                encoder.encode(seriesTimerID, forKey: "seriesTimerId")
                encoder.encode(isActive, forKey: "isActive")
                encoder.encode(isScheduled, forKey: "isScheduled")
                return encoder.items
            }
        }

        /// Creates a live tv timer.
        public func post(_ body: JellyfinAPI.TimerInfoDto? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Startup {
    public var configuration: Configuration {
        Configuration(path: path + "/Configuration")
    }

    public struct Configuration {
        /// Path: `/Startup/Configuration`
        public let path: String

        /// Gets the initial startup wizard configuration.
        public var get: Request<JellyfinAPI.StartupConfigurationDto> {
            .get(path)
        }

        /// Sets the initial startup wizard configuration.
        public func post(_ body: JellyfinAPI.StartupConfigurationDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Library {
    public var physicalPaths: PhysicalPaths {
        PhysicalPaths(path: path + "/PhysicalPaths")
    }

    public struct PhysicalPaths {
        /// Path: `/Library/PhysicalPaths`
        public let path: String

        /// Gets a list of physical paths from virtual folders.
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths.Localization {
    public var cultures: Cultures {
        Cultures(path: path + "/Cultures")
    }

    public struct Cultures {
        /// Path: `/Localization/Cultures`
        public let path: String

        /// Gets known cultures.
        public var get: Request<[JellyfinAPI.CultureDto]> {
            .get(path)
        }
    }
}

extension Paths.Sessions.Playing {
    public var stopped: Stopped {
        Stopped(path: path + "/Stopped")
    }

    public struct Stopped {
        /// Path: `/Sessions/Playing/Stopped`
        public let path: String

        /// Reports playback has stopped within a session.
        public func post(_ body: JellyfinAPI.PlaybackStopInfo? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Dlna.WithServerID.ContentDirectory {
    public var contentDirectoryXml: ContentDirectoryXml {
        ContentDirectoryXml(path: path + "/ContentDirectory.xml")
    }

    public struct ContentDirectoryXml {
        /// Path: `/Dlna/{serverId}/ContentDirectory/ContentDirectory.xml`
        public let path: String

        /// Gets Dlna content directory xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Shows {
    public var nextUp: NextUp {
        NextUp(path: path + "/NextUp")
    }

    public struct NextUp {
        /// Path: `/Shows/NextUp`
        public let path: String

        /// Gets a list of next up episodes.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The user id of the user to get the next up episodes for.
            public var userID: String?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Filter by series id.
            public var seriesID: String?
            /// Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Include image information in output.
            public var enableImges: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Whether to enable the total records count. Defaults to true.
            public var enableTotalRecordCount: Bool?
            /// Whether to disable sending the first episode in a series as next up.
            public var isDisableFirstEpisode: Bool?

            public init(userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, seriesID: String? = nil, parentID: String? = nil, enableImges: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil, enableTotalRecordCount: Bool? = nil, isDisableFirstEpisode: Bool? = nil) {
                self.userID = userID
                self.startIndex = startIndex
                self.limit = limit
                self.fields = fields
                self.seriesID = seriesID
                self.parentID = parentID
                self.enableImges = enableImges
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.enableUserData = enableUserData
                self.enableTotalRecordCount = enableTotalRecordCount
                self.isDisableFirstEpisode = isDisableFirstEpisode
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(seriesID, forKey: "seriesId")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(enableImges, forKey: "enableImges")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                encoder.encode(isDisableFirstEpisode, forKey: "disableFirstEpisode")
                return encoder.items
            }
        }
    }
}

extension Paths.System {
    public var wakeOnLanInfo: WakeOnLanInfo {
        WakeOnLanInfo(path: path + "/WakeOnLanInfo")
    }

    public struct WakeOnLanInfo {
        /// Path: `/System/WakeOnLanInfo`
        public let path: String

        /// Gets wake on lan information.
        public var get: Request<[JellyfinAPI.WakeOnLanInfo]> {
            .get(path)
        }
    }
}

extension Paths.SyncPlay {
    public var queue: Queue {
        Queue(path: path + "/Queue")
    }

    public struct Queue {
        /// Path: `/SyncPlay/Queue`
        public let path: String

        /// Request to queue items to the playlist of a SyncPlay group.
        public func post(_ body: JellyfinAPI.QueueRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Items.WithItemID.RemoteImages {
    public var download: Download {
        Download(path: path + "/Download")
    }

    public struct Download {
        /// Path: `/Items/{itemId}/RemoteImages/Download`
        public let path: String

        /// Downloads a remote image for an item.
        public func post(type: `Type`, imageURL: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(type, imageURL))
        }

        private func makePostQuery(_ type: `Type`, _ imageURL: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(type, forKey: "type")
            encoder.encode(imageURL, forKey: "imageUrl")
            return encoder.items
        }

        public typealias `Type` = JellyfinAPI.ImageType
    }
}

extension Paths.SyncPlay {
    public var setIgnoreWait: SetIgnoreWait {
        SetIgnoreWait(path: path + "/SetIgnoreWait")
    }

    public struct SetIgnoreWait {
        /// Path: `/SyncPlay/SetIgnoreWait`
        public let path: String

        /// Request SyncPlay group to ignore member during group-wait.
        public func post(_ body: JellyfinAPI.IgnoreWaitRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Auth {
    public var providers: Providers {
        Providers(path: path + "/Providers")
    }

    public struct Providers {
        /// Path: `/Auth/Providers`
        public let path: String

        /// Get all auth providers.
        public var get: Request<[JellyfinAPI.NameIDPair]> {
            .get(path)
        }
    }
}

extension Paths.Videos.WithItemID {
    public var subtitles: Subtitles {
        Subtitles(path: path + "/Subtitles")
    }

    public struct Subtitles {
        /// Path: `/Videos/{itemId}/Subtitles`
        public let path: String

        /// Upload an external subtitle file.
        public func post(_ body: JellyfinAPI.UploadSubtitleDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.ScheduledTasks.WithTaskID {
    public var triggers: Triggers {
        Triggers(path: path + "/Triggers")
    }

    public struct Triggers {
        /// Path: `/ScheduledTasks/{taskId}/Triggers`
        public let path: String

        /// Update specified task triggers.
        public func post(_ body: [JellyfinAPI.TaskTriggerInfo]) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var providers: Providers {
        Providers(path: "/Providers")
    }

    public struct Providers {
        /// Path: `/Providers`
        public let path: String
    }
}

extension Paths.Providers {
    public var subtitles: Subtitles {
        Subtitles(path: path + "/Subtitles")
    }

    public struct Subtitles {
        /// Path: `/Providers/Subtitles`
        public let path: String
    }
}

extension Paths.Providers.Subtitles {
    public var subtitles: Subtitles {
        Subtitles(path: path + "/Subtitles")
    }

    public struct Subtitles {
        /// Path: `/Providers/Subtitles/Subtitles`
        public let path: String
    }
}

extension Paths.Providers.Subtitles.Subtitles {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/Providers/Subtitles/Subtitles/{id}`
        public let path: String

        /// Gets the remote subtitles.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Videos.WithItemID.Hls.WithPlaylistID {
    public func segmentID(_ segmentID: String) -> WithSegmentContainer {
        WithSegmentContainer(path: "\(path)/\(segmentID).{segmentContainer}")
    }

    public struct WithSegmentContainer {
        /// Path: `/Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}`
        public let path: String

        /// Gets a hls video segment.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.LiveStreams {
    public var `open`: Open {
        Open(path: path + "/Open")
    }

    public struct Open {
        /// Path: `/LiveStreams/Open`
        public let path: String

        /// Opens a media source.
        public func post(parameters: PostParameters? = nil, _ body: JellyfinAPI.OpenLiveStreamDto? = nil) -> Request<JellyfinAPI.LiveStreamResponse> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            /// The open token.
            public var openToken: String?
            /// The user id.
            public var userID: String?
            /// The play session id.
            public var playSessionID: String?
            /// The maximum streaming bitrate.
            public var maxStreamingBitrate: Int?
            /// The start time in ticks.
            public var startTimeTicks: Int?
            /// The audio stream index.
            public var audioStreamIndex: Int?
            /// The subtitle stream index.
            public var subtitleStreamIndex: Int?
            /// The maximum number of audio channels.
            public var maxAudioChannels: Int?
            /// The item id.
            public var itemID: String?
            /// Whether to enable direct play. Default: true.
            public var enableDirectPlay: Bool?
            /// Whether to enable direct stream. Default: true.
            public var enableDirectStream: Bool?

            public init(openToken: String? = nil, userID: String? = nil, playSessionID: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, itemID: String? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil) {
                self.openToken = openToken
                self.userID = userID
                self.playSessionID = playSessionID
                self.maxStreamingBitrate = maxStreamingBitrate
                self.startTimeTicks = startTimeTicks
                self.audioStreamIndex = audioStreamIndex
                self.subtitleStreamIndex = subtitleStreamIndex
                self.maxAudioChannels = maxAudioChannels
                self.itemID = itemID
                self.enableDirectPlay = enableDirectPlay
                self.enableDirectStream = enableDirectStream
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(openToken, forKey: "openToken")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(playSessionID, forKey: "playSessionId")
                encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
                encoder.encode(startTimeTicks, forKey: "startTimeTicks")
                encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
                encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
                encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
                encoder.encode(itemID, forKey: "itemId")
                encoder.encode(enableDirectPlay, forKey: "enableDirectPlay")
                encoder.encode(enableDirectStream, forKey: "enableDirectStream")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var search: Search {
        Search(path: "/Search")
    }

    public struct Search {
        /// Path: `/Search`
        public let path: String
    }
}

extension Paths.Search {
    public var hints: Hints {
        Hints(path: path + "/Hints")
    }

    public struct Hints {
        /// Path: `/Search/Hints`
        public let path: String

        /// Gets the search hint result.
        public func get(parameters: GetParameters) -> Request<JellyfinAPI.SearchHintResult> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Supply a user id to search within a user's library or omit to search all.
            public var userID: String?
            /// The search term to filter on.
            public var searchTerm: String
            /// If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
            public var includeItemTypes: [String]?
            /// If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
            public var excludeItemTypes: [String]?
            /// If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
            public var mediaTypes: [String]?
            /// If specified, only children of the parent are returned.
            public var parentID: String?
            /// Optional filter for movies.
            public var isMovie: Bool?
            /// Optional filter for series.
            public var isSeries: Bool?
            /// Optional filter for news.
            public var isNews: Bool?
            /// Optional filter for kids.
            public var isKids: Bool?
            /// Optional filter for sports.
            public var isSports: Bool?
            /// Optional filter whether to include people.
            public var isIncludePeople: Bool?
            /// Optional filter whether to include media.
            public var isIncludeMedia: Bool?
            /// Optional filter whether to include genres.
            public var isIncludeGenres: Bool?
            /// Optional filter whether to include studios.
            public var isIncludeStudios: Bool?
            /// Optional filter whether to include artists.
            public var isIncludeArtists: Bool?

            public init(startIndex: Int? = nil, limit: Int? = nil, userID: String? = nil, searchTerm: String, includeItemTypes: [String]? = nil, excludeItemTypes: [String]? = nil, mediaTypes: [String]? = nil, parentID: String? = nil, isMovie: Bool? = nil, isSeries: Bool? = nil, isNews: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, isIncludePeople: Bool? = nil, isIncludeMedia: Bool? = nil, isIncludeGenres: Bool? = nil, isIncludeStudios: Bool? = nil, isIncludeArtists: Bool? = nil) {
                self.startIndex = startIndex
                self.limit = limit
                self.userID = userID
                self.searchTerm = searchTerm
                self.includeItemTypes = includeItemTypes
                self.excludeItemTypes = excludeItemTypes
                self.mediaTypes = mediaTypes
                self.parentID = parentID
                self.isMovie = isMovie
                self.isSeries = isSeries
                self.isNews = isNews
                self.isKids = isKids
                self.isSports = isSports
                self.isIncludePeople = isIncludePeople
                self.isIncludeMedia = isIncludeMedia
                self.isIncludeGenres = isIncludeGenres
                self.isIncludeStudios = isIncludeStudios
                self.isIncludeArtists = isIncludeArtists
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(mediaTypes, forKey: "mediaTypes")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(isMovie, forKey: "isMovie")
                encoder.encode(isSeries, forKey: "isSeries")
                encoder.encode(isNews, forKey: "isNews")
                encoder.encode(isKids, forKey: "isKids")
                encoder.encode(isSports, forKey: "isSports")
                encoder.encode(isIncludePeople, forKey: "includePeople")
                encoder.encode(isIncludeMedia, forKey: "includeMedia")
                encoder.encode(isIncludeGenres, forKey: "includeGenres")
                encoder.encode(isIncludeStudios, forKey: "includeStudios")
                encoder.encode(isIncludeArtists, forKey: "includeArtists")
                return encoder.items
            }
        }
    }
}

extension Paths.Artists.WithName {
    public var images: Images {
        Images(path: path + "/Images")
    }

    public struct Images {
        /// Path: `/Artists/{name}/Images`
        public let path: String
    }
}

extension Paths.Artists.WithName.Images {
    public func imageType(_ imageType: String) -> WithImageType {
        WithImageType(path: "\(path)/\(imageType)")
    }

    public struct WithImageType {
        /// Path: `/Artists/{name}/Images/{imageType}`
        public let path: String
    }
}

extension Paths.Artists.WithName.Images.WithImageType {
    public func imageIndex(_ imageIndex: Int) -> WithImageIndex {
        WithImageIndex(path: "\(path)/\(imageIndex)")
    }

    public struct WithImageIndex {
        /// Path: `/Artists/{name}/Images/{imageType}/{imageIndex}`
        public let path: String

        /// Get artist image by name.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }

        /// Get artist image by name.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                return encoder.items
            }
        }
    }
}

extension Paths.Audio.WithItemID.Hls.WithSegmentID {
    public var streamMp3: StreamMp3 {
        StreamMp3(path: path + "/stream.mp3")
    }

    public struct StreamMp3 {
        /// Path: `/Audio/{itemId}/hls/{segmentId}/stream.mp3`
        public let path: String

        /// Gets the specified audio segment for an audio item.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.LiveTv {
    public var programs: Programs {
        Programs(path: path + "/Programs")
    }

    public struct Programs {
        /// Path: `/LiveTv/Programs`
        public let path: String

        /// Gets available live tv epgs.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The channels to return guide information for.
            public var channelIDs: [String]?
            /// Optional. Filter by user id.
            public var userID: String?
            /// Optional. The minimum premiere start date.
            public var minStartDate: Date?
            /// Optional. Filter by programs that have completed airing, or not.
            public var hasAired: Bool?
            /// Optional. Filter by programs that are currently airing, or not.
            public var isAiring: Bool?
            /// Optional. The maximum premiere start date.
            public var maxStartDate: Date?
            /// Optional. The minimum premiere end date.
            public var minEndDate: Date?
            /// Optional. The maximum premiere end date.
            public var maxEndDate: Date?
            /// Optional. Filter for movies.
            public var isMovie: Bool?
            /// Optional. Filter for series.
            public var isSeries: Bool?
            /// Optional. Filter for news.
            public var isNews: Bool?
            /// Optional. Filter for kids.
            public var isKids: Bool?
            /// Optional. Filter for sports.
            public var isSports: Bool?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
            public var sortBy: [String]?
            /// Sort Order - Ascending,Descending.
            public var sortOrder: [JellyfinAPI.SortOrder]?
            /// The genres to return guide information for.
            public var genres: [String]?
            /// The genre ids to return guide information for.
            public var genreIDs: [String]?
            /// Optional. Include image information in output.
            public var enableImages: Bool?
            /// Optional. The max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Include user data.
            public var enableUserData: Bool?
            /// Optional. Filter by series timer id.
            public var seriesTimerID: String?
            /// Optional. Filter by library series id.
            public var librarySeriesID: String?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Retrieve total record count.
            public var enableTotalRecordCount: Bool?

            public init(channelIDs: [String]? = nil, userID: String? = nil, minStartDate: Date? = nil, hasAired: Bool? = nil, isAiring: Bool? = nil, maxStartDate: Date? = nil, minEndDate: Date? = nil, maxEndDate: Date? = nil, isMovie: Bool? = nil, isSeries: Bool? = nil, isNews: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, startIndex: Int? = nil, limit: Int? = nil, sortBy: [String]? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, genres: [String]? = nil, genreIDs: [String]? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil, seriesTimerID: String? = nil, librarySeriesID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableTotalRecordCount: Bool? = nil) {
                self.channelIDs = channelIDs
                self.userID = userID
                self.minStartDate = minStartDate
                self.hasAired = hasAired
                self.isAiring = isAiring
                self.maxStartDate = maxStartDate
                self.minEndDate = minEndDate
                self.maxEndDate = maxEndDate
                self.isMovie = isMovie
                self.isSeries = isSeries
                self.isNews = isNews
                self.isKids = isKids
                self.isSports = isSports
                self.startIndex = startIndex
                self.limit = limit
                self.sortBy = sortBy
                self.sortOrder = sortOrder
                self.genres = genres
                self.genreIDs = genreIDs
                self.enableImages = enableImages
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.enableUserData = enableUserData
                self.seriesTimerID = seriesTimerID
                self.librarySeriesID = librarySeriesID
                self.fields = fields
                self.enableTotalRecordCount = enableTotalRecordCount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(channelIDs, forKey: "channelIds")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(minStartDate, forKey: "minStartDate")
                encoder.encode(hasAired, forKey: "hasAired")
                encoder.encode(isAiring, forKey: "isAiring")
                encoder.encode(maxStartDate, forKey: "maxStartDate")
                encoder.encode(minEndDate, forKey: "minEndDate")
                encoder.encode(maxEndDate, forKey: "maxEndDate")
                encoder.encode(isMovie, forKey: "isMovie")
                encoder.encode(isSeries, forKey: "isSeries")
                encoder.encode(isNews, forKey: "isNews")
                encoder.encode(isKids, forKey: "isKids")
                encoder.encode(isSports, forKey: "isSports")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(sortBy, forKey: "sortBy")
                encoder.encode(sortOrder, forKey: "sortOrder")
                encoder.encode(genres, forKey: "genres")
                encoder.encode(genreIDs, forKey: "genreIds")
                encoder.encode(enableImages, forKey: "enableImages")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(seriesTimerID, forKey: "seriesTimerId")
                encoder.encode(librarySeriesID, forKey: "librarySeriesId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                return encoder.items
            }
        }

        /// Gets available live tv epgs.
        public func post(_ body: JellyfinAPI.GetProgramsDto? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .post(path, body: body)
        }
    }
}

extension Paths.Images.General {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/Images/General/{name}`
        public let path: String
    }
}

extension Paths.Images.General.WithName {
    public func type(_ type: String) -> WithType {
        WithType(path: "\(path)/\(type)")
    }

    public struct WithType {
        /// Path: `/Images/General/{name}/{type}`
        public let path: String

        /// Get General Image.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.FallbackFont {
    public var fonts: Fonts {
        Fonts(path: path + "/Fonts")
    }

    public struct Fonts {
        /// Path: `/FallbackFont/Fonts`
        public let path: String

        /// Gets a list of available fallback font files.
        public var get: Request<[JellyfinAPI.FontFile]> {
            .get(path)
        }
    }
}

extension Paths.Dlna.WithServerID.MediaReceiverRegistrar {
    public var mediaReceiverRegistrar: MediaReceiverRegistrar {
        MediaReceiverRegistrar(path: path + "/MediaReceiverRegistrar")
    }

    public struct MediaReceiverRegistrar {
        /// Path: `/Dlna/{serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar`
        public let path: String

        /// Gets Dlna media receiver registrar xml.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Branding {
    public var css: Css {
        Css(path: path + "/Css")
    }

    public struct Css {
        /// Path: `/Branding/Css`
        public let path: String

        /// Gets branding css.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var persons: Persons {
        Persons(path: "/Persons")
    }

    public struct Persons {
        /// Path: `/Persons`
        public let path: String

        /// Gets all persons.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// The search term.
            public var searchTerm: String?
            /// Optional. Specify additional fields of information to return in the output.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. Specify additional filters to apply.
            public var filters: [JellyfinAPI.ItemFilter]?
            /// Optional filter by items that are marked as favorite, or not. userId is required.
            public var isFavorite: Bool?
            /// Optional, include user data.
            public var enableUserData: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.
            public var excludePersonTypes: [String]?
            /// Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.
            public var personTypes: [String]?
            /// Optional. If specified, person results will be filtered on items related to said persons.
            public var appearsInItemID: String?
            /// User id.
            public var userID: String?
            /// Optional, include image information in output.
            public var enableImages: Bool?

            public init(limit: Int? = nil, searchTerm: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, excludePersonTypes: [String]? = nil, personTypes: [String]? = nil, appearsInItemID: String? = nil, userID: String? = nil, enableImages: Bool? = nil) {
                self.limit = limit
                self.searchTerm = searchTerm
                self.fields = fields
                self.filters = filters
                self.isFavorite = isFavorite
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.excludePersonTypes = excludePersonTypes
                self.personTypes = personTypes
                self.appearsInItemID = appearsInItemID
                self.userID = userID
                self.enableImages = enableImages
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(filters, forKey: "filters")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(excludePersonTypes, forKey: "excludePersonTypes")
                encoder.encode(personTypes, forKey: "personTypes")
                encoder.encode(appearsInItemID, forKey: "appearsInItemId")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(enableImages, forKey: "enableImages")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var views: Views {
        Views(path: path + "/Views")
    }

    public struct Views {
        /// Path: `/Users/{userId}/Views`
        public let path: String

        /// Get user views.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Whether or not to include external views such as channels or live tv.
            public var isIncludeExternalContent: Bool?
            /// Preset views.
            public var presetViews: [String]?
            /// Whether or not to include hidden content.
            public var isIncludeHidden: Bool?

            public init(isIncludeExternalContent: Bool? = nil, presetViews: [String]? = nil, isIncludeHidden: Bool? = nil) {
                self.isIncludeExternalContent = isIncludeExternalContent
                self.presetViews = presetViews
                self.isIncludeHidden = isIncludeHidden
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isIncludeExternalContent, forKey: "includeExternalContent")
                encoder.encode(presetViews, forKey: "presetViews")
                encoder.encode(isIncludeHidden, forKey: "includeHidden")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var packages: Packages {
        Packages(path: "/Packages")
    }

    public struct Packages {
        /// Path: `/Packages`
        public let path: String

        /// Gets available packages.
        public var get: Request<[JellyfinAPI.PackageInfo]> {
            .get(path)
        }
    }
}

extension Paths.Library {
    public var media: Media {
        Media(path: path + "/Media")
    }

    public struct Media {
        /// Path: `/Library/Media`
        public let path: String
    }
}

extension Paths.Library.Media {
    public var updated: Updated {
        Updated(path: path + "/Updated")
    }

    public struct Updated {
        /// Path: `/Library/Media/Updated`
        public let path: String

        /// Reports that new movies have been added by an external source.
        public func post(_ body: JellyfinAPI.MediaUpdateInfoDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var trailers: Trailers {
        Trailers(path: "/Trailers")
    }

    public struct Trailers {
        /// Path: `/Trailers`
        public let path: String

        /// Finds movies and trailers similar to a given trailer.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The user id.
            public var userID: String?
            /// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
            public var maxOfficialRating: String?
            /// Optional filter by items with theme songs.
            public var hasThemeSong: Bool?
            /// Optional filter by items with theme videos.
            public var hasThemeVideo: Bool?
            /// Optional filter by items with subtitles.
            public var hasSubtitles: Bool?
            /// Optional filter by items with special features.
            public var hasSpecialFeature: Bool?
            /// Optional filter by items with trailers.
            public var hasTrailer: Bool?
            /// Optional. Return items that are siblings of a supplied item.
            public var adjacentTo: String?
            /// Optional filter by parent index number.
            public var parentIndexNumber: Int?
            /// Optional filter by items that have or do not have a parental rating.
            public var hasParentalRating: Bool?
            /// Optional filter by items that are HD or not.
            public var isHd: Bool?
            /// Optional filter by items that are 4K or not.
            public var isIs4K: Bool?
            /// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
            public var locationTypes: [JellyfinAPI.LocationType]?
            /// Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
            public var excludeLocationTypes: [JellyfinAPI.LocationType]?
            /// Optional filter by items that are missing episodes or not.
            public var isMissing: Bool?
            /// Optional filter by items that are unaired episodes or not.
            public var isUnaired: Bool?
            /// Optional filter by minimum community rating.
            public var minCommunityRating: Double?
            /// Optional filter by minimum critic rating.
            public var minCriticRating: Double?
            /// Optional. The minimum premiere date. Format = ISO.
            public var minPremiereDate: Date?
            /// Optional. The minimum last saved date. Format = ISO.
            public var minDateLastSaved: Date?
            /// Optional. The minimum last saved date for the current user. Format = ISO.
            public var minDateLastSavedForUser: Date?
            /// Optional. The maximum premiere date. Format = ISO.
            public var maxPremiereDate: Date?
            /// Optional filter by items that have an overview or not.
            public var hasOverview: Bool?
            /// Optional filter by items that have an imdb id or not.
            public var hasImdbID: Bool?
            /// Optional filter by items that have a tmdb id or not.
            public var hasTmdbID: Bool?
            /// Optional filter by items that have a tvdb id or not.
            public var hasTvdbID: Bool?
            /// Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
            public var excludeItemIDs: [String]?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// When searching within folders, this determines whether or not the search will be recursive. true/false.
            public var isRecursive: Bool?
            /// Optional. Filter based on a search term.
            public var searchTerm: String?
            /// Sort Order - Ascending,Descending.
            public var sortOrder: [JellyfinAPI.SortOrder]?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
            public var excludeItemTypes: [String]?
            /// Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
            public var filters: [JellyfinAPI.ItemFilter]?
            /// Optional filter by items that are marked as favorite, or not.
            public var isFavorite: Bool?
            /// Optional filter by MediaType. Allows multiple, comma delimited.
            public var mediaTypes: [String]?
            /// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
            public var imageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
            public var sortBy: [String]?
            /// Optional filter by items that are played, or not.
            public var isPlayed: Bool?
            /// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
            public var genres: [String]?
            /// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
            public var officialRatings: [String]?
            /// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
            public var tags: [String]?
            /// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
            public var years: [Int]?
            /// Optional, include user data.
            public var enableUserData: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. If specified, results will be filtered to include only those containing the specified person.
            public var person: String?
            /// Optional. If specified, results will be filtered to include only those containing the specified person id.
            public var personIDs: [String]?
            /// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
            public var personTypes: [String]?
            /// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
            public var studios: [String]?
            /// Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
            public var artists: [String]?
            /// Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
            public var excludeArtistIDs: [String]?
            /// Optional. If specified, results will be filtered to include only those containing the specified artist id.
            public var artistIDs: [String]?
            /// Optional. If specified, results will be filtered to include only those containing the specified album artist id.
            public var albumArtistIDs: [String]?
            /// Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
            public var contributingArtistIDs: [String]?
            /// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
            public var albums: [String]?
            /// Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
            public var albumIDs: [String]?
            /// Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
            public var ids: [String]?
            /// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
            public var videoTypes: [JellyfinAPI.VideoType]?
            /// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
            public var minOfficialRating: String?
            /// Optional filter by items that are locked.
            public var isLocked: Bool?
            /// Optional filter by items that are placeholders.
            public var isPlaceHolder: Bool?
            /// Optional filter by items that have official ratings.
            public var hasOfficialRating: Bool?
            /// Whether or not to hide items behind their boxsets.
            public var isCollapseBoxSetItems: Bool?
            /// Optional. Filter by the minimum width of the item.
            public var minWidth: Int?
            /// Optional. Filter by the minimum height of the item.
            public var minHeight: Int?
            /// Optional. Filter by the maximum width of the item.
            public var maxWidth: Int?
            /// Optional. Filter by the maximum height of the item.
            public var maxHeight: Int?
            /// Optional filter by items that are 3D, or not.
            public var isIs3D: Bool?
            /// Optional filter by Series Status. Allows multiple, comma delimited.
            public var seriesStatus: [JellyfinAPI.SeriesStatus]?
            /// Optional filter by items whose name is sorted equally or greater than a given input string.
            public var nameStartsWithOrGreater: String?
            /// Optional filter by items whose name is sorted equally than a given input string.
            public var nameStartsWith: String?
            /// Optional filter by items whose name is equally or lesser than a given input string.
            public var nameLessThan: String?
            /// Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
            public var studioIDs: [String]?
            /// Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
            public var genreIDs: [String]?
            /// Optional. Enable the total record count.
            public var enableTotalRecordCount: Bool?
            /// Optional, include image information in output.
            public var enableImages: Bool?

            public init(userID: String? = nil, maxOfficialRating: String? = nil, hasThemeSong: Bool? = nil, hasThemeVideo: Bool? = nil, hasSubtitles: Bool? = nil, hasSpecialFeature: Bool? = nil, hasTrailer: Bool? = nil, adjacentTo: String? = nil, parentIndexNumber: Int? = nil, hasParentalRating: Bool? = nil, isHd: Bool? = nil, isIs4K: Bool? = nil, locationTypes: [JellyfinAPI.LocationType]? = nil, excludeLocationTypes: [JellyfinAPI.LocationType]? = nil, isMissing: Bool? = nil, isUnaired: Bool? = nil, minCommunityRating: Double? = nil, minCriticRating: Double? = nil, minPremiereDate: Date? = nil, minDateLastSaved: Date? = nil, minDateLastSavedForUser: Date? = nil, maxPremiereDate: Date? = nil, hasOverview: Bool? = nil, hasImdbID: Bool? = nil, hasTmdbID: Bool? = nil, hasTvdbID: Bool? = nil, excludeItemIDs: [String]? = nil, startIndex: Int? = nil, limit: Int? = nil, isRecursive: Bool? = nil, searchTerm: String? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, imageTypes: [JellyfinAPI.ImageType]? = nil, sortBy: [String]? = nil, isPlayed: Bool? = nil, genres: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, artists: [String]? = nil, excludeArtistIDs: [String]? = nil, artistIDs: [String]? = nil, albumArtistIDs: [String]? = nil, contributingArtistIDs: [String]? = nil, albums: [String]? = nil, albumIDs: [String]? = nil, ids: [String]? = nil, videoTypes: [JellyfinAPI.VideoType]? = nil, minOfficialRating: String? = nil, isLocked: Bool? = nil, isPlaceHolder: Bool? = nil, hasOfficialRating: Bool? = nil, isCollapseBoxSetItems: Bool? = nil, minWidth: Int? = nil, minHeight: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, isIs3D: Bool? = nil, seriesStatus: [JellyfinAPI.SeriesStatus]? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, studioIDs: [String]? = nil, genreIDs: [String]? = nil, enableTotalRecordCount: Bool? = nil, enableImages: Bool? = nil) {
                self.userID = userID
                self.maxOfficialRating = maxOfficialRating
                self.hasThemeSong = hasThemeSong
                self.hasThemeVideo = hasThemeVideo
                self.hasSubtitles = hasSubtitles
                self.hasSpecialFeature = hasSpecialFeature
                self.hasTrailer = hasTrailer
                self.adjacentTo = adjacentTo
                self.parentIndexNumber = parentIndexNumber
                self.hasParentalRating = hasParentalRating
                self.isHd = isHd
                self.isIs4K = isIs4K
                self.locationTypes = locationTypes
                self.excludeLocationTypes = excludeLocationTypes
                self.isMissing = isMissing
                self.isUnaired = isUnaired
                self.minCommunityRating = minCommunityRating
                self.minCriticRating = minCriticRating
                self.minPremiereDate = minPremiereDate
                self.minDateLastSaved = minDateLastSaved
                self.minDateLastSavedForUser = minDateLastSavedForUser
                self.maxPremiereDate = maxPremiereDate
                self.hasOverview = hasOverview
                self.hasImdbID = hasImdbID
                self.hasTmdbID = hasTmdbID
                self.hasTvdbID = hasTvdbID
                self.excludeItemIDs = excludeItemIDs
                self.startIndex = startIndex
                self.limit = limit
                self.isRecursive = isRecursive
                self.searchTerm = searchTerm
                self.sortOrder = sortOrder
                self.parentID = parentID
                self.fields = fields
                self.excludeItemTypes = excludeItemTypes
                self.filters = filters
                self.isFavorite = isFavorite
                self.mediaTypes = mediaTypes
                self.imageTypes = imageTypes
                self.sortBy = sortBy
                self.isPlayed = isPlayed
                self.genres = genres
                self.officialRatings = officialRatings
                self.tags = tags
                self.years = years
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.person = person
                self.personIDs = personIDs
                self.personTypes = personTypes
                self.studios = studios
                self.artists = artists
                self.excludeArtistIDs = excludeArtistIDs
                self.artistIDs = artistIDs
                self.albumArtistIDs = albumArtistIDs
                self.contributingArtistIDs = contributingArtistIDs
                self.albums = albums
                self.albumIDs = albumIDs
                self.ids = ids
                self.videoTypes = videoTypes
                self.minOfficialRating = minOfficialRating
                self.isLocked = isLocked
                self.isPlaceHolder = isPlaceHolder
                self.hasOfficialRating = hasOfficialRating
                self.isCollapseBoxSetItems = isCollapseBoxSetItems
                self.minWidth = minWidth
                self.minHeight = minHeight
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.isIs3D = isIs3D
                self.seriesStatus = seriesStatus
                self.nameStartsWithOrGreater = nameStartsWithOrGreater
                self.nameStartsWith = nameStartsWith
                self.nameLessThan = nameLessThan
                self.studioIDs = studioIDs
                self.genreIDs = genreIDs
                self.enableTotalRecordCount = enableTotalRecordCount
                self.enableImages = enableImages
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(maxOfficialRating, forKey: "maxOfficialRating")
                encoder.encode(hasThemeSong, forKey: "hasThemeSong")
                encoder.encode(hasThemeVideo, forKey: "hasThemeVideo")
                encoder.encode(hasSubtitles, forKey: "hasSubtitles")
                encoder.encode(hasSpecialFeature, forKey: "hasSpecialFeature")
                encoder.encode(hasTrailer, forKey: "hasTrailer")
                encoder.encode(adjacentTo, forKey: "adjacentTo")
                encoder.encode(parentIndexNumber, forKey: "parentIndexNumber")
                encoder.encode(hasParentalRating, forKey: "hasParentalRating")
                encoder.encode(isHd, forKey: "isHd")
                encoder.encode(isIs4K, forKey: "is4K")
                encoder.encode(locationTypes, forKey: "locationTypes")
                encoder.encode(excludeLocationTypes, forKey: "excludeLocationTypes")
                encoder.encode(isMissing, forKey: "isMissing")
                encoder.encode(isUnaired, forKey: "isUnaired")
                encoder.encode(minCommunityRating, forKey: "minCommunityRating")
                encoder.encode(minCriticRating, forKey: "minCriticRating")
                encoder.encode(minPremiereDate, forKey: "minPremiereDate")
                encoder.encode(minDateLastSaved, forKey: "minDateLastSaved")
                encoder.encode(minDateLastSavedForUser, forKey: "minDateLastSavedForUser")
                encoder.encode(maxPremiereDate, forKey: "maxPremiereDate")
                encoder.encode(hasOverview, forKey: "hasOverview")
                encoder.encode(hasImdbID, forKey: "hasImdbId")
                encoder.encode(hasTmdbID, forKey: "hasTmdbId")
                encoder.encode(hasTvdbID, forKey: "hasTvdbId")
                encoder.encode(excludeItemIDs, forKey: "excludeItemIds")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isRecursive, forKey: "recursive")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(sortOrder, forKey: "sortOrder")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(filters, forKey: "filters")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(mediaTypes, forKey: "mediaTypes")
                encoder.encode(imageTypes, forKey: "imageTypes")
                encoder.encode(sortBy, forKey: "sortBy")
                encoder.encode(isPlayed, forKey: "isPlayed")
                encoder.encode(genres, forKey: "genres")
                encoder.encode(officialRatings, forKey: "officialRatings")
                encoder.encode(tags, forKey: "tags")
                encoder.encode(years, forKey: "years")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(person, forKey: "person")
                encoder.encode(personIDs, forKey: "personIds")
                encoder.encode(personTypes, forKey: "personTypes")
                encoder.encode(studios, forKey: "studios")
                encoder.encode(artists, forKey: "artists")
                encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
                encoder.encode(artistIDs, forKey: "artistIds")
                encoder.encode(albumArtistIDs, forKey: "albumArtistIds")
                encoder.encode(contributingArtistIDs, forKey: "contributingArtistIds")
                encoder.encode(albums, forKey: "albums")
                encoder.encode(albumIDs, forKey: "albumIds")
                encoder.encode(ids, forKey: "ids")
                encoder.encode(videoTypes, forKey: "videoTypes")
                encoder.encode(minOfficialRating, forKey: "minOfficialRating")
                encoder.encode(isLocked, forKey: "isLocked")
                encoder.encode(isPlaceHolder, forKey: "isPlaceHolder")
                encoder.encode(hasOfficialRating, forKey: "hasOfficialRating")
                encoder.encode(isCollapseBoxSetItems, forKey: "collapseBoxSetItems")
                encoder.encode(minWidth, forKey: "minWidth")
                encoder.encode(minHeight, forKey: "minHeight")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(isIs3D, forKey: "is3D")
                encoder.encode(seriesStatus, forKey: "seriesStatus")
                encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
                encoder.encode(nameStartsWith, forKey: "nameStartsWith")
                encoder.encode(nameLessThan, forKey: "nameLessThan")
                encoder.encode(studioIDs, forKey: "studioIds")
                encoder.encode(genreIDs, forKey: "genreIds")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                encoder.encode(enableImages, forKey: "enableImages")
                return encoder.items
            }
        }
    }
}

extension Paths.Sessions.WithSessionID {
    public var message: Message {
        Message(path: path + "/Message")
    }

    public struct Message {
        /// Path: `/Sessions/{sessionId}/Message`
        public let path: String

        /// Issues a command to a client to display a message to the user.
        public func post(_ body: JellyfinAPI.MessageCommand) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Environment {
    public var networkShares: NetworkShares {
        NetworkShares(path: path + "/NetworkShares")
    }

    public struct NetworkShares {
        /// Path: `/Environment/NetworkShares`
        public let path: String

        /// Gets network paths.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<[JellyfinAPI.FileSystemEntryInfo]> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUserID.Items.WithItemID {
    public var rating: Rating {
        Rating(path: path + "/Rating")
    }

    public struct Rating {
        /// Path: `/Users/{userId}/Items/{itemId}/Rating`
        public let path: String

        /// Updates a user's rating for an item.
        public func post(isLikes: Bool? = nil) -> Request<JellyfinAPI.UserItemDataDto> {
            .post(path, query: makePostQuery(isLikes))
        }

        private func makePostQuery(_ isLikes: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isLikes, forKey: "likes")
            return encoder.items
        }

        /// Deletes a user's saved personal rating for an item.
        public var delete: Request<JellyfinAPI.UserItemDataDto> {
            .delete(path)
        }
    }
}

extension Paths.QuickConnect {
    public var authorize: Authorize {
        Authorize(path: path + "/Authorize")
    }

    public struct Authorize {
        /// Path: `/QuickConnect/Authorize`
        public let path: String

        /// Authorizes a pending quick connect request.
        public func post(code: String) -> Request<Data> {
            .post(path, query: [("code", code)])
        }
    }
}

extension Paths.Users {
    public var me: Me {
        Me(path: path + "/Me")
    }

    public struct Me {
        /// Path: `/Users/Me`
        public let path: String

        /// Gets the user based on auth token.
        public var get: Request<JellyfinAPI.UserDto> {
            .get(path)
        }
    }
}

extension Paths.Studios.WithName.Images {
    public func imageType(_ imageType: String) -> WithImageType {
        WithImageType(path: "\(path)/\(imageType)")
    }

    public struct WithImageType {
        /// Path: `/Studios/{name}/Images/{imageType}`
        public let path: String

        /// Get studio image by name.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }

        /// Get studio image by name.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Determines the output format of the image - original,gif,jpg,png.
            public var format: Format?
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.tag = tag
                self.format = format
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.isCropWhitespace = isCropWhitespace
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tag, forKey: "tag")
                encoder.encode(format, forKey: "format")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var items: Items {
        Items(path: "/Items")
    }

    public struct Items {
        /// Path: `/Items`
        public let path: String

        /// Gets items based on a query.
        public func get(parameters: GetParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The user id supplied as query parameter.
            public var userID: String?
            /// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
            public var maxOfficialRating: String?
            /// Optional filter by items with theme songs.
            public var hasThemeSong: Bool?
            /// Optional filter by items with theme videos.
            public var hasThemeVideo: Bool?
            /// Optional filter by items with subtitles.
            public var hasSubtitles: Bool?
            /// Optional filter by items with special features.
            public var hasSpecialFeature: Bool?
            /// Optional filter by items with trailers.
            public var hasTrailer: Bool?
            /// Optional. Return items that are siblings of a supplied item.
            public var adjacentTo: String?
            /// Optional filter by parent index number.
            public var parentIndexNumber: Int?
            /// Optional filter by items that have or do not have a parental rating.
            public var hasParentalRating: Bool?
            /// Optional filter by items that are HD or not.
            public var isHd: Bool?
            /// Optional filter by items that are 4K or not.
            public var isIs4K: Bool?
            /// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
            public var locationTypes: [JellyfinAPI.LocationType]?
            /// Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
            public var excludeLocationTypes: [JellyfinAPI.LocationType]?
            /// Optional filter by items that are missing episodes or not.
            public var isMissing: Bool?
            /// Optional filter by items that are unaired episodes or not.
            public var isUnaired: Bool?
            /// Optional filter by minimum community rating.
            public var minCommunityRating: Double?
            /// Optional filter by minimum critic rating.
            public var minCriticRating: Double?
            /// Optional. The minimum premiere date. Format = ISO.
            public var minPremiereDate: Date?
            /// Optional. The minimum last saved date. Format = ISO.
            public var minDateLastSaved: Date?
            /// Optional. The minimum last saved date for the current user. Format = ISO.
            public var minDateLastSavedForUser: Date?
            /// Optional. The maximum premiere date. Format = ISO.
            public var maxPremiereDate: Date?
            /// Optional filter by items that have an overview or not.
            public var hasOverview: Bool?
            /// Optional filter by items that have an imdb id or not.
            public var hasImdbID: Bool?
            /// Optional filter by items that have a tmdb id or not.
            public var hasTmdbID: Bool?
            /// Optional filter by items that have a tvdb id or not.
            public var hasTvdbID: Bool?
            /// Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
            public var excludeItemIDs: [String]?
            /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
            public var startIndex: Int?
            /// Optional. The maximum number of records to return.
            public var limit: Int?
            /// When searching within folders, this determines whether or not the search will be recursive. true/false.
            public var isRecursive: Bool?
            /// Optional. Filter based on a search term.
            public var searchTerm: String?
            /// Sort Order - Ascending,Descending.
            public var sortOrder: [JellyfinAPI.SortOrder]?
            /// Specify this to localize the search to a specific item or folder. Omit to use the root.
            public var parentID: String?
            /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
            public var fields: [JellyfinAPI.ItemFields]?
            /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
            public var excludeItemTypes: [String]?
            /// Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
            public var includeItemTypes: [String]?
            /// Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
            public var filters: [JellyfinAPI.ItemFilter]?
            /// Optional filter by items that are marked as favorite, or not.
            public var isFavorite: Bool?
            /// Optional filter by MediaType. Allows multiple, comma delimited.
            public var mediaTypes: [String]?
            /// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
            public var imageTypes: [JellyfinAPI.ImageType]?
            /// Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
            public var sortBy: [String]?
            /// Optional filter by items that are played, or not.
            public var isPlayed: Bool?
            /// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
            public var genres: [String]?
            /// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
            public var officialRatings: [String]?
            /// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
            public var tags: [String]?
            /// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
            public var years: [Int]?
            /// Optional, include user data.
            public var enableUserData: Bool?
            /// Optional, the max number of images to return, per image type.
            public var imageTypeLimit: Int?
            /// Optional. The image types to include in the output.
            public var enableImageTypes: [JellyfinAPI.ImageType]?
            /// Optional. If specified, results will be filtered to include only those containing the specified person.
            public var person: String?
            /// Optional. If specified, results will be filtered to include only those containing the specified person id.
            public var personIDs: [String]?
            /// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
            public var personTypes: [String]?
            /// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
            public var studios: [String]?
            /// Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
            public var artists: [String]?
            /// Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
            public var excludeArtistIDs: [String]?
            /// Optional. If specified, results will be filtered to include only those containing the specified artist id.
            public var artistIDs: [String]?
            /// Optional. If specified, results will be filtered to include only those containing the specified album artist id.
            public var albumArtistIDs: [String]?
            /// Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
            public var contributingArtistIDs: [String]?
            /// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
            public var albums: [String]?
            /// Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
            public var albumIDs: [String]?
            /// Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
            public var ids: [String]?
            /// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
            public var videoTypes: [JellyfinAPI.VideoType]?
            /// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
            public var minOfficialRating: String?
            /// Optional filter by items that are locked.
            public var isLocked: Bool?
            /// Optional filter by items that are placeholders.
            public var isPlaceHolder: Bool?
            /// Optional filter by items that have official ratings.
            public var hasOfficialRating: Bool?
            /// Whether or not to hide items behind their boxsets.
            public var isCollapseBoxSetItems: Bool?
            /// Optional. Filter by the minimum width of the item.
            public var minWidth: Int?
            /// Optional. Filter by the minimum height of the item.
            public var minHeight: Int?
            /// Optional. Filter by the maximum width of the item.
            public var maxWidth: Int?
            /// Optional. Filter by the maximum height of the item.
            public var maxHeight: Int?
            /// Optional filter by items that are 3D, or not.
            public var isIs3D: Bool?
            /// Optional filter by Series Status. Allows multiple, comma delimited.
            public var seriesStatus: [JellyfinAPI.SeriesStatus]?
            /// Optional filter by items whose name is sorted equally or greater than a given input string.
            public var nameStartsWithOrGreater: String?
            /// Optional filter by items whose name is sorted equally than a given input string.
            public var nameStartsWith: String?
            /// Optional filter by items whose name is equally or lesser than a given input string.
            public var nameLessThan: String?
            /// Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
            public var studioIDs: [String]?
            /// Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
            public var genreIDs: [String]?
            /// Optional. Enable the total record count.
            public var enableTotalRecordCount: Bool?
            /// Optional, include image information in output.
            public var enableImages: Bool?

            public init(userID: String? = nil, maxOfficialRating: String? = nil, hasThemeSong: Bool? = nil, hasThemeVideo: Bool? = nil, hasSubtitles: Bool? = nil, hasSpecialFeature: Bool? = nil, hasTrailer: Bool? = nil, adjacentTo: String? = nil, parentIndexNumber: Int? = nil, hasParentalRating: Bool? = nil, isHd: Bool? = nil, isIs4K: Bool? = nil, locationTypes: [JellyfinAPI.LocationType]? = nil, excludeLocationTypes: [JellyfinAPI.LocationType]? = nil, isMissing: Bool? = nil, isUnaired: Bool? = nil, minCommunityRating: Double? = nil, minCriticRating: Double? = nil, minPremiereDate: Date? = nil, minDateLastSaved: Date? = nil, minDateLastSavedForUser: Date? = nil, maxPremiereDate: Date? = nil, hasOverview: Bool? = nil, hasImdbID: Bool? = nil, hasTmdbID: Bool? = nil, hasTvdbID: Bool? = nil, excludeItemIDs: [String]? = nil, startIndex: Int? = nil, limit: Int? = nil, isRecursive: Bool? = nil, searchTerm: String? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, imageTypes: [JellyfinAPI.ImageType]? = nil, sortBy: [String]? = nil, isPlayed: Bool? = nil, genres: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, artists: [String]? = nil, excludeArtistIDs: [String]? = nil, artistIDs: [String]? = nil, albumArtistIDs: [String]? = nil, contributingArtistIDs: [String]? = nil, albums: [String]? = nil, albumIDs: [String]? = nil, ids: [String]? = nil, videoTypes: [JellyfinAPI.VideoType]? = nil, minOfficialRating: String? = nil, isLocked: Bool? = nil, isPlaceHolder: Bool? = nil, hasOfficialRating: Bool? = nil, isCollapseBoxSetItems: Bool? = nil, minWidth: Int? = nil, minHeight: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, isIs3D: Bool? = nil, seriesStatus: [JellyfinAPI.SeriesStatus]? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, studioIDs: [String]? = nil, genreIDs: [String]? = nil, enableTotalRecordCount: Bool? = nil, enableImages: Bool? = nil) {
                self.userID = userID
                self.maxOfficialRating = maxOfficialRating
                self.hasThemeSong = hasThemeSong
                self.hasThemeVideo = hasThemeVideo
                self.hasSubtitles = hasSubtitles
                self.hasSpecialFeature = hasSpecialFeature
                self.hasTrailer = hasTrailer
                self.adjacentTo = adjacentTo
                self.parentIndexNumber = parentIndexNumber
                self.hasParentalRating = hasParentalRating
                self.isHd = isHd
                self.isIs4K = isIs4K
                self.locationTypes = locationTypes
                self.excludeLocationTypes = excludeLocationTypes
                self.isMissing = isMissing
                self.isUnaired = isUnaired
                self.minCommunityRating = minCommunityRating
                self.minCriticRating = minCriticRating
                self.minPremiereDate = minPremiereDate
                self.minDateLastSaved = minDateLastSaved
                self.minDateLastSavedForUser = minDateLastSavedForUser
                self.maxPremiereDate = maxPremiereDate
                self.hasOverview = hasOverview
                self.hasImdbID = hasImdbID
                self.hasTmdbID = hasTmdbID
                self.hasTvdbID = hasTvdbID
                self.excludeItemIDs = excludeItemIDs
                self.startIndex = startIndex
                self.limit = limit
                self.isRecursive = isRecursive
                self.searchTerm = searchTerm
                self.sortOrder = sortOrder
                self.parentID = parentID
                self.fields = fields
                self.excludeItemTypes = excludeItemTypes
                self.includeItemTypes = includeItemTypes
                self.filters = filters
                self.isFavorite = isFavorite
                self.mediaTypes = mediaTypes
                self.imageTypes = imageTypes
                self.sortBy = sortBy
                self.isPlayed = isPlayed
                self.genres = genres
                self.officialRatings = officialRatings
                self.tags = tags
                self.years = years
                self.enableUserData = enableUserData
                self.imageTypeLimit = imageTypeLimit
                self.enableImageTypes = enableImageTypes
                self.person = person
                self.personIDs = personIDs
                self.personTypes = personTypes
                self.studios = studios
                self.artists = artists
                self.excludeArtistIDs = excludeArtistIDs
                self.artistIDs = artistIDs
                self.albumArtistIDs = albumArtistIDs
                self.contributingArtistIDs = contributingArtistIDs
                self.albums = albums
                self.albumIDs = albumIDs
                self.ids = ids
                self.videoTypes = videoTypes
                self.minOfficialRating = minOfficialRating
                self.isLocked = isLocked
                self.isPlaceHolder = isPlaceHolder
                self.hasOfficialRating = hasOfficialRating
                self.isCollapseBoxSetItems = isCollapseBoxSetItems
                self.minWidth = minWidth
                self.minHeight = minHeight
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.isIs3D = isIs3D
                self.seriesStatus = seriesStatus
                self.nameStartsWithOrGreater = nameStartsWithOrGreater
                self.nameStartsWith = nameStartsWith
                self.nameLessThan = nameLessThan
                self.studioIDs = studioIDs
                self.genreIDs = genreIDs
                self.enableTotalRecordCount = enableTotalRecordCount
                self.enableImages = enableImages
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userID, forKey: "userId")
                encoder.encode(maxOfficialRating, forKey: "maxOfficialRating")
                encoder.encode(hasThemeSong, forKey: "hasThemeSong")
                encoder.encode(hasThemeVideo, forKey: "hasThemeVideo")
                encoder.encode(hasSubtitles, forKey: "hasSubtitles")
                encoder.encode(hasSpecialFeature, forKey: "hasSpecialFeature")
                encoder.encode(hasTrailer, forKey: "hasTrailer")
                encoder.encode(adjacentTo, forKey: "adjacentTo")
                encoder.encode(parentIndexNumber, forKey: "parentIndexNumber")
                encoder.encode(hasParentalRating, forKey: "hasParentalRating")
                encoder.encode(isHd, forKey: "isHd")
                encoder.encode(isIs4K, forKey: "is4K")
                encoder.encode(locationTypes, forKey: "locationTypes")
                encoder.encode(excludeLocationTypes, forKey: "excludeLocationTypes")
                encoder.encode(isMissing, forKey: "isMissing")
                encoder.encode(isUnaired, forKey: "isUnaired")
                encoder.encode(minCommunityRating, forKey: "minCommunityRating")
                encoder.encode(minCriticRating, forKey: "minCriticRating")
                encoder.encode(minPremiereDate, forKey: "minPremiereDate")
                encoder.encode(minDateLastSaved, forKey: "minDateLastSaved")
                encoder.encode(minDateLastSavedForUser, forKey: "minDateLastSavedForUser")
                encoder.encode(maxPremiereDate, forKey: "maxPremiereDate")
                encoder.encode(hasOverview, forKey: "hasOverview")
                encoder.encode(hasImdbID, forKey: "hasImdbId")
                encoder.encode(hasTmdbID, forKey: "hasTmdbId")
                encoder.encode(hasTvdbID, forKey: "hasTvdbId")
                encoder.encode(excludeItemIDs, forKey: "excludeItemIds")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isRecursive, forKey: "recursive")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(sortOrder, forKey: "sortOrder")
                encoder.encode(parentID, forKey: "parentId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
                encoder.encode(includeItemTypes, forKey: "includeItemTypes")
                encoder.encode(filters, forKey: "filters")
                encoder.encode(isFavorite, forKey: "isFavorite")
                encoder.encode(mediaTypes, forKey: "mediaTypes")
                encoder.encode(imageTypes, forKey: "imageTypes")
                encoder.encode(sortBy, forKey: "sortBy")
                encoder.encode(isPlayed, forKey: "isPlayed")
                encoder.encode(genres, forKey: "genres")
                encoder.encode(officialRatings, forKey: "officialRatings")
                encoder.encode(tags, forKey: "tags")
                encoder.encode(years, forKey: "years")
                encoder.encode(enableUserData, forKey: "enableUserData")
                encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
                encoder.encode(enableImageTypes, forKey: "enableImageTypes")
                encoder.encode(person, forKey: "person")
                encoder.encode(personIDs, forKey: "personIds")
                encoder.encode(personTypes, forKey: "personTypes")
                encoder.encode(studios, forKey: "studios")
                encoder.encode(artists, forKey: "artists")
                encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
                encoder.encode(artistIDs, forKey: "artistIds")
                encoder.encode(albumArtistIDs, forKey: "albumArtistIds")
                encoder.encode(contributingArtistIDs, forKey: "contributingArtistIds")
                encoder.encode(albums, forKey: "albums")
                encoder.encode(albumIDs, forKey: "albumIds")
                encoder.encode(ids, forKey: "ids")
                encoder.encode(videoTypes, forKey: "videoTypes")
                encoder.encode(minOfficialRating, forKey: "minOfficialRating")
                encoder.encode(isLocked, forKey: "isLocked")
                encoder.encode(isPlaceHolder, forKey: "isPlaceHolder")
                encoder.encode(hasOfficialRating, forKey: "hasOfficialRating")
                encoder.encode(isCollapseBoxSetItems, forKey: "collapseBoxSetItems")
                encoder.encode(minWidth, forKey: "minWidth")
                encoder.encode(minHeight, forKey: "minHeight")
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(isIs3D, forKey: "is3D")
                encoder.encode(seriesStatus, forKey: "seriesStatus")
                encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
                encoder.encode(nameStartsWith, forKey: "nameStartsWith")
                encoder.encode(nameLessThan, forKey: "nameLessThan")
                encoder.encode(studioIDs, forKey: "studioIds")
                encoder.encode(genreIDs, forKey: "genreIds")
                encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
                encoder.encode(enableImages, forKey: "enableImages")
                return encoder.items
            }
        }

        /// Deletes items from the library and filesystem.
        public func delete(ids: [String]? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(ids))
        }

        private func makeDeleteQuery(_ ids: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ids, forKey: "ids")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var configuration: Configuration {
        Configuration(path: path + "/Configuration")
    }

    public struct Configuration {
        /// Path: `/Users/{userId}/Configuration`
        public let path: String

        /// Updates a user configuration.
        public func post(_ body: JellyfinAPI.UserConfiguration) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var playback: Playback {
        Playback(path: "/Playback")
    }

    public struct Playback {
        /// Path: `/Playback`
        public let path: String
    }
}

extension Paths.Playback {
    public var bitrateTest: BitrateTest {
        BitrateTest(path: path + "/BitrateTest")
    }

    public struct BitrateTest {
        /// Path: `/Playback/BitrateTest`
        public let path: String

        /// Tests the network with a request with the size of the bitrate.
        public func get(size: Int? = nil) -> Request<Data> {
            .get(path, query: makeGetQuery(size))
        }

        private func makeGetQuery(_ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(size, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.SyncPlay {
    public var ping: Ping {
        Ping(path: path + "/Ping")
    }

    public struct Ping {
        /// Path: `/SyncPlay/Ping`
        public let path: String

        /// Update session ping.
        public func post(_ body: JellyfinAPI.PingRequestDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Plugins.WithPluginID.WithVersion {
    public var disable: Disable {
        Disable(path: path + "/Disable")
    }

    public struct Disable {
        /// Path: `/Plugins/{pluginId}/{version}/Disable`
        public let path: String

        /// Disable a plugin.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Notifications {
    public var admin: Admin {
        Admin(path: path + "/Admin")
    }

    public struct Admin {
        /// Path: `/Notifications/Admin`
        public let path: String

        /// Sends a notification to all admins.
        public func post(_ body: JellyfinAPI.AdminNotificationDto) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Items.RemoteSearch {
    public var person: Person {
        Person(path: path + "/Person")
    }

    public struct Person {
        /// Path: `/Items/RemoteSearch/Person`
        public let path: String

        /// Get person remote search.
        public func post(_ body: JellyfinAPI.PersonLookupInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.LiveTv.Channels {
    public func channelID(_ channelID: String) -> WithChannelID {
        WithChannelID(path: "\(path)/\(channelID)")
    }

    public struct WithChannelID {
        /// Path: `/LiveTv/Channels/{channelId}`
        public let path: String

        /// Gets a live tv channel.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.SyncPlay {
    public var list: List {
        List(path: path + "/List")
    }

    public struct List {
        /// Path: `/SyncPlay/List`
        public let path: String

        /// Gets all SyncPlay groups.
        public var get: Request<[JellyfinAPI.GroupInfoDto]> {
            .get(path)
        }
    }
}

extension Paths.MusicGenres {
    public func genreName(_ genreName: String) -> WithGenreName {
        WithGenreName(path: "\(path)/\(genreName)")
    }

    public struct WithGenreName {
        /// Path: `/MusicGenres/{genreName}`
        public let path: String

        /// Gets a music genre, by name.
        public func get(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
            .get(path, query: makeGetQuery(userID))
        }

        private func makeGetQuery(_ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            return encoder.items
        }
    }
}

extension Paths.Items.WithItemID.Images {
    public func imageType(_ imageType: String) -> WithImageType {
        WithImageType(path: "\(path)/\(imageType)")
    }

    public struct WithImageType {
        /// Path: `/Items/{itemId}/Images/{imageType}`
        public let path: String

        /// Gets the item's image.
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
            public var format: Format?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(maxWidth: Int? = nil, maxHeight: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, tag: String? = nil, isCropWhitespace: Bool? = nil, format: Format? = nil, isAddPlayedIndicator: Bool? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.tag = tag
                self.isCropWhitespace = isCropWhitespace
                self.format = format
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(format, forKey: "format")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }

        /// Set item image.
        public func post(_ body: Data? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Delete an item's image.
        public func delete(imageIndex: Int? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(imageIndex))
        }

        private func makeDeleteQuery(_ imageIndex: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }

        /// Gets the item's image.
        public func head(parameters: HeadParameters? = nil) -> Request<Data> {
            .head(path, query: parameters?.asQuery)
        }

        public struct HeadParameters {
            /// The maximum image width to return.
            public var maxWidth: Int?
            /// The maximum image height to return.
            public var maxHeight: Int?
            /// The fixed image width to return.
            public var width: Int?
            /// The fixed image height to return.
            public var height: Int?
            /// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
            public var quality: Int?
            /// Width of box to fill.
            public var fillWidth: Int?
            /// Height of box to fill.
            public var fillHeight: Int?
            /// Optional. Supply the cache tag from the item object to receive strong caching headers.
            public var tag: String?
            /// Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
            public var isCropWhitespace: Bool?
            /// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
            public var format: Format?
            /// Optional. Add a played indicator.
            public var isAddPlayedIndicator: Bool?
            /// Optional. Percent to render for the percent played overlay.
            public var percentPlayed: Double?
            /// Optional. Unplayed count overlay to render.
            public var unplayedCount: Int?
            /// Optional. Blur image.
            public var blur: Int?
            /// Optional. Apply a background color for transparent images.
            public var backgroundColor: String?
            /// Optional. Apply a foreground layer on top of the image.
            public var foregroundLayer: String?
            /// Image index.
            public var imageIndex: Int?

            public typealias Format = JellyfinAPI.ImageFormat

            public init(maxWidth: Int? = nil, maxHeight: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, tag: String? = nil, isCropWhitespace: Bool? = nil, format: Format? = nil, isAddPlayedIndicator: Bool? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
                self.maxWidth = maxWidth
                self.maxHeight = maxHeight
                self.width = width
                self.height = height
                self.quality = quality
                self.fillWidth = fillWidth
                self.fillHeight = fillHeight
                self.tag = tag
                self.isCropWhitespace = isCropWhitespace
                self.format = format
                self.isAddPlayedIndicator = isAddPlayedIndicator
                self.percentPlayed = percentPlayed
                self.unplayedCount = unplayedCount
                self.blur = blur
                self.backgroundColor = backgroundColor
                self.foregroundLayer = foregroundLayer
                self.imageIndex = imageIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(maxWidth, forKey: "maxWidth")
                encoder.encode(maxHeight, forKey: "maxHeight")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(quality, forKey: "quality")
                encoder.encode(fillWidth, forKey: "fillWidth")
                encoder.encode(fillHeight, forKey: "fillHeight")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
                encoder.encode(format, forKey: "format")
                encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
                encoder.encode(percentPlayed, forKey: "percentPlayed")
                encoder.encode(unplayedCount, forKey: "unplayedCount")
                encoder.encode(blur, forKey: "blur")
                encoder.encode(backgroundColor, forKey: "backgroundColor")
                encoder.encode(foregroundLayer, forKey: "foregroundLayer")
                encoder.encode(imageIndex, forKey: "imageIndex")
                return encoder.items
            }
        }
    }
}

public enum Paths {}
