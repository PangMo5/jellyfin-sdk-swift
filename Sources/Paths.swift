// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    static public func processMediaReceiverRegistrarControlRequest(serverID: String) -> Request<String> {
        .post("/Dlna/\(serverID)/MediaReceiverRegistrar/Control")
    }
}

extension Paths {
    static public var getLocalizationOptions: Request<[JellyfinAPI.LocalizationOption]> {
        .get("/Localization/Options")
    }
}

extension Paths {
    static public func getSimilarItems(itemID: String, parameters: GetSimilarItemsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Items/\(itemID)/Similar", query: parameters?.asQuery)
    }

    public struct GetSimilarItemsParameters {
        public var excludeArtistIDs: [String]?
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?

        public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
            self.excludeArtistIDs = excludeArtistIDs
            self.userID = userID
            self.limit = limit
            self.fields = fields
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getRecordingGroup(groupID: String) -> Request<Void> {
        .get("/LiveTv/Recordings/Groups/\(groupID)")
    }
}

extension Paths {
    static public func getAncestors(itemID: String, userID: String? = nil) -> Request<[JellyfinAPI.BaseItemDto]> {
        .get("/Items/\(itemID)/Ancestors", query: makeGetAncestorsQuery(userID))
    }

    private static func makeGetAncestorsQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func getPersonRemoteSearchResults(_ body: JellyfinAPI.PersonLookupInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
        .post("/Items/RemoteSearch/Person", body: body)
    }
}

extension Paths {
    static public var getProfileInfos: Request<[JellyfinAPI.DeviceProfileInfo]> {
        .get("/Dlna/ProfileInfos")
    }
}

extension Paths {
    static public func getHlsVideoSegmentLegacy(itemID: String, playlistID: String, segmentID: String, segmentContainer: String) -> Request<Data> {
        .get("/Videos/\(itemID)/hls/\(playlistID)/\(segmentID).\(segmentContainer)")
    }
}

extension Paths {
    static public func getRecordingGroups(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/LiveTv/Recordings/Groups", query: makeGetRecordingGroupsQuery(userID))
    }

    private static func makeGetRecordingGroupsQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public var getTunerHostTypes: Request<[JellyfinAPI.NameIDPair]> {
        .get("/LiveTv/TunerHosts/Types")
    }
}

extension Paths {
    static public func updateUserItemRating(userID: String, itemID: String, isLikes: Bool? = nil) -> Request<JellyfinAPI.UserItemDataDto> {
        .post("/Users/\(userID)/Items/\(itemID)/Rating", query: makeUpdateUserItemRatingQuery(isLikes))
    }

    private static func makeUpdateUserItemRatingQuery(_ isLikes: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isLikes, forKey: "likes")
        return encoder.items
    }
}

extension Paths {
    static public func deleteUserItemRating(userID: String, itemID: String) -> Request<JellyfinAPI.UserItemDataDto> {
        .delete("/Users/\(userID)/Items/\(itemID)/Rating")
    }
}

extension Paths {
    static public func getTasks(isHidden: Bool? = nil, isEnabled: Bool? = nil) -> Request<[JellyfinAPI.TaskInfo]> {
        .get("/ScheduledTasks", query: makeGetTasksQuery(isHidden, isEnabled))
    }

    private static func makeGetTasksQuery(_ isHidden: Bool?, _ isEnabled: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isHidden, forKey: "isHidden")
        encoder.encode(isEnabled, forKey: "isEnabled")
        return encoder.items
    }
}

extension Paths {
    static public var getNetworkShares: Request<[JellyfinAPI.FileSystemEntryInfo]> {
        .get("/Environment/NetworkShares")
    }
}

extension Paths {
    static public func getProgram(programID: String, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/LiveTv/Programs/\(programID)", query: makeGetProgramQuery(userID))
    }

    private static func makeGetProgramQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func postUpdatedSeries(tvdbID: String? = nil) -> Request<Void> {
        .post("/Library/Series/Updated", query: makePostUpdatedSeriesQuery(tvdbID))
    }

    private static func makePostUpdatedSeriesQuery(_ tvdbID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(tvdbID, forKey: "tvdbId")
        return encoder.items
    }
}

extension Paths {
    static public func getLibraryOptionsInfo(libraryContentType: String? = nil, isNewLibrary: Bool? = nil) -> Request<JellyfinAPI.LibraryOptionsResultDto> {
        .get("/Libraries/AvailableOptions", query: makeGetLibraryOptionsInfoQuery(libraryContentType, isNewLibrary))
    }

    private static func makeGetLibraryOptionsInfoQuery(_ libraryContentType: String?, _ isNewLibrary: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(libraryContentType, forKey: "libraryContentType")
        encoder.encode(isNewLibrary, forKey: "isNewLibrary")
        return encoder.items
    }
}

extension Paths {
    static public func discvoverTuners(isNewDevicesOnly: Bool? = nil) -> Request<[JellyfinAPI.TunerHostInfo]> {
        .get("/LiveTv/Tuners/Discvover", query: makeDiscvoverTunersQuery(isNewDevicesOnly))
    }

    private static func makeDiscvoverTunersQuery(_ isNewDevicesOnly: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isNewDevicesOnly, forKey: "newDevicesOnly")
        return encoder.items
    }
}

extension Paths {
    static public func updateUserEasyPassword(userID: String, _ body: JellyfinAPI.UpdateUserEasyPassword) -> Request<Void> {
        .post("/Users/\(userID)/EasyPassword", body: body)
    }
}

extension Paths {
    static public func getLiveRecordingFile(recordingID: String) -> Request<Data> {
        .get("/LiveTv/LiveRecordings/\(recordingID)/stream")
    }
}

extension Paths {
    static public func getIntros(userID: String, itemID: String) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Users/\(userID)/Items/\(itemID)/Intros")
    }
}

extension Paths {
    static public var getDefaultMetadataOptions: Request<JellyfinAPI.MetadataOptions> {
        .get("/System/Configuration/MetadataOptions/Default")
    }
}

extension Paths {
    static public func getMusicVideoRemoteSearchResults(_ body: JellyfinAPI.MusicVideoInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
        .post("/Items/RemoteSearch/MusicVideo", body: body)
    }
}

extension Paths {
    static public func reportPlaybackProgress(_ body: JellyfinAPI.PlaybackProgressInfo? = nil) -> Request<Void> {
        .post("/Sessions/Playing/Progress", body: body)
    }
}

extension Paths {
    static public var getNotificationTypes: Request<[JellyfinAPI.NotificationTypeInfo]> {
        .get("/Notifications/Types")
    }
}

extension Paths {
    static public func getBoxSetRemoteSearchResults(_ body: JellyfinAPI.BoxSetInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
        .post("/Items/RemoteSearch/BoxSet", body: body)
    }
}

extension Paths {
    static public func getRemoteSubtitles(id: String) -> Request<String> {
        .get("/Providers/Subtitles/Subtitles/\(id)")
    }
}

extension Paths {
    static public func getMediaReceiverRegistrar2(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/MediaReceiverRegistrar/MediaReceiverRegistrar")
    }
}

extension Paths {
    static public func getSubtitleWithTicks(routeItemID: String, routeMediaSourceID: String, routeIndex: Int, routeStartPositionTicks: Int, routeFormat: String, parameters: GetSubtitleWithTicksParameters? = nil) -> Request<String> {
        .get("/Videos/\(routeItemID)/\(routeMediaSourceID)/Subtitles/\(routeIndex)/\(routeStartPositionTicks)/Stream.\(routeFormat)", query: parameters?.asQuery)
    }

    public struct GetSubtitleWithTicksParameters {
        public var itemID: String?
        public var mediaSourceID: String?
        public var index: Int?
        public var startPositionTicks: Int?
        public var format: String?
        public var endPositionTicks: Int?
        public var isCopyTimestamps: Bool?
        public var isAddVttTimeMap: Bool?

        public init(itemID: String? = nil, mediaSourceID: String? = nil, index: Int? = nil, startPositionTicks: Int? = nil, format: String? = nil, endPositionTicks: Int? = nil, isCopyTimestamps: Bool? = nil, isAddVttTimeMap: Bool? = nil) {
            self.itemID = itemID
            self.mediaSourceID = mediaSourceID
            self.index = index
            self.startPositionTicks = startPositionTicks
            self.format = format
            self.endPositionTicks = endPositionTicks
            self.isCopyTimestamps = isCopyTimestamps
            self.isAddVttTimeMap = isAddVttTimeMap
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(itemID, forKey: "itemId")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(index, forKey: "index")
            encoder.encode(startPositionTicks, forKey: "startPositionTicks")
            encoder.encode(format, forKey: "format")
            encoder.encode(endPositionTicks, forKey: "endPositionTicks")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(isAddVttTimeMap, forKey: "addVttTimeMap")
            return encoder.items
        }
    }
}

extension Paths {
    static public var getPackages: Request<[JellyfinAPI.PackageInfo]> {
        .get("/Packages")
    }
}

extension Paths {
    static public func sendMessageCommand(sessionID: String, _ body: JellyfinAPI.MessageCommand) -> Request<Void> {
        .post("/Sessions/\(sessionID)/Message", body: body)
    }
}

extension Paths {
    static public func updatePluginSecurityInfo(_ body: JellyfinAPI.PluginSecurityInfo) -> Request<Void> {
        .post("/Plugins/SecurityInfo", body: body)
    }
}

extension Paths {
    static public var getParentalRatings: Request<[JellyfinAPI.ParentalRating]> {
        .get("/Localization/ParentalRatings")
    }
}

extension Paths {
    static public func getQueryFiltersLegacy(parameters: GetQueryFiltersLegacyParameters? = nil) -> Request<JellyfinAPI.QueryFiltersLegacy> {
        .get("/Items/Filters", query: parameters?.asQuery)
    }

    public struct GetQueryFiltersLegacyParameters {
        public var userID: String?
        public var parentID: String?
        public var includeItemTypes: [String]?
        public var mediaTypes: [String]?

        public init(userID: String? = nil, parentID: String? = nil, includeItemTypes: [String]? = nil, mediaTypes: [String]? = nil) {
            self.userID = userID
            self.parentID = parentID
            self.includeItemTypes = includeItemTypes
            self.mediaTypes = mediaTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(mediaTypes, forKey: "mediaTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func processConnectionManagerControlRequest(serverID: String) -> Request<String> {
        .post("/Dlna/\(serverID)/ConnectionManager/Control")
    }
}

extension Paths {
    static public func getThemeSongs(itemID: String, userID: String? = nil, isInheritFromParent: Bool? = nil) -> Request<JellyfinAPI.ThemeMediaResult> {
        .get("/Items/\(itemID)/ThemeSongs", query: makeGetThemeSongsQuery(userID, isInheritFromParent))
    }

    private static func makeGetThemeSongsQuery(_ userID: String?, _ isInheritFromParent: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        encoder.encode(isInheritFromParent, forKey: "inheritFromParent")
        return encoder.items
    }
}

extension Paths {
    static public func getMasterHlsAudioPlaylist(itemID: String, parameters: GetMasterHlsAudioPlaylistParameters) -> Request<Data> {
        .get("/Audio/\(itemID)/master.m3u8", query: parameters.asQuery)
    }

    public struct GetMasterHlsAudioPlaylistParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var maxStreamingBitrate: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?
        public var enableAdaptiveBitrateStreaming: Bool?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, enableAdaptiveBitrateStreaming: Bool? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.maxStreamingBitrate = maxStreamingBitrate
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
            self.enableAdaptiveBitrateStreaming = enableAdaptiveBitrateStreaming
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            encoder.encode(enableAdaptiveBitrateStreaming, forKey: "enableAdaptiveBitrateStreaming")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headMasterHlsAudioPlaylist(itemID: String, parameters: HeadMasterHlsAudioPlaylistParameters) -> Request<Data> {
        .head("/Audio/\(itemID)/master.m3u8", query: parameters.asQuery)
    }

    public struct HeadMasterHlsAudioPlaylistParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var maxStreamingBitrate: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?
        public var enableAdaptiveBitrateStreaming: Bool?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, enableAdaptiveBitrateStreaming: Bool? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.maxStreamingBitrate = maxStreamingBitrate
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
            self.enableAdaptiveBitrateStreaming = enableAdaptiveBitrateStreaming
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            encoder.encode(enableAdaptiveBitrateStreaming, forKey: "enableAdaptiveBitrateStreaming")
            return encoder.items
        }
    }
}

extension Paths {
    static public func syncPlayNextItem(_ body: JellyfinAPI.NextItemRequestDto) -> Request<Void> {
        .post("/SyncPlay/NextItem", body: body)
    }
}

extension Paths {
    static public func getBitrateTestBytes(size: Int? = nil) -> Request<Data> {
        .get("/Playback/BitrateTest", query: makeGetBitrateTestBytesQuery(size))
    }

    private static func makeGetBitrateTestBytesQuery(_ size: Int?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(size, forKey: "size")
        return encoder.items
    }
}

extension Paths {
    static public var getStartupConfiguration: Request<JellyfinAPI.StartupConfigurationDto> {
        .get("/Startup/Configuration")
    }
}

extension Paths {
    static public func updateInitialConfiguration(_ body: JellyfinAPI.StartupConfigurationDto) -> Request<Void> {
        .post("/Startup/Configuration", body: body)
    }
}

extension Paths {
    static public func postCapabilities(parameters: PostCapabilitiesParameters? = nil) -> Request<Void> {
        .post("/Sessions/Capabilities", query: parameters?.asQuery)
    }

    public struct PostCapabilitiesParameters {
        public var id: String?
        public var playableMediaTypes: [String]?
        public var supportedCommands: [JellyfinAPI.GeneralCommandType]?
        public var isSupportsMediaControl: Bool?
        public var isSupportsSync: Bool?
        public var isSupportsPersistentIdentifier: Bool?

        public init(id: String? = nil, playableMediaTypes: [String]? = nil, supportedCommands: [JellyfinAPI.GeneralCommandType]? = nil, isSupportsMediaControl: Bool? = nil, isSupportsSync: Bool? = nil, isSupportsPersistentIdentifier: Bool? = nil) {
            self.id = id
            self.playableMediaTypes = playableMediaTypes
            self.supportedCommands = supportedCommands
            self.isSupportsMediaControl = isSupportsMediaControl
            self.isSupportsSync = isSupportsSync
            self.isSupportsPersistentIdentifier = isSupportsPersistentIdentifier
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            encoder.encode(playableMediaTypes, forKey: "playableMediaTypes")
            encoder.encode(supportedCommands, forKey: "supportedCommands")
            encoder.encode(isSupportsMediaControl, forKey: "supportsMediaControl")
            encoder.encode(isSupportsSync, forKey: "supportsSync")
            encoder.encode(isSupportsPersistentIdentifier, forKey: "supportsPersistentIdentifier")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getItemImageByIndex(itemID: String, imageType: String, imageIndex: Int, parameters: GetItemImageByIndexParameters? = nil) -> Request<Data> {
        .get("/Items/\(itemID)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct GetItemImageByIndexParameters {
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var tag: String?
        public var isCropWhitespace: Bool?
        public var format: Format?
        public var isAddPlayedIndicator: Bool?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(maxWidth: Int? = nil, maxHeight: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, tag: String? = nil, isCropWhitespace: Bool? = nil, format: Format? = nil, isAddPlayedIndicator: Bool? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.tag = tag
            self.isCropWhitespace = isCropWhitespace
            self.format = format
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(format, forKey: "format")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func setItemImageByIndex(itemID: String, imageType: String, imageIndex: Int, _ body: Data? = nil) -> Request<Void> {
        .post("/Items/\(itemID)/Images/\(imageType)/\(imageIndex)", body: body)
    }
}

extension Paths {
    static public func deleteItemImageByIndex(itemID: String, imageType: String, imageIndex: Int) -> Request<Void> {
        .delete("/Items/\(itemID)/Images/\(imageType)/\(imageIndex)")
    }
}

extension Paths {
    static public func headItemImageByIndex(itemID: String, imageType: String, imageIndex: Int, parameters: HeadItemImageByIndexParameters? = nil) -> Request<Data> {
        .head("/Items/\(itemID)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct HeadItemImageByIndexParameters {
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var tag: String?
        public var isCropWhitespace: Bool?
        public var format: Format?
        public var isAddPlayedIndicator: Bool?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(maxWidth: Int? = nil, maxHeight: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, tag: String? = nil, isCropWhitespace: Bool? = nil, format: Format? = nil, isAddPlayedIndicator: Bool? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.tag = tag
            self.isCropWhitespace = isCropWhitespace
            self.format = format
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(format, forKey: "format")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getSimilarArtists(itemID: String, parameters: GetSimilarArtistsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Artists/\(itemID)/Similar", query: parameters?.asQuery)
    }

    public struct GetSimilarArtistsParameters {
        public var excludeArtistIDs: [String]?
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?

        public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
            self.excludeArtistIDs = excludeArtistIDs
            self.userID = userID
            self.limit = limit
            self.fields = fields
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getItemCounts(userID: String? = nil, isFavorite: Bool? = nil) -> Request<JellyfinAPI.ItemCounts> {
        .get("/Items/Counts", query: makeGetItemCountsQuery(userID, isFavorite))
    }

    private static func makeGetItemCountsQuery(_ userID: String?, _ isFavorite: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        encoder.encode(isFavorite, forKey: "isFavorite")
        return encoder.items
    }
}

extension Paths {
    static public func syncPlayPreviousItem(_ body: JellyfinAPI.PreviousItemRequestDto) -> Request<Void> {
        .post("/SyncPlay/PreviousItem", body: body)
    }
}

extension Paths {
    static public var initiate: Request<JellyfinAPI.QuickConnectResult> {
        .get("/QuickConnect/Initiate")
    }
}

extension Paths {
    static public var syncPlayLeaveGroup: Request<Void> {
        .post("/SyncPlay/Leave")
    }
}

extension Paths {
    static public func getRecordingsSeries(parameters: GetRecordingsSeriesParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/LiveTv/Recordings/Series", query: parameters?.asQuery)
    }

    public struct GetRecordingsSeriesParameters {
        public var channelID: String?
        public var userID: String?
        public var groupID: String?
        public var startIndex: Int?
        public var limit: Int?
        public var status: Status?
        public var isInProgress: Bool?
        public var seriesTimerID: String?
        public var enableImages: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableUserData: Bool?
        public var enableTotalRecordCount: Bool?

        public typealias Status = JellyfinAPI.RecordingStatus

        public init(channelID: String? = nil, userID: String? = nil, groupID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, status: Status? = nil, isInProgress: Bool? = nil, seriesTimerID: String? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableUserData: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
            self.channelID = channelID
            self.userID = userID
            self.groupID = groupID
            self.startIndex = startIndex
            self.limit = limit
            self.status = status
            self.isInProgress = isInProgress
            self.seriesTimerID = seriesTimerID
            self.enableImages = enableImages
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.fields = fields
            self.enableUserData = enableUserData
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(channelID, forKey: "channelId")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(groupID, forKey: "groupId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(status, forKey: "status")
            encoder.encode(isInProgress, forKey: "isInProgress")
            encoder.encode(seriesTimerID, forKey: "seriesTimerId")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func addUserToSession(sessionID: String, userID: String) -> Request<Void> {
        .post("/Sessions/\(sessionID)/User/\(userID)")
    }
}

extension Paths {
    static public func removeUserFromSession(sessionID: String, userID: String) -> Request<Void> {
        .delete("/Sessions/\(sessionID)/User/\(userID)")
    }
}

extension Paths {
    static public func getMusicGenreImageByIndex(name: String, imageType: String, imageIndex: Int, parameters: GetMusicGenreImageByIndexParameters? = nil) -> Request<Data> {
        .get("/MusicGenres/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct GetMusicGenreImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headMusicGenreImageByIndex(name: String, imageType: String, imageIndex: Int, parameters: HeadMusicGenreImageByIndexParameters? = nil) -> Request<Data> {
        .head("/MusicGenres/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct HeadMusicGenreImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getRecordingFolders(userID: String? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/LiveTv/Recordings/Folders", query: makeGetRecordingFoldersQuery(userID))
    }

    private static func makeGetRecordingFoldersQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func getDirectoryContents(parameters: GetDirectoryContentsParameters) -> Request<[JellyfinAPI.FileSystemEntryInfo]> {
        .get("/Environment/DirectoryContents", query: parameters.asQuery)
    }

    public struct GetDirectoryContentsParameters {
        public var path: String
        public var isIncludeFiles: Bool?
        public var isIncludeDirectories: Bool?

        public init(path: String, isIncludeFiles: Bool? = nil, isIncludeDirectories: Bool? = nil) {
            self.path = path
            self.isIncludeFiles = isIncludeFiles
            self.isIncludeDirectories = isIncludeDirectories
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(path, forKey: "path")
            encoder.encode(isIncludeFiles, forKey: "includeFiles")
            encoder.encode(isIncludeDirectories, forKey: "includeDirectories")
            return encoder.items
        }
    }
}

extension Paths {
    static public func postFullCapabilities(id: String? = nil, _ body: JellyfinAPI.ClientCapabilitiesDto) -> Request<Void> {
        .post("/Sessions/Capabilities/Full", query: makePostFullCapabilitiesQuery(id), body: body)
    }

    private static func makePostFullCapabilitiesQuery(_ id: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(id, forKey: "id")
        return encoder.items
    }
}

extension Paths {
    static public func connect(secret: String) -> Request<JellyfinAPI.QuickConnectResult> {
        .get("/QuickConnect/Connect", query: [("secret", secret)])
    }
}

extension Paths {
    static public func searchRemoteSubtitles(itemID: String, language: String, isPerfectMatch: Bool? = nil) -> Request<[JellyfinAPI.RemoteSubtitleInfo]> {
        .get("/Items/\(itemID)/RemoteSearch/Subtitles/\(language)", query: makeSearchRemoteSubtitlesQuery(isPerfectMatch))
    }

    private static func makeSearchRemoteSubtitlesQuery(_ isPerfectMatch: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isPerfectMatch, forKey: "isPerfectMatch")
        return encoder.items
    }
}

extension Paths {
    static public func getInstantMixFromMusicGenreById2(parameters: GetInstantMixFromMusicGenreById2Parameters) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/MusicGenres/InstantMix", query: parameters.asQuery)
    }

    public struct GetInstantMixFromMusicGenreById2Parameters {
        public var id: String
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(id: String, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.id = id
            self.userID = userID
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getPluginManifest(pluginID: String) -> Request<Void> {
        .post("/Plugins/\(pluginID)/Manifest")
    }
}

extension Paths {
    static public func getItemImageInfos(itemID: String) -> Request<[JellyfinAPI.ImageInfo]> {
        .get("/Items/\(itemID)/Images")
    }
}

extension Paths {
    static public func startTask(taskID: String) -> Request<Void> {
        .post("/ScheduledTasks/Running/\(taskID)")
    }
}

extension Paths {
    static public func stopTask(taskID: String) -> Request<Void> {
        .delete("/ScheduledTasks/Running/\(taskID)")
    }
}

extension Paths {
    static public func post(itemID: String, parameters: PostParameters? = nil) -> Request<Void> {
        .post("/Items/\(itemID)/Refresh", query: parameters?.asQuery)
    }

    public struct PostParameters {
        public var metadataRefreshMode: MetadataRefreshMode?
        public var imageRefreshMode: ImageRefreshMode?
        public var isReplaceAllMetadata: Bool?
        public var isReplaceAllImages: Bool?

        public typealias MetadataRefreshMode = JellyfinAPI.MetadataRefreshMode

        public typealias ImageRefreshMode = JellyfinAPI.MetadataRefreshMode

        public init(metadataRefreshMode: MetadataRefreshMode? = nil, imageRefreshMode: ImageRefreshMode? = nil, isReplaceAllMetadata: Bool? = nil, isReplaceAllImages: Bool? = nil) {
            self.metadataRefreshMode = metadataRefreshMode
            self.imageRefreshMode = imageRefreshMode
            self.isReplaceAllMetadata = isReplaceAllMetadata
            self.isReplaceAllImages = isReplaceAllImages
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(metadataRefreshMode, forKey: "metadataRefreshMode")
            encoder.encode(imageRefreshMode, forKey: "imageRefreshMode")
            encoder.encode(isReplaceAllMetadata, forKey: "replaceAllMetadata")
            encoder.encode(isReplaceAllImages, forKey: "replaceAllImages")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getItem(userID: String, itemID: String) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/Users/\(userID)/Items/\(itemID)")
    }
}

extension Paths {
    static public func getSeasons(seriesID: String, parameters: GetSeasonsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Shows/\(seriesID)/Seasons", query: parameters?.asQuery)
    }

    public struct GetSeasonsParameters {
        public var userID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var isSpecialSeason: Bool?
        public var isMissing: Bool?
        public var adjacentTo: String?
        public var enableImages: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var enableUserData: Bool?

        public init(userID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, isSpecialSeason: Bool? = nil, isMissing: Bool? = nil, adjacentTo: String? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil) {
            self.userID = userID
            self.fields = fields
            self.isSpecialSeason = isSpecialSeason
            self.isMissing = isMissing
            self.adjacentTo = adjacentTo
            self.enableImages = enableImages
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.enableUserData = enableUserData
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(isSpecialSeason, forKey: "isSpecialSeason")
            encoder.encode(isMissing, forKey: "isMissing")
            encoder.encode(adjacentTo, forKey: "adjacentTo")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(enableUserData, forKey: "enableUserData")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getHlsVideoSegment(itemID: String, playlistID: String, segmentID: Int, container: String, parameters: GetHlsVideoSegmentParameters? = nil) -> Request<Data> {
        .get("/Videos/\(itemID)/hls1/\(playlistID)/\(segmentID).\(container)", query: parameters?.asQuery)
    }

    public struct GetHlsVideoSegmentParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public var getDefaultListingProvider: Request<JellyfinAPI.ListingsProviderInfo> {
        .get("/LiveTv/ListingProviders/Default")
    }
}

extension Paths {
    static public func getGenre(genreName: String, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/Genres/\(genreName)", query: makeGetGenreQuery(userID))
    }

    private static func makeGetGenreQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public var getBrandingOptions: Request<JellyfinAPI.BrandingOptions> {
        .get("/Branding/Configuration")
    }
}

extension Paths {
    static public var completeWizard: Request<Void> {
        .post("/Startup/Complete")
    }
}

extension Paths {
    static public func getParentPath(path: String) -> Request<String> {
        .get("/Environment/ParentPath", query: [("path", path)])
    }
}

extension Paths {
    static public func getSuggestions(userID: String, parameters: GetSuggestionsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Users/\(userID)/Suggestions", query: parameters?.asQuery)
    }

    public struct GetSuggestionsParameters {
        public var mediaType: [String]?
        public var type: [String]?
        public var startIndex: Int?
        public var limit: Int?
        public var enableTotalRecordCount: Bool?

        public init(mediaType: [String]? = nil, type: [String]? = nil, startIndex: Int? = nil, limit: Int? = nil, enableTotalRecordCount: Bool? = nil) {
            self.mediaType = mediaType
            self.type = type
            self.startIndex = startIndex
            self.limit = limit
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(mediaType, forKey: "mediaType")
            encoder.encode(type, forKey: "type")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func uninstallPluginByVersion(pluginID: String, version: String) -> Request<Void> {
        .delete("/Plugins/\(pluginID)/\(version)")
    }
}

extension Paths {
    static public func getMusicGenre(genreName: String, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/MusicGenres/\(genreName)", query: makeGetMusicGenreQuery(userID))
    }

    private static func makeGetMusicGenreQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public var getCurrentUser: Request<JellyfinAPI.UserDto> {
        .get("/Users/Me")
    }
}

extension Paths {
    static public func getTimer(timerID: String) -> Request<JellyfinAPI.TimerInfoDto> {
        .get("/LiveTv/Timers/\(timerID)")
    }
}

extension Paths {
    static public func updateTimer(timerID: String, _ body: JellyfinAPI.TimerInfoDto? = nil) -> Request<Void> {
        .post("/LiveTv/Timers/\(timerID)", body: body)
    }
}

extension Paths {
    static public func cancelTimer(timerID: String) -> Request<Void> {
        .delete("/LiveTv/Timers/\(timerID)")
    }
}

extension Paths {
    static public func createCollection(parameters: CreateCollectionParameters? = nil) -> Request<JellyfinAPI.CollectionCreationResult> {
        .post("/Collections", query: parameters?.asQuery)
    }

    public struct CreateCollectionParameters {
        public var name: String?
        public var ids: [String]?
        public var parentID: String?
        public var isLocked: Bool?

        public init(name: String? = nil, ids: [String]? = nil, parentID: String? = nil, isLocked: Bool? = nil) {
            self.name = name
            self.ids = ids
            self.parentID = parentID
            self.isLocked = isLocked
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(name, forKey: "name")
            encoder.encode(ids, forKey: "ids")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(isLocked, forKey: "isLocked")
            return encoder.items
        }
    }
}

extension Paths {
    static public var getDefaultProfile: Request<JellyfinAPI.DeviceProfile> {
        .get("/Dlna/Profiles/Default")
    }
}

extension Paths {
    static public func syncPlaySetRepeatMode(_ body: JellyfinAPI.SetRepeatModeRequestDto) -> Request<Void> {
        .post("/SyncPlay/SetRepeatMode", body: body)
    }
}

extension Paths {
    static public func updateMediaEncoderPath(_ body: JellyfinAPI.MediaEncoderPathDto) -> Request<Void> {
        .post("/System/MediaEncoder/Path", body: body)
    }
}

extension Paths {
    static public func downloadRemoteImage(itemID: String, parameters: DownloadRemoteImageParameters) -> Request<Void> {
        .post("/Items/\(itemID)/RemoteImages/Download", query: parameters.asQuery)
    }

    public struct DownloadRemoteImageParameters {
        public var type: `Type`
        public var imageURL: String?

        public typealias `Type` = JellyfinAPI.ImageType

        public init(type: `Type`, imageURL: String? = nil) {
            self.type = type
            self.imageURL = imageURL
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(type, forKey: "type")
            encoder.encode(imageURL, forKey: "imageUrl")
            return encoder.items
        }
    }
}

extension Paths {
    static public func syncPlayBuffering(_ body: JellyfinAPI.BufferRequestDto) -> Request<Void> {
        .post("/SyncPlay/Buffering", body: body)
    }
}

extension Paths {
    static public func markPlayedItem(userID: String, itemID: String, datePlayed: Date? = nil) -> Request<JellyfinAPI.UserItemDataDto> {
        .post("/Users/\(userID)/PlayedItems/\(itemID)", query: makeMarkPlayedItemQuery(datePlayed))
    }

    private static func makeMarkPlayedItemQuery(_ datePlayed: Date?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(datePlayed, forKey: "datePlayed")
        return encoder.items
    }
}

extension Paths {
    static public func markUnplayedItem(userID: String, itemID: String) -> Request<JellyfinAPI.UserItemDataDto> {
        .delete("/Users/\(userID)/PlayedItems/\(itemID)")
    }
}

extension Paths {
    static public func getInstantMixFromItem(id: String, parameters: GetInstantMixFromItemParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Items/\(id)/InstantMix", query: parameters?.asQuery)
    }

    public struct GetInstantMixFromItemParameters {
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.userID = userID
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getPluginImage(pluginID: String, version: String) -> Request<Data> {
        .get("/Plugins/\(pluginID)/\(version)/Image")
    }
}

extension Paths {
    static public func getSeriesTimer(timerID: String) -> Request<JellyfinAPI.SeriesTimerInfoDto> {
        .get("/LiveTv/SeriesTimers/\(timerID)")
    }
}

extension Paths {
    static public func updateSeriesTimer(timerID: String, _ body: JellyfinAPI.SeriesTimerInfoDto? = nil) -> Request<Void> {
        .post("/LiveTv/SeriesTimers/\(timerID)", body: body)
    }
}

extension Paths {
    static public func cancelSeriesTimer(timerID: String) -> Request<Void> {
        .delete("/LiveTv/SeriesTimers/\(timerID)")
    }
}

extension Paths {
    static public func getFile(itemID: String) -> Request<Data> {
        .get("/Items/\(itemID)/File")
    }
}

extension Paths {
    static public func getChannels(parameters: GetChannelsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Channels", query: parameters?.asQuery)
    }

    public struct GetChannelsParameters {
        public var userID: String?
        public var startIndex: Int?
        public var limit: Int?
        public var isSupportsLatestItems: Bool?
        public var isSupportsMediaDeletion: Bool?
        public var isFavorite: Bool?

        public init(userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, isSupportsLatestItems: Bool? = nil, isSupportsMediaDeletion: Bool? = nil, isFavorite: Bool? = nil) {
            self.userID = userID
            self.startIndex = startIndex
            self.limit = limit
            self.isSupportsLatestItems = isSupportsLatestItems
            self.isSupportsMediaDeletion = isSupportsMediaDeletion
            self.isFavorite = isFavorite
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isSupportsLatestItems, forKey: "supportsLatestItems")
            encoder.encode(isSupportsMediaDeletion, forKey: "supportsMediaDeletion")
            encoder.encode(isFavorite, forKey: "isFavorite")
            return encoder.items
        }
    }
}

extension Paths {
    static public func setRead(userID: String) -> Request<Void> {
        .post("/Notifications/\(userID)/Read")
    }
}

extension Paths {
    static public func getMovieRemoteSearchResults(_ body: JellyfinAPI.MovieInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
        .post("/Items/RemoteSearch/Movie", body: body)
    }
}

extension Paths {
    static public func processContentDirectoryControlRequest(serverID: String) -> Request<String> {
        .post("/Dlna/\(serverID)/ContentDirectory/Control")
    }
}

extension Paths {
    static public func getProfile(profileID: String) -> Request<JellyfinAPI.DeviceProfile> {
        .get("/Dlna/Profiles/\(profileID)")
    }
}

extension Paths {
    static public func updateProfile(profileID: String, _ body: JellyfinAPI.DeviceProfile? = nil) -> Request<Void> {
        .post("/Dlna/Profiles/\(profileID)", body: body)
    }
}

extension Paths {
    static public func deleteProfile(profileID: String) -> Request<Void> {
        .delete("/Dlna/Profiles/\(profileID)")
    }
}

extension Paths {
    static public func setChannelMapping(_ body: JellyfinAPI.SetChannelMappingDto) -> Request<JellyfinAPI.TunerChannelMapping> {
        .post("/LiveTv/ChannelMappings", body: body)
    }
}

extension Paths {
    static public var getPasswordResetProviders: Request<[JellyfinAPI.NameIDPair]> {
        .get("/Auth/PasswordResetProviders")
    }
}

extension Paths {
    static public func syncPlaySetShuffleMode(_ body: JellyfinAPI.SetShuffleModeRequestDto) -> Request<Void> {
        .post("/SyncPlay/SetShuffleMode", body: body)
    }
}

extension Paths {
    static public func addMediaPath(isRefreshLibrary: Bool? = nil, _ body: JellyfinAPI.MediaPathDto) -> Request<Void> {
        .post("/Library/VirtualFolders/Paths", query: makeAddMediaPathQuery(isRefreshLibrary), body: body)
    }

    private static func makeAddMediaPathQuery(_ isRefreshLibrary: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
        return encoder.items
    }
}

extension Paths {
    static public func removeMediaPath(parameters: RemoveMediaPathParameters? = nil) -> Request<Void> {
        .delete("/Library/VirtualFolders/Paths", query: parameters?.asQuery)
    }

    public struct RemoveMediaPathParameters {
        public var name: String?
        public var path: String?
        public var isRefreshLibrary: Bool?

        public init(name: String? = nil, path: String? = nil, isRefreshLibrary: Bool? = nil) {
            self.name = name
            self.path = path
            self.isRefreshLibrary = isRefreshLibrary
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(name, forKey: "name")
            encoder.encode(path, forKey: "path")
            encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
            return encoder.items
        }
    }
}

extension Paths {
    static public func stopEncodingProcess(deviceID: String, playSessionID: String) -> Request<Void> {
        .delete("/Videos/ActiveEncodings", query: [("deviceId", deviceID), ("playSessionId", playSessionID)])
    }
}

extension Paths {
    static public func uploadSubtitle(itemID: String, _ body: JellyfinAPI.UploadSubtitleDto) -> Request<Void> {
        .post("/Videos/\(itemID)/Subtitles", body: body)
    }
}

extension Paths {
    static public var getPublicUsers: Request<[JellyfinAPI.UserDto]> {
        .get("/Users/Public")
    }
}

extension Paths {
    static public var getEndpointInfo: Request<JellyfinAPI.EndPointInfo> {
        .get("/System/Endpoint")
    }
}

extension Paths {
    static public func getItemImage(itemID: String, imageType: String, parameters: GetItemImageParameters? = nil) -> Request<Data> {
        .get("/Items/\(itemID)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct GetItemImageParameters {
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var tag: String?
        public var isCropWhitespace: Bool?
        public var format: Format?
        public var isAddPlayedIndicator: Bool?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(maxWidth: Int? = nil, maxHeight: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, tag: String? = nil, isCropWhitespace: Bool? = nil, format: Format? = nil, isAddPlayedIndicator: Bool? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.tag = tag
            self.isCropWhitespace = isCropWhitespace
            self.format = format
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(format, forKey: "format")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func setItemImage(itemID: String, imageType: String, _ body: Data? = nil) -> Request<Void> {
        .post("/Items/\(itemID)/Images/\(imageType)", body: body)
    }
}

extension Paths {
    static public func deleteItemImage(itemID: String, imageType: String, imageIndex: Int? = nil) -> Request<Void> {
        .delete("/Items/\(itemID)/Images/\(imageType)", query: makeDeleteItemImageQuery(imageIndex))
    }

    private static func makeDeleteItemImageQuery(_ imageIndex: Int?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(imageIndex, forKey: "imageIndex")
        return encoder.items
    }
}

extension Paths {
    static public func headItemImage(itemID: String, imageType: String, parameters: HeadItemImageParameters? = nil) -> Request<Data> {
        .head("/Items/\(itemID)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct HeadItemImageParameters {
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var tag: String?
        public var isCropWhitespace: Bool?
        public var format: Format?
        public var isAddPlayedIndicator: Bool?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(maxWidth: Int? = nil, maxHeight: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, tag: String? = nil, isCropWhitespace: Bool? = nil, format: Format? = nil, isAddPlayedIndicator: Bool? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.tag = tag
            self.isCropWhitespace = isCropWhitespace
            self.format = format
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(format, forKey: "format")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getDescriptionXml(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/description")
    }
}

extension Paths {
    static public func updateUserPassword(userID: String, _ body: JellyfinAPI.UpdateUserPassword) -> Request<Void> {
        .post("/Users/\(userID)/Password", body: body)
    }
}

extension Paths {
    static public func syncPlaySetPlaylistItem(_ body: JellyfinAPI.SetPlaylistItemRequestDto) -> Request<Void> {
        .post("/SyncPlay/SetPlaylistItem", body: body)
    }
}

extension Paths {
    static public var reportSessionEnded: Request<Void> {
        .post("/Sessions/Logout")
    }
}

extension Paths {
    static public func syncPlayJoinGroup(_ body: JellyfinAPI.JoinGroupRequestDto) -> Request<Void> {
        .post("/SyncPlay/Join", body: body)
    }
}

extension Paths {
    static public func getChannelItems(channelID: String, parameters: GetChannelItemsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Channels/\(channelID)/Items", query: parameters?.asQuery)
    }

    public struct GetChannelItemsParameters {
        public var folderID: String?
        public var userID: String?
        public var startIndex: Int?
        public var limit: Int?
        public var sortOrder: [JellyfinAPI.SortOrder]?
        public var filters: [JellyfinAPI.ItemFilter]?
        public var sortBy: [String]?
        public var fields: [JellyfinAPI.ItemFields]?

        public init(folderID: String? = nil, userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, sortBy: [String]? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
            self.folderID = folderID
            self.userID = userID
            self.startIndex = startIndex
            self.limit = limit
            self.sortOrder = sortOrder
            self.filters = filters
            self.sortBy = sortBy
            self.fields = fields
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(folderID, forKey: "folderId")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(sortOrder, forKey: "sortOrder")
            encoder.encode(filters, forKey: "filters")
            encoder.encode(sortBy, forKey: "sortBy")
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getVariantHlsAudioPlaylist(itemID: String, parameters: GetVariantHlsAudioPlaylistParameters? = nil) -> Request<Data> {
        .get("/Audio/\(itemID)/main.m3u8", query: parameters?.asQuery)
    }

    public struct GetVariantHlsAudioPlaylistParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var maxStreamingBitrate: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.maxStreamingBitrate = maxStreamingBitrate
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getSpecialFeatures(userID: String, itemID: String) -> Request<[JellyfinAPI.BaseItemDto]> {
        .get("/Users/\(userID)/Items/\(itemID)/SpecialFeatures")
    }
}

extension Paths {
    static public func mergeVersions(ids: [String]) -> Request<Void> {
        .post("/Videos/MergeVersions", query: makeMergeVersionsQuery(ids))
    }

    private static func makeMergeVersionsQuery(_ ids: [String]) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(ids, forKey: "ids")
        return encoder.items
    }
}

extension Paths {
    static public func sendFullGeneralCommand(sessionID: String, _ body: JellyfinAPI.GeneralCommand) -> Request<Void> {
        .post("/Sessions/\(sessionID)/Command", body: body)
    }
}

extension Paths {
    static public func getVariantHlsVideoPlaylist(itemID: String, parameters: GetVariantHlsVideoPlaylistParameters? = nil) -> Request<Data> {
        .get("/Videos/\(itemID)/main.m3u8", query: parameters?.asQuery)
    }

    public struct GetVariantHlsVideoPlaylistParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func discoverTuners(isNewDevicesOnly: Bool? = nil) -> Request<[JellyfinAPI.TunerHostInfo]> {
        .get("/LiveTv/Tuners/Discover", query: makeDiscoverTunersQuery(isNewDevicesOnly))
    }

    private static func makeDiscoverTunersQuery(_ isNewDevicesOnly: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isNewDevicesOnly, forKey: "newDevicesOnly")
        return encoder.items
    }
}

extension Paths {
    static public func reportPlaybackStopped(_ body: JellyfinAPI.PlaybackStopInfo? = nil) -> Request<Void> {
        .post("/Sessions/Playing/Stopped", body: body)
    }
}

extension Paths {
    static public func getAudioStreamByContainer(itemID: String, container: String, parameters: GetAudioStreamByContainerParameters? = nil) -> Request<Data> {
        .get("/Audio/\(itemID)/stream.\(container)", query: parameters?.asQuery)
    }

    public struct GetAudioStreamByContainerParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headAudioStreamByContainer(itemID: String, container: String, parameters: HeadAudioStreamByContainerParameters? = nil) -> Request<Data> {
        .head("/Audio/\(itemID)/stream.\(container)", query: parameters?.asQuery)
    }

    public struct HeadAudioStreamByContainerParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getItemImage2(itemID: String, imageType: String, maxWidth: Int, maxHeight: Int, tag: String, format: String, percentPlayed: String, unplayedCount: Int, imageIndex: Int, parameters: GetItemImage2Parameters? = nil) -> Request<Data> {
        .get("/Items/\(itemID)/Images/\(imageType)/\(imageIndex)/\(tag)/\(format)/\(maxWidth)/\(maxHeight)/\(percentPlayed)/\(unplayedCount)", query: parameters?.asQuery)
    }

    public struct GetItemImage2Parameters {
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public init(width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headItemImage2(itemID: String, imageType: String, maxWidth: Int, maxHeight: Int, tag: String, format: String, percentPlayed: String, unplayedCount: Int, imageIndex: Int, parameters: HeadItemImage2Parameters? = nil) -> Request<Data> {
        .head("/Items/\(itemID)/Images/\(imageType)/\(imageIndex)/\(tag)/\(format)/\(maxWidth)/\(maxHeight)/\(percentPlayed)/\(unplayedCount)", query: parameters?.asQuery)
    }

    public struct HeadItemImage2Parameters {
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public init(width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func enablePlugin(pluginID: String, version: String) -> Request<Void> {
        .post("/Plugins/\(pluginID)/\(version)/Enable")
    }
}

extension Paths {
    static public func deleteSubtitle(itemID: String, index: Int) -> Request<Void> {
        .delete("/Videos/\(itemID)/Subtitles/\(index)")
    }
}

extension Paths {
    static public func createUserByName(_ body: JellyfinAPI.CreateUserByName) -> Request<JellyfinAPI.UserDto> {
        .post("/Users/New", body: body)
    }
}

extension Paths {
    static public var getConfiguration: Request<JellyfinAPI.ServerConfiguration> {
        .get("/System/Configuration")
    }
}

extension Paths {
    static public func updateConfiguration(_ body: JellyfinAPI.ServerConfiguration) -> Request<Void> {
        .post("/System/Configuration", body: body)
    }
}

extension Paths {
    static public var syncPlayUnpause: Request<Void> {
        .post("/SyncPlay/Unpause")
    }
}

extension Paths {
    static public var getNotificationServices: Request<[JellyfinAPI.NameIDPair]> {
        .get("/Notifications/Services")
    }
}

extension Paths {
    static public func getNotificationsSummary(userID: String) -> Request<JellyfinAPI.NotificationsSummaryDto> {
        .get("/Notifications/\(userID)/Summary")
    }
}

extension Paths {
    static public func getAudioStream(itemID: String, parameters: GetAudioStreamParameters? = nil) -> Request<Data> {
        .get("/Audio/\(itemID)/stream", query: parameters?.asQuery)
    }

    public struct GetAudioStreamParameters {
        public var container: String?
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.container = container
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(container, forKey: "container")
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headAudioStream(itemID: String, parameters: HeadAudioStreamParameters? = nil) -> Request<Data> {
        .head("/Audio/\(itemID)/stream", query: parameters?.asQuery)
    }

    public struct HeadAudioStreamParameters {
        public var container: String?
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.container = container
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(container, forKey: "container")
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public var getAllChannelFeatures: Request<[JellyfinAPI.ChannelFeatures]> {
        .get("/Channels/Features")
    }
}

extension Paths {
    static public func updateUserPolicy(userID: String, _ body: JellyfinAPI.UserPolicy) -> Request<Void> {
        .post("/Users/\(userID)/Policy", body: body)
    }
}

extension Paths {
    static public var activate: Request<Void> {
        .post("/QuickConnect/Activate")
    }
}

extension Paths {
    static public func getLocalTrailers(userID: String, itemID: String) -> Request<[JellyfinAPI.BaseItemDto]> {
        .get("/Users/\(userID)/Items/\(itemID)/LocalTrailers")
    }
}

extension Paths {
    static public func postUpdatedMovies(tmdbID: String? = nil, imdbID: String? = nil) -> Request<Void> {
        .post("/Library/Movies/Updated", query: makePostUpdatedMoviesQuery(tmdbID, imdbID))
    }

    private static func makePostUpdatedMoviesQuery(_ tmdbID: String?, _ imdbID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(tmdbID, forKey: "tmdbId")
        encoder.encode(imdbID, forKey: "imdbId")
        return encoder.items
    }
}

extension Paths {
    static public var getDrives: Request<[JellyfinAPI.FileSystemEntryInfo]> {
        .get("/Environment/Drives")
    }
}

extension Paths {
    static public func getLiveTvChannels(parameters: GetLiveTvChannelsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/LiveTv/Channels", query: parameters?.asQuery)
    }

    public struct GetLiveTvChannelsParameters {
        public var type: `Type`?
        public var userID: String?
        public var startIndex: Int?
        public var isMovie: Bool?
        public var isSeries: Bool?
        public var isNews: Bool?
        public var isKids: Bool?
        public var isSports: Bool?
        public var limit: Int?
        public var isFavorite: Bool?
        public var isLiked: Bool?
        public var isDisliked: Bool?
        public var enableImages: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableUserData: Bool?
        public var sortBy: [String]?
        public var sortOrder: SortOrder?
        public var enableFavoriteSorting: Bool?
        public var isAddCurrentProgram: Bool?

        public typealias `Type` = JellyfinAPI.ChannelType

        public typealias SortOrder = JellyfinAPI.SortOrder

        public init(type: `Type`? = nil, userID: String? = nil, startIndex: Int? = nil, isMovie: Bool? = nil, isSeries: Bool? = nil, isNews: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, limit: Int? = nil, isFavorite: Bool? = nil, isLiked: Bool? = nil, isDisliked: Bool? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableUserData: Bool? = nil, sortBy: [String]? = nil, sortOrder: SortOrder? = nil, enableFavoriteSorting: Bool? = nil, isAddCurrentProgram: Bool? = nil) {
            self.type = type
            self.userID = userID
            self.startIndex = startIndex
            self.isMovie = isMovie
            self.isSeries = isSeries
            self.isNews = isNews
            self.isKids = isKids
            self.isSports = isSports
            self.limit = limit
            self.isFavorite = isFavorite
            self.isLiked = isLiked
            self.isDisliked = isDisliked
            self.enableImages = enableImages
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.fields = fields
            self.enableUserData = enableUserData
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.enableFavoriteSorting = enableFavoriteSorting
            self.isAddCurrentProgram = isAddCurrentProgram
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(type, forKey: "type")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(isMovie, forKey: "isMovie")
            encoder.encode(isSeries, forKey: "isSeries")
            encoder.encode(isNews, forKey: "isNews")
            encoder.encode(isKids, forKey: "isKids")
            encoder.encode(isSports, forKey: "isSports")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(isLiked, forKey: "isLiked")
            encoder.encode(isDisliked, forKey: "isDisliked")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(sortBy, forKey: "sortBy")
            encoder.encode(sortOrder, forKey: "sortOrder")
            encoder.encode(enableFavoriteSorting, forKey: "enableFavoriteSorting")
            encoder.encode(isAddCurrentProgram, forKey: "addCurrentProgram")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getLiveTvPrograms(parameters: GetLiveTvProgramsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/LiveTv/Programs", query: parameters?.asQuery)
    }

    public struct GetLiveTvProgramsParameters {
        public var channelIDs: [String]?
        public var userID: String?
        public var minStartDate: Date?
        public var hasAired: Bool?
        public var isAiring: Bool?
        public var maxStartDate: Date?
        public var minEndDate: Date?
        public var maxEndDate: Date?
        public var isMovie: Bool?
        public var isSeries: Bool?
        public var isNews: Bool?
        public var isKids: Bool?
        public var isSports: Bool?
        public var startIndex: Int?
        public var limit: Int?
        public var sortBy: [String]?
        public var sortOrder: [JellyfinAPI.SortOrder]?
        public var genres: [String]?
        public var genreIDs: [String]?
        public var enableImages: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var enableUserData: Bool?
        public var seriesTimerID: String?
        public var librarySeriesID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableTotalRecordCount: Bool?

        public init(channelIDs: [String]? = nil, userID: String? = nil, minStartDate: Date? = nil, hasAired: Bool? = nil, isAiring: Bool? = nil, maxStartDate: Date? = nil, minEndDate: Date? = nil, maxEndDate: Date? = nil, isMovie: Bool? = nil, isSeries: Bool? = nil, isNews: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, startIndex: Int? = nil, limit: Int? = nil, sortBy: [String]? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, genres: [String]? = nil, genreIDs: [String]? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil, seriesTimerID: String? = nil, librarySeriesID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableTotalRecordCount: Bool? = nil) {
            self.channelIDs = channelIDs
            self.userID = userID
            self.minStartDate = minStartDate
            self.hasAired = hasAired
            self.isAiring = isAiring
            self.maxStartDate = maxStartDate
            self.minEndDate = minEndDate
            self.maxEndDate = maxEndDate
            self.isMovie = isMovie
            self.isSeries = isSeries
            self.isNews = isNews
            self.isKids = isKids
            self.isSports = isSports
            self.startIndex = startIndex
            self.limit = limit
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.genres = genres
            self.genreIDs = genreIDs
            self.enableImages = enableImages
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.enableUserData = enableUserData
            self.seriesTimerID = seriesTimerID
            self.librarySeriesID = librarySeriesID
            self.fields = fields
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(channelIDs, forKey: "channelIds")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(minStartDate, forKey: "minStartDate")
            encoder.encode(hasAired, forKey: "hasAired")
            encoder.encode(isAiring, forKey: "isAiring")
            encoder.encode(maxStartDate, forKey: "maxStartDate")
            encoder.encode(minEndDate, forKey: "minEndDate")
            encoder.encode(maxEndDate, forKey: "maxEndDate")
            encoder.encode(isMovie, forKey: "isMovie")
            encoder.encode(isSeries, forKey: "isSeries")
            encoder.encode(isNews, forKey: "isNews")
            encoder.encode(isKids, forKey: "isKids")
            encoder.encode(isSports, forKey: "isSports")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(sortBy, forKey: "sortBy")
            encoder.encode(sortOrder, forKey: "sortOrder")
            encoder.encode(genres, forKey: "genres")
            encoder.encode(genreIDs, forKey: "genreIds")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(seriesTimerID, forKey: "seriesTimerId")
            encoder.encode(librarySeriesID, forKey: "librarySeriesId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getPrograms(_ body: JellyfinAPI.GetProgramsDto? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .post("/LiveTv/Programs", body: body)
    }
}

extension Paths {
    static public func getPerson(name: String, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/Persons/\(name)", query: makeGetPersonQuery(userID))
    }

    private static func makeGetPersonQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func getMetadataEditorInfo(itemID: String) -> Request<JellyfinAPI.MetadataEditorInfo> {
        .get("/Items/\(itemID)/MetadataEditor")
    }
}

extension Paths {
    static public func getConfigurationPages(parameters: GetConfigurationPagesParameters? = nil) -> Request<[JellyfinAPI.ConfigurationPageInfo]> {
        .get("/web/ConfigurationPages", query: parameters?.asQuery)
    }

    public struct GetConfigurationPagesParameters {
        public var enableInMainMenu: Bool?
        public var pageType: PageType?

        public typealias PageType = JellyfinAPI.ConfigurationPageType

        public init(enableInMainMenu: Bool? = nil, pageType: PageType? = nil) {
            self.enableInMainMenu = enableInMainMenu
            self.pageType = pageType
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(enableInMainMenu, forKey: "enableInMainMenu")
            encoder.encode(pageType, forKey: "pageType")
            return encoder.items
        }
    }
}

extension Paths {
    static public func resetTuner(tunerID: String) -> Request<Void> {
        .post("/LiveTv/Tuners/\(tunerID)/Reset")
    }
}

extension Paths {
    static public func syncPlaySetIgnoreWait(_ body: JellyfinAPI.IgnoreWaitRequestDto) -> Request<Void> {
        .post("/SyncPlay/SetIgnoreWait", body: body)
    }
}

extension Paths {
    static public func available(parameters: AvailableParameters? = nil) -> Request<Void> {
        .post("/QuickConnect/Available", query: parameters?.asQuery)
    }

    public struct AvailableParameters {
        public var status: Status?

        public typealias Status = JellyfinAPI.QuickConnectState

        public init(status: Status? = nil) {
            self.status = status
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(status, forKey: "status")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getChannelMappingOptions(providerID: String? = nil) -> Request<JellyfinAPI.ChannelMappingOptionsDto> {
        .get("/LiveTv/ChannelMappingOptions", query: makeGetChannelMappingOptionsQuery(providerID))
    }

    private static func makeGetChannelMappingOptionsQuery(_ providerID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(providerID, forKey: "providerId")
        return encoder.items
    }
}

extension Paths {
    static public func get(parameters: GetParameters) -> Request<JellyfinAPI.SearchHintResult> {
        .get("/Search/Hints", query: parameters.asQuery)
    }

    public struct GetParameters {
        public var startIndex: Int?
        public var limit: Int?
        public var userID: String?
        public var searchTerm: String
        public var includeItemTypes: [String]?
        public var excludeItemTypes: [String]?
        public var mediaTypes: [String]?
        public var parentID: String?
        public var isMovie: Bool?
        public var isSeries: Bool?
        public var isNews: Bool?
        public var isKids: Bool?
        public var isSports: Bool?
        public var isIncludePeople: Bool?
        public var isIncludeMedia: Bool?
        public var isIncludeGenres: Bool?
        public var isIncludeStudios: Bool?
        public var isIncludeArtists: Bool?

        public init(startIndex: Int? = nil, limit: Int? = nil, userID: String? = nil, searchTerm: String, includeItemTypes: [String]? = nil, excludeItemTypes: [String]? = nil, mediaTypes: [String]? = nil, parentID: String? = nil, isMovie: Bool? = nil, isSeries: Bool? = nil, isNews: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, isIncludePeople: Bool? = nil, isIncludeMedia: Bool? = nil, isIncludeGenres: Bool? = nil, isIncludeStudios: Bool? = nil, isIncludeArtists: Bool? = nil) {
            self.startIndex = startIndex
            self.limit = limit
            self.userID = userID
            self.searchTerm = searchTerm
            self.includeItemTypes = includeItemTypes
            self.excludeItemTypes = excludeItemTypes
            self.mediaTypes = mediaTypes
            self.parentID = parentID
            self.isMovie = isMovie
            self.isSeries = isSeries
            self.isNews = isNews
            self.isKids = isKids
            self.isSports = isSports
            self.isIncludePeople = isIncludePeople
            self.isIncludeMedia = isIncludeMedia
            self.isIncludeGenres = isIncludeGenres
            self.isIncludeStudios = isIncludeStudios
            self.isIncludeArtists = isIncludeArtists
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(mediaTypes, forKey: "mediaTypes")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(isMovie, forKey: "isMovie")
            encoder.encode(isSeries, forKey: "isSeries")
            encoder.encode(isNews, forKey: "isNews")
            encoder.encode(isKids, forKey: "isKids")
            encoder.encode(isSports, forKey: "isSports")
            encoder.encode(isIncludePeople, forKey: "includePeople")
            encoder.encode(isIncludeMedia, forKey: "includeMedia")
            encoder.encode(isIncludeGenres, forKey: "includeGenres")
            encoder.encode(isIncludeStudios, forKey: "includeStudios")
            encoder.encode(isIncludeArtists, forKey: "includeArtists")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getContentDirectory2(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/ContentDirectory/ContentDirectory")
    }
}

extension Paths {
    static public func getTask(taskID: String) -> Request<JellyfinAPI.TaskInfo> {
        .get("/ScheduledTasks/\(taskID)")
    }
}

extension Paths {
    static public var getRepositories: Request<[JellyfinAPI.RepositoryInfo]> {
        .get("/Repositories")
    }
}

extension Paths {
    static public func setRepositories(_ body: [JellyfinAPI.RepositoryInfo]) -> Request<Void> {
        .post("/Repositories", body: body)
    }
}

extension Paths {
    static public func syncPlaySeek(_ body: JellyfinAPI.SeekRequestDto) -> Request<Void> {
        .post("/SyncPlay/Seek", body: body)
    }
}

extension Paths {
    static public func updateLibraryOptions(_ body: JellyfinAPI.UpdateLibraryOptionsDto? = nil) -> Request<Void> {
        .post("/Library/VirtualFolders/LibraryOptions", body: body)
    }
}

extension Paths {
    static public func authenticateUser(userID: String, pw: String, password: String? = nil) -> Request<JellyfinAPI.AuthenticationResult> {
        .post("/Users/\(userID)/Authenticate", query: makeAuthenticateUserQuery(pw, password))
    }

    private static func makeAuthenticateUserQuery(_ pw: String, _ password: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(pw, forKey: "pw")
        encoder.encode(password, forKey: "password")
        return encoder.items
    }
}

extension Paths {
    static public func getGenres(parameters: GetGenresParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Genres", query: parameters?.asQuery)
    }

    public struct GetGenresParameters {
        public var startIndex: Int?
        public var limit: Int?
        public var searchTerm: String?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var excludeItemTypes: [String]?
        public var includeItemTypes: [String]?
        public var isFavorite: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var userID: String?
        public var nameStartsWithOrGreater: String?
        public var nameStartsWith: String?
        public var nameLessThan: String?
        public var enableImages: Bool?
        public var enableTotalRecordCount: Bool?

        public init(startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, isFavorite: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
            self.startIndex = startIndex
            self.limit = limit
            self.searchTerm = searchTerm
            self.parentID = parentID
            self.fields = fields
            self.excludeItemTypes = excludeItemTypes
            self.includeItemTypes = includeItemTypes
            self.isFavorite = isFavorite
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.userID = userID
            self.nameStartsWithOrGreater = nameStartsWithOrGreater
            self.nameStartsWith = nameStartsWith
            self.nameLessThan = nameLessThan
            self.enableImages = enableImages
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
            encoder.encode(nameStartsWith, forKey: "nameStartsWith")
            encoder.encode(nameLessThan, forKey: "nameLessThan")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getGenreImageByIndex(name: String, imageType: String, imageIndex: Int, parameters: GetGenreImageByIndexParameters? = nil) -> Request<Data> {
        .get("/Genres/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct GetGenreImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headGenreImageByIndex(name: String, imageType: String, imageIndex: Int, parameters: HeadGenreImageByIndexParameters? = nil) -> Request<Data> {
        .head("/Genres/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct HeadGenreImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getUserByID(userID: String) -> Request<JellyfinAPI.UserDto> {
        .get("/Users/\(userID)")
    }
}

extension Paths {
    static public func updateUser(userID: String, _ body: JellyfinAPI.UserDto) -> Request<Void> {
        .post("/Users/\(userID)", body: body)
    }
}

extension Paths {
    static public func deleteUser(userID: String) -> Request<Void> {
        .delete("/Users/\(userID)")
    }
}

extension Paths {
    static public func getDescriptionXml2(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/description.xml")
    }
}

extension Paths {
    static public func getMediaReceiverRegistrar3(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/MediaReceiverRegistrar/MediaReceiverRegistrar.xml")
    }
}

extension Paths {
    static public func validatePath(_ body: JellyfinAPI.ValidatePathDto) -> Request<Void> {
        .post("/Environment/ValidatePath", body: body)
    }
}

extension Paths {
    static public func getLatestChannelItems(parameters: GetLatestChannelItemsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Channels/Items/Latest", query: parameters?.asQuery)
    }

    public struct GetLatestChannelItemsParameters {
        public var userID: String?
        public var startIndex: Int?
        public var limit: Int?
        public var filters: [JellyfinAPI.ItemFilter]?
        public var fields: [JellyfinAPI.ItemFields]?
        public var channelIDs: [String]?

        public init(userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, channelIDs: [String]? = nil) {
            self.userID = userID
            self.startIndex = startIndex
            self.limit = limit
            self.filters = filters
            self.fields = fields
            self.channelIDs = channelIDs
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(filters, forKey: "filters")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(channelIDs, forKey: "channelIds")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getRemoteImages(itemID: String, parameters: GetRemoteImagesParameters? = nil) -> Request<JellyfinAPI.RemoteImageResult> {
        .get("/Items/\(itemID)/RemoteImages", query: parameters?.asQuery)
    }

    public struct GetRemoteImagesParameters {
        public var type: `Type`?
        public var startIndex: Int?
        public var limit: Int?
        public var providerName: String?
        public var isIncludeAllLanguages: Bool?

        public typealias `Type` = JellyfinAPI.ImageType

        public init(type: `Type`? = nil, startIndex: Int? = nil, limit: Int? = nil, providerName: String? = nil, isIncludeAllLanguages: Bool? = nil) {
            self.type = type
            self.startIndex = startIndex
            self.limit = limit
            self.providerName = providerName
            self.isIncludeAllLanguages = isIncludeAllLanguages
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(type, forKey: "type")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(providerName, forKey: "providerName")
            encoder.encode(isIncludeAllLanguages, forKey: "includeAllLanguages")
            return encoder.items
        }
    }
}

extension Paths {
    static public var getUtcTime: Request<JellyfinAPI.UtcTimeResponse> {
        .get("/GetUtcTime")
    }
}

extension Paths {
    static public var getWakeOnLanInfo: Request<[JellyfinAPI.WakeOnLanInfo]> {
        .get("/System/WakeOnLanInfo")
    }
}

extension Paths {
    static public func getEpisodes(seriesID: String, parameters: GetEpisodesParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Shows/\(seriesID)/Episodes", query: parameters?.asQuery)
    }

    public struct GetEpisodesParameters {
        public var userID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var season: Int?
        public var seasonID: String?
        public var isMissing: Bool?
        public var adjacentTo: String?
        public var startItemID: String?
        public var startIndex: Int?
        public var limit: Int?
        public var enableImages: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var enableUserData: Bool?
        public var sortBy: String?

        public init(userID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, season: Int? = nil, seasonID: String? = nil, isMissing: Bool? = nil, adjacentTo: String? = nil, startItemID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil, sortBy: String? = nil) {
            self.userID = userID
            self.fields = fields
            self.season = season
            self.seasonID = seasonID
            self.isMissing = isMissing
            self.adjacentTo = adjacentTo
            self.startItemID = startItemID
            self.startIndex = startIndex
            self.limit = limit
            self.enableImages = enableImages
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.enableUserData = enableUserData
            self.sortBy = sortBy
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(season, forKey: "season")
            encoder.encode(seasonID, forKey: "seasonId")
            encoder.encode(isMissing, forKey: "isMissing")
            encoder.encode(adjacentTo, forKey: "adjacentTo")
            encoder.encode(startItemID, forKey: "startItemId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(sortBy, forKey: "sortBy")
            return encoder.items
        }
    }
}

extension Paths {
    static public func updateItemContentType(itemID: String, contentType: String? = nil) -> Request<Void> {
        .post("/Items/\(itemID)/ContentType", query: makeUpdateItemContentTypeQuery(contentType))
    }

    private static func makeUpdateItemContentTypeQuery(_ contentType: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(contentType, forKey: "contentType")
        return encoder.items
    }
}

extension Paths {
    static public func markFavoriteItem(userID: String, itemID: String) -> Request<JellyfinAPI.UserItemDataDto> {
        .post("/Users/\(userID)/FavoriteItems/\(itemID)")
    }
}

extension Paths {
    static public func unmarkFavoriteItem(userID: String, itemID: String) -> Request<JellyfinAPI.UserItemDataDto> {
        .delete("/Users/\(userID)/FavoriteItems/\(itemID)")
    }
}

extension Paths {
    static public var syncPlayGetGroups: Request<[JellyfinAPI.GroupInfoDto]> {
        .get("/SyncPlay/List")
    }
}

extension Paths {
    static public func updateItemImageIndex(itemID: String, imageType: String, imageIndex: Int, newIndex: Int) -> Request<Void> {
        .post("/Items/\(itemID)/Images/\(imageType)/\(imageIndex)/Index", query: [("newIndex", String(newIndex))])
    }
}

extension Paths {
    static public func createProfile(_ body: JellyfinAPI.DeviceProfile? = nil) -> Request<Void> {
        .post("/Dlna/Profiles", body: body)
    }
}

extension Paths {
    static public var getServerLogs: Request<[JellyfinAPI.LogFile]> {
        .get("/System/Logs")
    }
}

extension Paths {
    static public func getStudioImage(name: String, imageType: String, parameters: GetStudioImageParameters? = nil) -> Request<Data> {
        .get("/Studios/\(name)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct GetStudioImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headStudioImage(name: String, imageType: String, parameters: HeadStudioImageParameters? = nil) -> Request<Data> {
        .head("/Studios/\(name)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct HeadStudioImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func installPackage(name: String, parameters: InstallPackageParameters? = nil) -> Request<Void> {
        .post("/Packages/Installed/\(name)", query: parameters?.asQuery)
    }

    public struct InstallPackageParameters {
        public var assemblyGuid: String?
        public var version: String?
        public var repositoryURL: String?

        public init(assemblyGuid: String? = nil, version: String? = nil, repositoryURL: String? = nil) {
            self.assemblyGuid = assemblyGuid
            self.version = version
            self.repositoryURL = repositoryURL
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(assemblyGuid, forKey: "assemblyGuid")
            encoder.encode(version, forKey: "version")
            encoder.encode(repositoryURL, forKey: "repositoryUrl")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getSessions(parameters: GetSessionsParameters? = nil) -> Request<[JellyfinAPI.SessionInfo]> {
        .get("/Sessions", query: parameters?.asQuery)
    }

    public struct GetSessionsParameters {
        public var controllableByUserID: String?
        public var deviceID: String?
        public var activeWithinSeconds: Int?

        public init(controllableByUserID: String? = nil, deviceID: String? = nil, activeWithinSeconds: Int? = nil) {
            self.controllableByUserID = controllableByUserID
            self.deviceID = deviceID
            self.activeWithinSeconds = activeWithinSeconds
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(controllableByUserID, forKey: "controllableByUserId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(activeWithinSeconds, forKey: "activeWithinSeconds")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getStudios(parameters: GetStudiosParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Studios", query: parameters?.asQuery)
    }

    public struct GetStudiosParameters {
        public var startIndex: Int?
        public var limit: Int?
        public var searchTerm: String?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var excludeItemTypes: [String]?
        public var includeItemTypes: [String]?
        public var isFavorite: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var userID: String?
        public var nameStartsWithOrGreater: String?
        public var nameStartsWith: String?
        public var nameLessThan: String?
        public var enableImages: Bool?
        public var enableTotalRecordCount: Bool?

        public init(startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, isFavorite: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
            self.startIndex = startIndex
            self.limit = limit
            self.searchTerm = searchTerm
            self.parentID = parentID
            self.fields = fields
            self.excludeItemTypes = excludeItemTypes
            self.includeItemTypes = includeItemTypes
            self.isFavorite = isFavorite
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.userID = userID
            self.nameStartsWithOrGreater = nameStartsWithOrGreater
            self.nameStartsWith = nameStartsWith
            self.nameLessThan = nameLessThan
            self.enableImages = enableImages
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
            encoder.encode(nameStartsWith, forKey: "nameStartsWith")
            encoder.encode(nameLessThan, forKey: "nameLessThan")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getInstantMixFromAlbum(id: String, parameters: GetInstantMixFromAlbumParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Albums/\(id)/InstantMix", query: parameters?.asQuery)
    }

    public struct GetInstantMixFromAlbumParameters {
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.userID = userID
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getNamedConfiguration(key: String) -> Request<String> {
        .get("/System/Configuration/\(key)")
    }
}

extension Paths {
    static public func updateNamedConfiguration(key: String) -> Request<Void> {
        .post("/System/Configuration/\(key)")
    }
}

extension Paths {
    static public func getGeneralImage(name: String, type: String) -> Request<Data> {
        .get("/Images/General/\(name)/\(type)")
    }
}

extension Paths {
    static public func getSubtitlePlaylist(itemID: String, index: Int, mediaSourceID: String, segmentLength: Int) -> Request<Data> {
        .get("/Videos/\(itemID)/\(mediaSourceID)/Subtitles/\(index)/subtitles.m3u8", query: [("segmentLength", String(segmentLength))])
    }
}

extension Paths {
    static public var getGeneralImages: Request<[JellyfinAPI.ImageByNameInfo]> {
        .get("/Images/General")
    }
}

extension Paths {
    static public var getRatingImages: Request<[JellyfinAPI.ImageByNameInfo]> {
        .get("/Images/Ratings")
    }
}

extension Paths {
    static public func getYears(parameters: GetYearsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Years", query: parameters?.asQuery)
    }

    public struct GetYearsParameters {
        public var startIndex: Int?
        public var limit: Int?
        public var sortOrder: [JellyfinAPI.SortOrder]?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var excludeItemTypes: [String]?
        public var includeItemTypes: [String]?
        public var mediaTypes: [String]?
        public var sortBy: [String]?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var userID: String?
        public var isRecursive: Bool?
        public var enableImages: Bool?

        public init(startIndex: Int? = nil, limit: Int? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, mediaTypes: [String]? = nil, sortBy: [String]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, userID: String? = nil, isRecursive: Bool? = nil, enableImages: Bool? = nil) {
            self.startIndex = startIndex
            self.limit = limit
            self.sortOrder = sortOrder
            self.parentID = parentID
            self.fields = fields
            self.excludeItemTypes = excludeItemTypes
            self.includeItemTypes = includeItemTypes
            self.mediaTypes = mediaTypes
            self.sortBy = sortBy
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.userID = userID
            self.isRecursive = isRecursive
            self.enableImages = enableImages
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(sortOrder, forKey: "sortOrder")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(mediaTypes, forKey: "mediaTypes")
            encoder.encode(sortBy, forKey: "sortBy")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(isRecursive, forKey: "recursive")
            encoder.encode(enableImages, forKey: "enableImages")
            return encoder.items
        }
    }
}

extension Paths {
    static public func deleteAlternateSources(itemID: String) -> Request<Void> {
        .delete("/Videos/\(itemID)/AlternateSources")
    }
}

extension Paths {
    static public func getTrailerRemoteSearchResults(_ body: JellyfinAPI.TrailerInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
        .post("/Items/RemoteSearch/Trailer", body: body)
    }
}

extension Paths {
    static public var shutdownApplication: Request<Void> {
        .post("/System/Shutdown")
    }
}

extension Paths {
    static public func getMediaInfoImage(theme: String, name: String) -> Request<Data> {
        .get("/Images/MediaInfo/\(theme)/\(name)")
    }
}

extension Paths {
    static public func getMediaFolders(isHidden: Bool? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Library/MediaFolders", query: makeGetMediaFoldersQuery(isHidden))
    }

    private static func makeGetMediaFoldersQuery(_ isHidden: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isHidden, forKey: "isHidden")
        return encoder.items
    }
}

extension Paths {
    static public func getSeriesRemoteSearchResults(_ body: JellyfinAPI.SeriesInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
        .post("/Items/RemoteSearch/Series", body: body)
    }
}

extension Paths {
    static public func getVideoStreamByContainer(itemID: String, container: String, parameters: GetVideoStreamByContainerParameters? = nil) -> Request<Data> {
        .get("/Videos/\(itemID)/stream.\(container)", query: parameters?.asQuery)
    }

    public struct GetVideoStreamByContainerParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headVideoStreamByContainer(itemID: String, container: String, parameters: HeadVideoStreamByContainerParameters? = nil) -> Request<Data> {
        .head("/Videos/\(itemID)/stream.\(container)", query: parameters?.asQuery)
    }

    public struct HeadVideoStreamByContainerParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getHlsAudioSegmentLegacyMp3(itemID: String, segmentID: String) -> Request<Data> {
        .get("/Audio/\(itemID)/hls/\(segmentID)/stream.mp3")
    }
}

extension Paths {
    static public func postUpdatedMedia(_ body: JellyfinAPI.MediaUpdateInfoDto) -> Request<Void> {
        .post("/Library/Media/Updated", body: body)
    }
}

extension Paths {
    static public func updateTask(taskID: String, _ body: [JellyfinAPI.TaskTriggerInfo]) -> Request<Void> {
        .post("/ScheduledTasks/\(taskID)/Triggers", body: body)
    }
}

extension Paths {
    static public func getThemeMedia(itemID: String, userID: String? = nil, isInheritFromParent: Bool? = nil) -> Request<JellyfinAPI.AllThemeMediaResult> {
        .get("/Items/\(itemID)/ThemeMedia", query: makeGetThemeMediaQuery(userID, isInheritFromParent))
    }

    private static func makeGetThemeMediaQuery(_ userID: String?, _ isInheritFromParent: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        encoder.encode(isInheritFromParent, forKey: "inheritFromParent")
        return encoder.items
    }
}

extension Paths {
    static public func getRecordings(parameters: GetRecordingsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/LiveTv/Recordings", query: parameters?.asQuery)
    }

    public struct GetRecordingsParameters {
        public var channelID: String?
        public var userID: String?
        public var startIndex: Int?
        public var limit: Int?
        public var status: Status?
        public var isInProgress: Bool?
        public var seriesTimerID: String?
        public var enableImages: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableUserData: Bool?
        public var isMovie: Bool?
        public var isSeries: Bool?
        public var isKids: Bool?
        public var isSports: Bool?
        public var isNews: Bool?
        public var isLibraryItem: Bool?
        public var enableTotalRecordCount: Bool?

        public typealias Status = JellyfinAPI.RecordingStatus

        public init(channelID: String? = nil, userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, status: Status? = nil, isInProgress: Bool? = nil, seriesTimerID: String? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableUserData: Bool? = nil, isMovie: Bool? = nil, isSeries: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, isNews: Bool? = nil, isLibraryItem: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
            self.channelID = channelID
            self.userID = userID
            self.startIndex = startIndex
            self.limit = limit
            self.status = status
            self.isInProgress = isInProgress
            self.seriesTimerID = seriesTimerID
            self.enableImages = enableImages
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.fields = fields
            self.enableUserData = enableUserData
            self.isMovie = isMovie
            self.isSeries = isSeries
            self.isKids = isKids
            self.isSports = isSports
            self.isNews = isNews
            self.isLibraryItem = isLibraryItem
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(channelID, forKey: "channelId")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(status, forKey: "status")
            encoder.encode(isInProgress, forKey: "isInProgress")
            encoder.encode(seriesTimerID, forKey: "seriesTimerId")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(isMovie, forKey: "isMovie")
            encoder.encode(isSeries, forKey: "isSeries")
            encoder.encode(isKids, forKey: "isKids")
            encoder.encode(isSports, forKey: "isSports")
            encoder.encode(isNews, forKey: "isNews")
            encoder.encode(isLibraryItem, forKey: "isLibraryItem")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getHlsAudioSegmentLegacyAac(itemID: String, segmentID: String) -> Request<Data> {
        .get("/Audio/\(itemID)/hls/\(segmentID)/stream.aac")
    }
}

extension Paths {
    static public var getAuthProviders: Request<[JellyfinAPI.NameIDPair]> {
        .get("/Auth/Providers")
    }
}

extension Paths {
    static public func getLiveStreamFile(streamID: String, container: String) -> Request<Data> {
        .get("/LiveTv/LiveStreamFiles/\(streamID)/stream.\(container)")
    }
}

extension Paths {
    static public func displayContent(sessionID: String, parameters: DisplayContentParameters) -> Request<Void> {
        .post("/Sessions/\(sessionID)/Viewing", query: parameters.asQuery)
    }

    public struct DisplayContentParameters {
        public var itemType: String
        public var itemID: String
        public var itemName: String

        public init(itemType: String, itemID: String, itemName: String) {
            self.itemType = itemType
            self.itemID = itemID
            self.itemName = itemName
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(itemType, forKey: "itemType")
            encoder.encode(itemID, forKey: "itemId")
            encoder.encode(itemName, forKey: "itemName")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getDevices(isSupportsSync: Bool? = nil, userID: String? = nil) -> Request<JellyfinAPI.DeviceInfoQueryResult> {
        .get("/Devices", query: makeGetDevicesQuery(isSupportsSync, userID))
    }

    private static func makeGetDevicesQuery(_ isSupportsSync: Bool?, _ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isSupportsSync, forKey: "supportsSync")
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func deleteDevice(id: String) -> Request<Void> {
        .delete("/Devices", query: [("id", id)])
    }
}

extension Paths {
    static public func getBookRemoteSearchResults(_ body: JellyfinAPI.BookInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
        .post("/Items/RemoteSearch/Book", body: body)
    }
}

extension Paths {
    static public var getGuideInfo: Request<JellyfinAPI.GuideInfo> {
        .get("/LiveTv/GuideInfo")
    }
}

extension Paths {
    static public func updateUserConfiguration(userID: String, _ body: JellyfinAPI.UserConfiguration) -> Request<Void> {
        .post("/Users/\(userID)/Configuration", body: body)
    }
}

extension Paths {
    static public func getContentDirectory(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/ContentDirectory")
    }
}

extension Paths {
    static public func postAddedMovies(tmdbID: String? = nil, imdbID: String? = nil) -> Request<Void> {
        .post("/Library/Movies/Added", query: makePostAddedMoviesQuery(tmdbID, imdbID))
    }

    private static func makePostAddedMoviesQuery(_ tmdbID: String?, _ imdbID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(tmdbID, forKey: "tmdbId")
        encoder.encode(imdbID, forKey: "imdbId")
        return encoder.items
    }
}

extension Paths {
    static public func getGenreImage(name: String, imageType: String, parameters: GetGenreImageParameters? = nil) -> Request<Data> {
        .get("/Genres/\(name)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct GetGenreImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headGenreImage(name: String, imageType: String, parameters: HeadGenreImageParameters? = nil) -> Request<Data> {
        .head("/Genres/\(name)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct HeadGenreImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public var syncPlayStop: Request<Void> {
        .post("/SyncPlay/Stop")
    }
}

extension Paths {
    static public func addToCollection(collectionID: String, ids: [String]) -> Request<Void> {
        .post("/Collections/\(collectionID)/Items", query: makeAddToCollectionQuery(ids))
    }

    private static func makeAddToCollectionQuery(_ ids: [String]) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(ids, forKey: "ids")
        return encoder.items
    }
}

extension Paths {
    static public func removeFromCollection(collectionID: String, ids: [String]) -> Request<Void> {
        .delete("/Collections/\(collectionID)/Items", query: makeRemoveFromCollectionQuery(ids))
    }

    private static func makeRemoveFromCollectionQuery(_ ids: [String]) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(ids, forKey: "ids")
        return encoder.items
    }
}

extension Paths {
    static public func getPlaylistItems(playlistID: String, parameters: GetPlaylistItemsParameters) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Playlists/\(playlistID)/Items", query: parameters.asQuery)
    }

    public struct GetPlaylistItemsParameters {
        public var userID: String
        public var startIndex: Int?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(userID: String, startIndex: Int? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.userID = userID
            self.startIndex = startIndex
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func addToPlaylist(playlistID: String, ids: [String]? = nil, userID: String? = nil) -> Request<Void> {
        .post("/Playlists/\(playlistID)/Items", query: makeAddToPlaylistQuery(ids, userID))
    }

    private static func makeAddToPlaylistQuery(_ ids: [String]?, _ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(ids, forKey: "ids")
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func removeFromPlaylist(playlistID: String, entryIDs: [String]? = nil) -> Request<Void> {
        .delete("/Playlists/\(playlistID)/Items", query: makeRemoveFromPlaylistQuery(entryIDs))
    }

    private static func makeRemoveFromPlaylistQuery(_ entryIDs: [String]?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(entryIDs, forKey: "entryIds")
        return encoder.items
    }
}

extension Paths {
    static public func applySearchCriteria(itemID: String, isReplaceAllImages: Bool? = nil, _ body: JellyfinAPI.RemoteSearchResult) -> Request<Void> {
        .post("/Items/RemoteSearch/Apply/\(itemID)", query: makeApplySearchCriteriaQuery(isReplaceAllImages), body: body)
    }

    private static func makeApplySearchCriteriaQuery(_ isReplaceAllImages: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isReplaceAllImages, forKey: "replaceAllImages")
        return encoder.items
    }
}

extension Paths {
    static public var getLiveTvInfo: Request<JellyfinAPI.LiveTvInfo> {
        .get("/LiveTv/Info")
    }
}

extension Paths {
    static public func forgotPasswordPin(_ body: JellyfinAPI.ForgotPasswordPinDto) -> Request<JellyfinAPI.PinRedeemResult> {
        .post("/Users/ForgotPassword/Pin", body: body)
    }
}

extension Paths {
    static public func getMusicGenreImage(name: String, imageType: String, parameters: GetMusicGenreImageParameters? = nil) -> Request<Data> {
        .get("/MusicGenres/\(name)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct GetMusicGenreImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headMusicGenreImage(name: String, imageType: String, parameters: HeadMusicGenreImageParameters? = nil) -> Request<Data> {
        .head("/MusicGenres/\(name)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct HeadMusicGenreImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getRootFolder(userID: String) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/Users/\(userID)/Items/Root")
    }
}

extension Paths {
    static public func forgotPassword(_ body: JellyfinAPI.ForgotPasswordDto) -> Request<JellyfinAPI.ForgotPasswordResult> {
        .post("/Users/ForgotPassword", body: body)
    }
}

extension Paths {
    static public func getFallbackFont(name: String) -> Request<Data> {
        .get("/FallbackFont/Fonts/\(name)")
    }
}

extension Paths {
    static public func getAdditionalPart(itemID: String, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Videos/\(itemID)/AdditionalParts", query: makeGetAdditionalPartQuery(userID))
    }

    private static func makeGetAdditionalPartQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func getConnectionManager3(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/ConnectionManager/ConnectionManager.xml")
    }
}

extension Paths {
    static public var getSchedulesDirectCountries: Request<String> {
        .get("/LiveTv/ListingProviders/SchedulesDirect/Countries")
    }
}

extension Paths {
    static public func postAddedSeries(tvdbID: String? = nil) -> Request<Void> {
        .post("/Library/Series/Added", query: makePostAddedSeriesQuery(tvdbID))
    }

    private static func makePostAddedSeriesQuery(_ tvdbID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(tvdbID, forKey: "tvdbId")
        return encoder.items
    }
}

extension Paths {
    static public func getPersonImageByIndex(name: String, imageType: String, imageIndex: Int, parameters: GetPersonImageByIndexParameters? = nil) -> Request<Data> {
        .get("/Persons/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct GetPersonImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headPersonImageByIndex(name: String, imageType: String, imageIndex: Int, parameters: HeadPersonImageByIndexParameters? = nil) -> Request<Data> {
        .head("/Persons/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct HeadPersonImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func createPlaylist(parameters: CreatePlaylistParameters? = nil, _ body: JellyfinAPI.CreatePlaylistDto? = nil) -> Request<JellyfinAPI.PlaylistCreationResult> {
        .post("/Playlists", query: parameters?.asQuery, body: body)
    }

    public struct CreatePlaylistParameters {
        public var name: String?
        public var ids: [String]?
        public var userID: String?
        public var mediaType: String?

        public init(name: String? = nil, ids: [String]? = nil, userID: String? = nil, mediaType: String? = nil) {
            self.name = name
            self.ids = ids
            self.userID = userID
            self.mediaType = mediaType
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(name, forKey: "name")
            encoder.encode(ids, forKey: "ids")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(mediaType, forKey: "mediaType")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getExternalIDInfos(itemID: String) -> Request<[JellyfinAPI.ExternalIDInfo]> {
        .get("/Items/\(itemID)/ExternalIdInfos")
    }
}

extension Paths {
    static public var syncPlayPause: Request<Void> {
        .post("/SyncPlay/Pause")
    }
}

extension Paths {
    static public func getChannel(channelID: String, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/LiveTv/Channels/\(channelID)", query: makeGetChannelQuery(userID))
    }

    private static func makeGetChannelQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func getSimilarAlbums(itemID: String, parameters: GetSimilarAlbumsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Albums/\(itemID)/Similar", query: parameters?.asQuery)
    }

    public struct GetSimilarAlbumsParameters {
        public var excludeArtistIDs: [String]?
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?

        public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
            self.excludeArtistIDs = excludeArtistIDs
            self.userID = userID
            self.limit = limit
            self.fields = fields
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getPersonImage(name: String, imageType: String, parameters: GetPersonImageParameters? = nil) -> Request<Data> {
        .get("/Persons/\(name)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct GetPersonImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headPersonImage(name: String, imageType: String, parameters: HeadPersonImageParameters? = nil) -> Request<Data> {
        .head("/Persons/\(name)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct HeadPersonImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getMediaReceiverRegistrar(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/MediaReceiverRegistrar")
    }
}

extension Paths {
    static public func openLiveStream(parameters: OpenLiveStreamParameters? = nil, _ body: JellyfinAPI.OpenLiveStreamDto? = nil) -> Request<JellyfinAPI.LiveStreamResponse> {
        .post("/LiveStreams/Open", query: parameters?.asQuery, body: body)
    }

    public struct OpenLiveStreamParameters {
        public var openToken: String?
        public var userID: String?
        public var playSessionID: String?
        public var maxStreamingBitrate: Int?
        public var startTimeTicks: Int?
        public var audioStreamIndex: Int?
        public var subtitleStreamIndex: Int?
        public var maxAudioChannels: Int?
        public var itemID: String?
        public var enableDirectPlay: Bool?
        public var enableDirectStream: Bool?

        public init(openToken: String? = nil, userID: String? = nil, playSessionID: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, itemID: String? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil) {
            self.openToken = openToken
            self.userID = userID
            self.playSessionID = playSessionID
            self.maxStreamingBitrate = maxStreamingBitrate
            self.startTimeTicks = startTimeTicks
            self.audioStreamIndex = audioStreamIndex
            self.subtitleStreamIndex = subtitleStreamIndex
            self.maxAudioChannels = maxAudioChannels
            self.itemID = itemID
            self.enableDirectPlay = enableDirectPlay
            self.enableDirectStream = enableDirectStream
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(openToken, forKey: "openToken")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(itemID, forKey: "itemId")
            encoder.encode(enableDirectPlay, forKey: "enableDirectPlay")
            encoder.encode(enableDirectStream, forKey: "enableDirectStream")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getAttachment(videoID: String, mediaSourceID: String, index: Int) -> Request<Data> {
        .get("/Videos/\(videoID)/\(mediaSourceID)/Attachments/\(index)")
    }
}

extension Paths {
    static public func getUniversalAudioStream(itemID: String, parameters: GetUniversalAudioStreamParameters? = nil) -> Request<Data> {
        .get("/Audio/\(itemID)/universal", query: parameters?.asQuery)
    }

    public struct GetUniversalAudioStreamParameters {
        public var container: [String]?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var userID: String?
        public var audioCodec: String?
        public var maxAudioChannels: Int?
        public var transcodingAudioChannels: Int?
        public var maxStreamingBitrate: Int?
        public var audioBitRate: Int?
        public var startTimeTicks: Int?
        public var transcodingContainer: String?
        public var transcodingProtocol: String?
        public var maxAudioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var enableRemoteMedia: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var enableRedirection: Bool?

        public init(container: [String]? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, userID: String? = nil, audioCodec: String? = nil, maxAudioChannels: Int? = nil, transcodingAudioChannels: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, startTimeTicks: Int? = nil, transcodingContainer: String? = nil, transcodingProtocol: String? = nil, maxAudioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, enableRemoteMedia: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, enableRedirection: Bool? = nil) {
            self.container = container
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.userID = userID
            self.audioCodec = audioCodec
            self.maxAudioChannels = maxAudioChannels
            self.transcodingAudioChannels = transcodingAudioChannels
            self.maxStreamingBitrate = maxStreamingBitrate
            self.audioBitRate = audioBitRate
            self.startTimeTicks = startTimeTicks
            self.transcodingContainer = transcodingContainer
            self.transcodingProtocol = transcodingProtocol
            self.maxAudioSampleRate = maxAudioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.enableRemoteMedia = enableRemoteMedia
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.enableRedirection = enableRedirection
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(container, forKey: "container")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(transcodingAudioChannels, forKey: "transcodingAudioChannels")
            encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(transcodingContainer, forKey: "transcodingContainer")
            encoder.encode(transcodingProtocol, forKey: "transcodingProtocol")
            encoder.encode(maxAudioSampleRate, forKey: "maxAudioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(enableRemoteMedia, forKey: "enableRemoteMedia")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(enableRedirection, forKey: "enableRedirection")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headUniversalAudioStream(itemID: String, parameters: HeadUniversalAudioStreamParameters? = nil) -> Request<Data> {
        .head("/Audio/\(itemID)/universal", query: parameters?.asQuery)
    }

    public struct HeadUniversalAudioStreamParameters {
        public var container: [String]?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var userID: String?
        public var audioCodec: String?
        public var maxAudioChannels: Int?
        public var transcodingAudioChannels: Int?
        public var maxStreamingBitrate: Int?
        public var audioBitRate: Int?
        public var startTimeTicks: Int?
        public var transcodingContainer: String?
        public var transcodingProtocol: String?
        public var maxAudioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var enableRemoteMedia: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var enableRedirection: Bool?

        public init(container: [String]? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, userID: String? = nil, audioCodec: String? = nil, maxAudioChannels: Int? = nil, transcodingAudioChannels: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, startTimeTicks: Int? = nil, transcodingContainer: String? = nil, transcodingProtocol: String? = nil, maxAudioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, enableRemoteMedia: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, enableRedirection: Bool? = nil) {
            self.container = container
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.userID = userID
            self.audioCodec = audioCodec
            self.maxAudioChannels = maxAudioChannels
            self.transcodingAudioChannels = transcodingAudioChannels
            self.maxStreamingBitrate = maxStreamingBitrate
            self.audioBitRate = audioBitRate
            self.startTimeTicks = startTimeTicks
            self.transcodingContainer = transcodingContainer
            self.transcodingProtocol = transcodingProtocol
            self.maxAudioSampleRate = maxAudioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.enableRemoteMedia = enableRemoteMedia
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.enableRedirection = enableRedirection
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(container, forKey: "container")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(transcodingAudioChannels, forKey: "transcodingAudioChannels")
            encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(transcodingContainer, forKey: "transcodingContainer")
            encoder.encode(transcodingProtocol, forKey: "transcodingProtocol")
            encoder.encode(maxAudioSampleRate, forKey: "maxAudioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(enableRemoteMedia, forKey: "enableRemoteMedia")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(enableRedirection, forKey: "enableRedirection")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getCriticReviews(itemID: String) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Items/\(itemID)/CriticReviews")
    }
}

extension Paths {
    static public func pingPlaybackSession(playSessionID: String) -> Request<Void> {
        .post("/Sessions/Playing/Ping", query: [("playSessionId", playSessionID)])
    }
}

extension Paths {
    static public func getSimilarShows(itemID: String, parameters: GetSimilarShowsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Shows/\(itemID)/Similar", query: parameters?.asQuery)
    }

    public struct GetSimilarShowsParameters {
        public var excludeArtistIDs: [String]?
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?

        public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
            self.excludeArtistIDs = excludeArtistIDs
            self.userID = userID
            self.limit = limit
            self.fields = fields
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getInstantMixFromMusicGenreByName(name: String, parameters: GetInstantMixFromMusicGenreByNameParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/MusicGenres/\(name)/InstantMix", query: parameters?.asQuery)
    }

    public struct GetInstantMixFromMusicGenreByNameParameters {
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.userID = userID
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public var getFirstUser2: Request<JellyfinAPI.StartupUserDto> {
        .get("/Startup/FirstUser")
    }
}

extension Paths {
    static public var getBrandingCss2: Request<Void> {
        .get("/Branding/Css.css")
    }
}

extension Paths {
    static public func syncPlaySetNewQueue(_ body: JellyfinAPI.PlayRequestDto) -> Request<Void> {
        .post("/SyncPlay/SetNewQueue", body: body)
    }
}

extension Paths {
    static public func authenticateUserByName(_ body: JellyfinAPI.AuthenticateUserByName) -> Request<JellyfinAPI.AuthenticationResult> {
        .post("/Users/AuthenticateByName", body: body)
    }
}

extension Paths {
    static public func getPackageInfo(name: String, assemblyGuid: String? = nil) -> Request<JellyfinAPI.PackageInfo> {
        .get("/Packages/\(name)", query: makeGetPackageInfoQuery(assemblyGuid))
    }

    private static func makeGetPackageInfoQuery(_ assemblyGuid: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(assemblyGuid, forKey: "assemblyGuid")
        return encoder.items
    }
}

extension Paths {
    static public func syncPlayRemoveFromPlaylist(_ body: JellyfinAPI.RemoveFromPlaylistRequestDto) -> Request<Void> {
        .post("/SyncPlay/RemoveFromPlaylist", body: body)
    }
}

extension Paths {
    static public func getRecording(recordingID: String, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/LiveTv/Recordings/\(recordingID)", query: makeGetRecordingQuery(userID))
    }

    private static func makeGetRecordingQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func deleteRecording(recordingID: String) -> Request<Void> {
        .delete("/LiveTv/Recordings/\(recordingID)")
    }
}

extension Paths {
    static public func addTunerHost(_ body: JellyfinAPI.TunerHostInfo? = nil) -> Request<JellyfinAPI.TunerHostInfo> {
        .post("/LiveTv/TunerHosts", body: body)
    }
}

extension Paths {
    static public func deleteTunerHost(id: String? = nil) -> Request<Void> {
        .delete("/LiveTv/TunerHosts", query: makeDeleteTunerHostQuery(id))
    }

    private static func makeDeleteTunerHostQuery(_ id: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(id, forKey: "id")
        return encoder.items
    }
}

extension Paths {
    static public func getLiveHlsStream(itemID: String, parameters: GetLiveHlsStreamParameters? = nil) -> Request<Data> {
        .get("/Videos/\(itemID)/live.m3u8", query: parameters?.asQuery)
    }

    public struct GetLiveHlsStreamParameters {
        public var container: String?
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var enableSubtitlesInManifest: Bool?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, enableSubtitlesInManifest: Bool? = nil) {
            self.container = container
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.enableSubtitlesInManifest = enableSubtitlesInManifest
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(container, forKey: "container")
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(enableSubtitlesInManifest, forKey: "enableSubtitlesInManifest")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getRemoteImageProviders(itemID: String) -> Request<[JellyfinAPI.ImageProviderInfo]> {
        .get("/Items/\(itemID)/RemoteImages/Providers")
    }
}

extension Paths {
    static public var refreshLibrary: Request<Void> {
        .post("/Library/Refresh")
    }
}

extension Paths {
    static public func getInstantMixFromSong(id: String, parameters: GetInstantMixFromSongParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Songs/\(id)/InstantMix", query: parameters?.asQuery)
    }

    public struct GetInstantMixFromSongParameters {
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.userID = userID
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getNextUp(parameters: GetNextUpParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Shows/NextUp", query: parameters?.asQuery)
    }

    public struct GetNextUpParameters {
        public var userID: String?
        public var startIndex: Int?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var seriesID: String?
        public var parentID: String?
        public var enableImges: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var enableUserData: Bool?
        public var enableTotalRecordCount: Bool?
        public var isDisableFirstEpisode: Bool?

        public init(userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, seriesID: String? = nil, parentID: String? = nil, enableImges: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil, enableTotalRecordCount: Bool? = nil, isDisableFirstEpisode: Bool? = nil) {
            self.userID = userID
            self.startIndex = startIndex
            self.limit = limit
            self.fields = fields
            self.seriesID = seriesID
            self.parentID = parentID
            self.enableImges = enableImges
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.enableUserData = enableUserData
            self.enableTotalRecordCount = enableTotalRecordCount
            self.isDisableFirstEpisode = isDisableFirstEpisode
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(seriesID, forKey: "seriesId")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(enableImges, forKey: "enableImges")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            encoder.encode(isDisableFirstEpisode, forKey: "disableFirstEpisode")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getVideoStream(itemID: String, parameters: GetVideoStreamParameters? = nil) -> Request<Data> {
        .get("/Videos/\(itemID)/stream", query: parameters?.asQuery)
    }

    public struct GetVideoStreamParameters {
        public var container: String?
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.container = container
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(container, forKey: "container")
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headVideoStream(itemID: String, parameters: HeadVideoStreamParameters? = nil) -> Request<Data> {
        .head("/Videos/\(itemID)/stream", query: parameters?.asQuery)
    }

    public struct HeadVideoStreamParameters {
        public var container: String?
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(container: String? = nil, isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.container = container
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(container, forKey: "container")
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func authorize(code: String) -> Request<Data> {
        .post("/QuickConnect/Authorize", query: [("code", code)])
    }
}

extension Paths {
    static public func setUnread(userID: String) -> Request<Void> {
        .post("/Notifications/\(userID)/Unread")
    }
}

extension Paths {
    static public func cancelPackageInstallation(packageID: String) -> Request<Void> {
        .delete("/Packages/Installing/\(packageID)")
    }
}

extension Paths {
    static public func getInstantMixFromArtists(id: String, parameters: GetInstantMixFromArtistsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Artists/\(id)/InstantMix", query: parameters?.asQuery)
    }

    public struct GetInstantMixFromArtistsParameters {
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.userID = userID
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func syncPlayCreateGroup(_ body: JellyfinAPI.NewGroupRequestDto) -> Request<Void> {
        .post("/SyncPlay/New", body: body)
    }
}

extension Paths {
    static public func getRatingImage(theme: String, name: String) -> Request<Data> {
        .get("/Images/Ratings/\(theme)/\(name)")
    }
}

extension Paths {
    static public func getLineups(parameters: GetLineupsParameters? = nil) -> Request<[JellyfinAPI.NameIDPair]> {
        .get("/LiveTv/ListingProviders/Lineups", query: parameters?.asQuery)
    }

    public struct GetLineupsParameters {
        public var id: String?
        public var type: String?
        public var location: String?
        public var country: String?

        public init(id: String? = nil, type: String? = nil, location: String? = nil, country: String? = nil) {
            self.id = id
            self.type = type
            self.location = location
            self.country = country
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            encoder.encode(type, forKey: "type")
            encoder.encode(location, forKey: "location")
            encoder.encode(country, forKey: "country")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getMusicAlbumRemoteSearchResults(_ body: JellyfinAPI.AlbumInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
        .post("/Items/RemoteSearch/MusicAlbum", body: body)
    }
}

extension Paths {
    static public func getIcon(fileName: String) -> Request<Data> {
        .get("/Dlna/icons/\(fileName)")
    }
}

extension Paths {
    static public func getAlbumArtists(parameters: GetAlbumArtistsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Artists/AlbumArtists", query: parameters?.asQuery)
    }

    public struct GetAlbumArtistsParameters {
        public var minCommunityRating: Double?
        public var startIndex: Int?
        public var limit: Int?
        public var searchTerm: String?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var excludeItemTypes: [String]?
        public var includeItemTypes: [String]?
        public var filters: [JellyfinAPI.ItemFilter]?
        public var isFavorite: Bool?
        public var mediaTypes: [String]?
        public var genres: [String]?
        public var genreIDs: [String]?
        public var officialRatings: [String]?
        public var tags: [String]?
        public var years: [Int]?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var person: String?
        public var personIDs: [String]?
        public var personTypes: [String]?
        public var studios: [String]?
        public var studioIDs: [String]?
        public var userID: String?
        public var nameStartsWithOrGreater: String?
        public var nameStartsWith: String?
        public var nameLessThan: String?
        public var enableImages: Bool?
        public var enableTotalRecordCount: Bool?

        public init(minCommunityRating: Double? = nil, startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, genres: [String]? = nil, genreIDs: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, studioIDs: [String]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
            self.minCommunityRating = minCommunityRating
            self.startIndex = startIndex
            self.limit = limit
            self.searchTerm = searchTerm
            self.parentID = parentID
            self.fields = fields
            self.excludeItemTypes = excludeItemTypes
            self.includeItemTypes = includeItemTypes
            self.filters = filters
            self.isFavorite = isFavorite
            self.mediaTypes = mediaTypes
            self.genres = genres
            self.genreIDs = genreIDs
            self.officialRatings = officialRatings
            self.tags = tags
            self.years = years
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.person = person
            self.personIDs = personIDs
            self.personTypes = personTypes
            self.studios = studios
            self.studioIDs = studioIDs
            self.userID = userID
            self.nameStartsWithOrGreater = nameStartsWithOrGreater
            self.nameStartsWith = nameStartsWith
            self.nameLessThan = nameLessThan
            self.enableImages = enableImages
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(minCommunityRating, forKey: "minCommunityRating")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(filters, forKey: "filters")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(mediaTypes, forKey: "mediaTypes")
            encoder.encode(genres, forKey: "genres")
            encoder.encode(genreIDs, forKey: "genreIds")
            encoder.encode(officialRatings, forKey: "officialRatings")
            encoder.encode(tags, forKey: "tags")
            encoder.encode(years, forKey: "years")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(person, forKey: "person")
            encoder.encode(personIDs, forKey: "personIds")
            encoder.encode(personTypes, forKey: "personTypes")
            encoder.encode(studios, forKey: "studios")
            encoder.encode(studioIDs, forKey: "studioIds")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
            encoder.encode(nameStartsWith, forKey: "nameStartsWith")
            encoder.encode(nameLessThan, forKey: "nameLessThan")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getArtistImage(name: String, imageType: String, imageIndex: Int, parameters: GetArtistImageParameters? = nil) -> Request<Data> {
        .get("/Artists/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct GetArtistImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headArtistImage(name: String, imageType: String, imageIndex: Int, parameters: HeadArtistImageParameters? = nil) -> Request<Data> {
        .head("/Artists/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct HeadArtistImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func syncPlayMovePlaylistItem(_ body: JellyfinAPI.MovePlaylistItemRequestDto) -> Request<Void> {
        .post("/SyncPlay/MovePlaylistItem", body: body)
    }
}

extension Paths {
    static public var getBrandingCss: Request<String> {
        .get("/Branding/Css")
    }
}

extension Paths {
    static public func getSimilarMovies(itemID: String, parameters: GetSimilarMoviesParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Movies/\(itemID)/Similar", query: parameters?.asQuery)
    }

    public struct GetSimilarMoviesParameters {
        public var excludeArtistIDs: [String]?
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?

        public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
            self.excludeArtistIDs = excludeArtistIDs
            self.userID = userID
            self.limit = limit
            self.fields = fields
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths {
    static public var getPhysicalPaths: Request<[String]> {
        .get("/Library/PhysicalPaths")
    }
}

extension Paths {
    static public func getUsers(isHidden: Bool? = nil, isDisabled: Bool? = nil) -> Request<[JellyfinAPI.UserDto]> {
        .get("/Users", query: makeGetUsersQuery(isHidden, isDisabled))
    }

    private static func makeGetUsersQuery(_ isHidden: Bool?, _ isDisabled: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(isHidden, forKey: "isHidden")
        encoder.encode(isDisabled, forKey: "isDisabled")
        return encoder.items
    }
}

extension Paths {
    static public func getHlsAudioSegment(itemID: String, playlistID: String, segmentID: Int, container: String, parameters: GetHlsAudioSegmentParameters? = nil) -> Request<Data> {
        .get("/Audio/\(itemID)/hls1/\(playlistID)/\(segmentID).\(container)", query: parameters?.asQuery)
    }

    public struct GetHlsAudioSegmentParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String?
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var maxStreamingBitrate: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String? = nil, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, maxStreamingBitrate: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.maxStreamingBitrate = maxStreamingBitrate
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getInstantMixFromMusicGenreByID(id: String, parameters: GetInstantMixFromMusicGenreByIDParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/MusicGenres/\(id)/InstantMix", query: parameters?.asQuery)
    }

    public struct GetInstantMixFromMusicGenreByIDParameters {
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.userID = userID
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getStudioImageByIndex(name: String, imageType: String, imageIndex: Int, parameters: GetStudioImageByIndexParameters? = nil) -> Request<Data> {
        .get("/Studios/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct GetStudioImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headStudioImageByIndex(name: String, imageType: String, imageIndex: Int, parameters: HeadStudioImageByIndexParameters? = nil) -> Request<Data> {
        .head("/Studios/\(name)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct HeadStudioImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func postUserImageByIndex(userID: String, imageType: String, index: Int, _ body: Data? = nil) -> Request<Void> {
        .post("/Users/\(userID)/Images/\(imageType)/\(index)", body: body)
    }
}

extension Paths {
    static public func deleteUserImageByIndex(userID: String, imageType: String, index: Int) -> Request<Void> {
        .delete("/Users/\(userID)/Images/\(imageType)/\(index)")
    }
}

extension Paths {
    static public func setRemoteAccess(_ body: JellyfinAPI.StartupRemoteAccessDto) -> Request<Void> {
        .post("/Startup/RemoteAccess", body: body)
    }
}

extension Paths {
    static public func addListingProvider(parameters: AddListingProviderParameters? = nil, _ body: JellyfinAPI.ListingsProviderInfo? = nil) -> Request<JellyfinAPI.ListingsProviderInfo> {
        .post("/LiveTv/ListingProviders", query: parameters?.asQuery, body: body)
    }

    public struct AddListingProviderParameters {
        public var pw: String?
        public var isValidateListings: Bool?
        public var isValidateLogin: Bool?

        public init(pw: String? = nil, isValidateListings: Bool? = nil, isValidateLogin: Bool? = nil) {
            self.pw = pw
            self.isValidateListings = isValidateListings
            self.isValidateLogin = isValidateLogin
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pw, forKey: "pw")
            encoder.encode(isValidateListings, forKey: "validateListings")
            encoder.encode(isValidateLogin, forKey: "validateLogin")
            return encoder.items
        }
    }
}

extension Paths {
    static public func deleteListingProvider(id: String? = nil) -> Request<Void> {
        .delete("/LiveTv/ListingProviders", query: makeDeleteListingProviderQuery(id))
    }

    private static func makeDeleteListingProviderQuery(_ id: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(id, forKey: "id")
        return encoder.items
    }
}

extension Paths {
    static public func onPlaybackStart(userID: String, itemID: String, parameters: OnPlaybackStartParameters? = nil) -> Request<Void> {
        .post("/Users/\(userID)/PlayingItems/\(itemID)", query: parameters?.asQuery)
    }

    public struct OnPlaybackStartParameters {
        public var mediaSourceID: String?
        public var audioStreamIndex: Int?
        public var subtitleStreamIndex: Int?
        public var playMethod: PlayMethod?
        public var liveStreamID: String?
        public var playSessionID: String?
        public var canSeek: Bool?

        public typealias PlayMethod = JellyfinAPI.PlayMethod

        public init(mediaSourceID: String? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, playMethod: PlayMethod? = nil, liveStreamID: String? = nil, playSessionID: String? = nil, canSeek: Bool? = nil) {
            self.mediaSourceID = mediaSourceID
            self.audioStreamIndex = audioStreamIndex
            self.subtitleStreamIndex = subtitleStreamIndex
            self.playMethod = playMethod
            self.liveStreamID = liveStreamID
            self.playSessionID = playSessionID
            self.canSeek = canSeek
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(playMethod, forKey: "playMethod")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(canSeek, forKey: "canSeek")
            return encoder.items
        }
    }
}

extension Paths {
    static public func onPlaybackStopped(userID: String, itemID: String, parameters: OnPlaybackStoppedParameters? = nil) -> Request<Void> {
        .delete("/Users/\(userID)/PlayingItems/\(itemID)", query: parameters?.asQuery)
    }

    public struct OnPlaybackStoppedParameters {
        public var mediaSourceID: String?
        public var nextMediaType: String?
        public var positionTicks: Int?
        public var liveStreamID: String?
        public var playSessionID: String?

        public init(mediaSourceID: String? = nil, nextMediaType: String? = nil, positionTicks: Int? = nil, liveStreamID: String? = nil, playSessionID: String? = nil) {
            self.mediaSourceID = mediaSourceID
            self.nextMediaType = nextMediaType
            self.positionTicks = positionTicks
            self.liveStreamID = liveStreamID
            self.playSessionID = playSessionID
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(nextMediaType, forKey: "nextMediaType")
            encoder.encode(positionTicks, forKey: "positionTicks")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getSimilarTrailers(itemID: String, parameters: GetSimilarTrailersParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Trailers/\(itemID)/Similar", query: parameters?.asQuery)
    }

    public struct GetSimilarTrailersParameters {
        public var excludeArtistIDs: [String]?
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?

        public init(excludeArtistIDs: [String]? = nil, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil) {
            self.excludeArtistIDs = excludeArtistIDs
            self.userID = userID
            self.limit = limit
            self.fields = fields
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getIconID(serverID: String, fileName: String) -> Request<Data> {
        .get("/Dlna/\(serverID)/icons/\(fileName)")
    }
}

extension Paths {
    static public func reportViewing(sessionID: String? = nil, itemID: String) -> Request<Void> {
        .post("/Sessions/Viewing", query: makeReportViewingQuery(sessionID, itemID))
    }

    private static func makeReportViewingQuery(_ sessionID: String?, _ itemID: String) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(sessionID, forKey: "sessionId")
        encoder.encode(itemID, forKey: "itemId")
        return encoder.items
    }
}

extension Paths {
    static public func renameVirtualFolder(parameters: RenameVirtualFolderParameters? = nil) -> Request<Void> {
        .post("/Library/VirtualFolders/Name", query: parameters?.asQuery)
    }

    public struct RenameVirtualFolderParameters {
        public var name: String?
        public var newName: String?
        public var isRefreshLibrary: Bool?

        public init(name: String? = nil, newName: String? = nil, isRefreshLibrary: Bool? = nil) {
            self.name = name
            self.newName = newName
            self.isRefreshLibrary = isRefreshLibrary
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(name, forKey: "name")
            encoder.encode(newName, forKey: "newName")
            encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
            return encoder.items
        }
    }
}

extension Paths {
    static public func revokeKey(key: String) -> Request<Void> {
        .delete("/Auth/Keys/\(key)")
    }
}

extension Paths {
    static public func disablePlugin(pluginID: String, version: String) -> Request<Void> {
        .post("/Plugins/\(pluginID)/\(version)/Disable")
    }
}

extension Paths {
    static public func getPluginConfiguration(pluginID: String) -> Request<Void> {
        .get("/Plugins/\(pluginID)/Configuration")
    }
}

extension Paths {
    static public func updatePluginConfiguration(pluginID: String) -> Request<Void> {
        .post("/Plugins/\(pluginID)/Configuration")
    }
}

extension Paths {
    static public var getSystemInfo: Request<JellyfinAPI.SystemInfo> {
        .get("/System/Info")
    }
}

extension Paths {
    static public func getLatestMedia(userID: String, parameters: GetLatestMediaParameters? = nil) -> Request<[JellyfinAPI.BaseItemDto]> {
        .get("/Users/\(userID)/Items/Latest", query: parameters?.asQuery)
    }

    public struct GetLatestMediaParameters {
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var includeItemTypes: [String]?
        public var isPlayed: Bool?
        public var enableImages: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var enableUserData: Bool?
        public var limit: Int?
        public var isGroupItems: Bool?

        public init(parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, includeItemTypes: [String]? = nil, isPlayed: Bool? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil, limit: Int? = nil, isGroupItems: Bool? = nil) {
            self.parentID = parentID
            self.fields = fields
            self.includeItemTypes = includeItemTypes
            self.isPlayed = isPlayed
            self.enableImages = enableImages
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.enableUserData = enableUserData
            self.limit = limit
            self.isGroupItems = isGroupItems
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(isPlayed, forKey: "isPlayed")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isGroupItems, forKey: "groupItems")
            return encoder.items
        }
    }
}

extension Paths {
    static public var restartApplication: Request<Void> {
        .post("/System/Restart")
    }
}

extension Paths {
    static public func syncPlayQueue(_ body: JellyfinAPI.QueueRequestDto) -> Request<Void> {
        .post("/SyncPlay/Queue", body: body)
    }
}

extension Paths {
    static public func getUserImage(userID: String, imageType: String, parameters: GetUserImageParameters? = nil) -> Request<Data> {
        .get("/Users/\(userID)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct GetUserImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func postUserImage(userID: String, imageType: String, index: Int? = nil, _ body: Data? = nil) -> Request<Void> {
        .post("/Users/\(userID)/Images/\(imageType)", query: makePostUserImageQuery(index), body: body)
    }

    private static func makePostUserImageQuery(_ index: Int?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(index, forKey: "index")
        return encoder.items
    }
}

extension Paths {
    static public func deleteUserImage(userID: String, imageType: String, index: Int? = nil) -> Request<Void> {
        .delete("/Users/\(userID)/Images/\(imageType)", query: makeDeleteUserImageQuery(index))
    }

    private static func makeDeleteUserImageQuery(_ index: Int?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(index, forKey: "index")
        return encoder.items
    }
}

extension Paths {
    static public func headUserImage(userID: String, imageType: String, parameters: HeadUserImageParameters? = nil) -> Request<Data> {
        .head("/Users/\(userID)/Images/\(imageType)", query: parameters?.asQuery)
    }

    public struct HeadUserImageParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?
        public var imageIndex: Int?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil, imageIndex: Int? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
            self.imageIndex = imageIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            encoder.encode(imageIndex, forKey: "imageIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func downloadRemoteSubtitles(itemID: String, subtitleID: String) -> Request<Void> {
        .post("/Items/\(itemID)/RemoteSearch/Subtitles/\(subtitleID)")
    }
}

extension Paths {
    static public var getDefaultDirectoryBrowser: Request<JellyfinAPI.DefaultDirectoryBrowserInfoDto> {
        .get("/Environment/DefaultDirectoryBrowser")
    }
}

extension Paths {
    static public func sendPlaystateCommand(sessionID: String, command: String, seekPositionTicks: Int? = nil, controllingUserID: String? = nil) -> Request<Void> {
        .post("/Sessions/\(sessionID)/Playing/\(command)", query: makeSendPlaystateCommandQuery(seekPositionTicks, controllingUserID))
    }

    private static func makeSendPlaystateCommandQuery(_ seekPositionTicks: Int?, _ controllingUserID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(seekPositionTicks, forKey: "seekPositionTicks")
        encoder.encode(controllingUserID, forKey: "controllingUserId")
        return encoder.items
    }
}

extension Paths {
    static public func getTrailers(parameters: GetTrailersParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Trailers", query: parameters?.asQuery)
    }

    public struct GetTrailersParameters {
        public var userID: String?
        public var maxOfficialRating: String?
        public var hasThemeSong: Bool?
        public var hasThemeVideo: Bool?
        public var hasSubtitles: Bool?
        public var hasSpecialFeature: Bool?
        public var hasTrailer: Bool?
        public var adjacentTo: String?
        public var parentIndexNumber: Int?
        public var hasParentalRating: Bool?
        public var isHd: Bool?
        public var isIs4K: Bool?
        public var locationTypes: [JellyfinAPI.LocationType]?
        public var excludeLocationTypes: [JellyfinAPI.LocationType]?
        public var isMissing: Bool?
        public var isUnaired: Bool?
        public var minCommunityRating: Double?
        public var minCriticRating: Double?
        public var minPremiereDate: Date?
        public var minDateLastSaved: Date?
        public var minDateLastSavedForUser: Date?
        public var maxPremiereDate: Date?
        public var hasOverview: Bool?
        public var hasImdbID: Bool?
        public var hasTmdbID: Bool?
        public var hasTvdbID: Bool?
        public var excludeItemIDs: [String]?
        public var startIndex: Int?
        public var limit: Int?
        public var isRecursive: Bool?
        public var searchTerm: String?
        public var sortOrder: [JellyfinAPI.SortOrder]?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var excludeItemTypes: [String]?
        public var filters: [JellyfinAPI.ItemFilter]?
        public var isFavorite: Bool?
        public var mediaTypes: [String]?
        public var imageTypes: [JellyfinAPI.ImageType]?
        public var sortBy: [String]?
        public var isPlayed: Bool?
        public var genres: [String]?
        public var officialRatings: [String]?
        public var tags: [String]?
        public var years: [Int]?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var person: String?
        public var personIDs: [String]?
        public var personTypes: [String]?
        public var studios: [String]?
        public var artists: [String]?
        public var excludeArtistIDs: [String]?
        public var artistIDs: [String]?
        public var albumArtistIDs: [String]?
        public var contributingArtistIDs: [String]?
        public var albums: [String]?
        public var albumIDs: [String]?
        public var ids: [String]?
        public var videoTypes: [JellyfinAPI.VideoType]?
        public var minOfficialRating: String?
        public var isLocked: Bool?
        public var isPlaceHolder: Bool?
        public var hasOfficialRating: Bool?
        public var isCollapseBoxSetItems: Bool?
        public var minWidth: Int?
        public var minHeight: Int?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var isIs3D: Bool?
        public var seriesStatus: [JellyfinAPI.SeriesStatus]?
        public var nameStartsWithOrGreater: String?
        public var nameStartsWith: String?
        public var nameLessThan: String?
        public var studioIDs: [String]?
        public var genreIDs: [String]?
        public var enableTotalRecordCount: Bool?
        public var enableImages: Bool?

        public init(userID: String? = nil, maxOfficialRating: String? = nil, hasThemeSong: Bool? = nil, hasThemeVideo: Bool? = nil, hasSubtitles: Bool? = nil, hasSpecialFeature: Bool? = nil, hasTrailer: Bool? = nil, adjacentTo: String? = nil, parentIndexNumber: Int? = nil, hasParentalRating: Bool? = nil, isHd: Bool? = nil, isIs4K: Bool? = nil, locationTypes: [JellyfinAPI.LocationType]? = nil, excludeLocationTypes: [JellyfinAPI.LocationType]? = nil, isMissing: Bool? = nil, isUnaired: Bool? = nil, minCommunityRating: Double? = nil, minCriticRating: Double? = nil, minPremiereDate: Date? = nil, minDateLastSaved: Date? = nil, minDateLastSavedForUser: Date? = nil, maxPremiereDate: Date? = nil, hasOverview: Bool? = nil, hasImdbID: Bool? = nil, hasTmdbID: Bool? = nil, hasTvdbID: Bool? = nil, excludeItemIDs: [String]? = nil, startIndex: Int? = nil, limit: Int? = nil, isRecursive: Bool? = nil, searchTerm: String? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, imageTypes: [JellyfinAPI.ImageType]? = nil, sortBy: [String]? = nil, isPlayed: Bool? = nil, genres: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, artists: [String]? = nil, excludeArtistIDs: [String]? = nil, artistIDs: [String]? = nil, albumArtistIDs: [String]? = nil, contributingArtistIDs: [String]? = nil, albums: [String]? = nil, albumIDs: [String]? = nil, ids: [String]? = nil, videoTypes: [JellyfinAPI.VideoType]? = nil, minOfficialRating: String? = nil, isLocked: Bool? = nil, isPlaceHolder: Bool? = nil, hasOfficialRating: Bool? = nil, isCollapseBoxSetItems: Bool? = nil, minWidth: Int? = nil, minHeight: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, isIs3D: Bool? = nil, seriesStatus: [JellyfinAPI.SeriesStatus]? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, studioIDs: [String]? = nil, genreIDs: [String]? = nil, enableTotalRecordCount: Bool? = nil, enableImages: Bool? = nil) {
            self.userID = userID
            self.maxOfficialRating = maxOfficialRating
            self.hasThemeSong = hasThemeSong
            self.hasThemeVideo = hasThemeVideo
            self.hasSubtitles = hasSubtitles
            self.hasSpecialFeature = hasSpecialFeature
            self.hasTrailer = hasTrailer
            self.adjacentTo = adjacentTo
            self.parentIndexNumber = parentIndexNumber
            self.hasParentalRating = hasParentalRating
            self.isHd = isHd
            self.isIs4K = isIs4K
            self.locationTypes = locationTypes
            self.excludeLocationTypes = excludeLocationTypes
            self.isMissing = isMissing
            self.isUnaired = isUnaired
            self.minCommunityRating = minCommunityRating
            self.minCriticRating = minCriticRating
            self.minPremiereDate = minPremiereDate
            self.minDateLastSaved = minDateLastSaved
            self.minDateLastSavedForUser = minDateLastSavedForUser
            self.maxPremiereDate = maxPremiereDate
            self.hasOverview = hasOverview
            self.hasImdbID = hasImdbID
            self.hasTmdbID = hasTmdbID
            self.hasTvdbID = hasTvdbID
            self.excludeItemIDs = excludeItemIDs
            self.startIndex = startIndex
            self.limit = limit
            self.isRecursive = isRecursive
            self.searchTerm = searchTerm
            self.sortOrder = sortOrder
            self.parentID = parentID
            self.fields = fields
            self.excludeItemTypes = excludeItemTypes
            self.filters = filters
            self.isFavorite = isFavorite
            self.mediaTypes = mediaTypes
            self.imageTypes = imageTypes
            self.sortBy = sortBy
            self.isPlayed = isPlayed
            self.genres = genres
            self.officialRatings = officialRatings
            self.tags = tags
            self.years = years
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.person = person
            self.personIDs = personIDs
            self.personTypes = personTypes
            self.studios = studios
            self.artists = artists
            self.excludeArtistIDs = excludeArtistIDs
            self.artistIDs = artistIDs
            self.albumArtistIDs = albumArtistIDs
            self.contributingArtistIDs = contributingArtistIDs
            self.albums = albums
            self.albumIDs = albumIDs
            self.ids = ids
            self.videoTypes = videoTypes
            self.minOfficialRating = minOfficialRating
            self.isLocked = isLocked
            self.isPlaceHolder = isPlaceHolder
            self.hasOfficialRating = hasOfficialRating
            self.isCollapseBoxSetItems = isCollapseBoxSetItems
            self.minWidth = minWidth
            self.minHeight = minHeight
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.isIs3D = isIs3D
            self.seriesStatus = seriesStatus
            self.nameStartsWithOrGreater = nameStartsWithOrGreater
            self.nameStartsWith = nameStartsWith
            self.nameLessThan = nameLessThan
            self.studioIDs = studioIDs
            self.genreIDs = genreIDs
            self.enableTotalRecordCount = enableTotalRecordCount
            self.enableImages = enableImages
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(maxOfficialRating, forKey: "maxOfficialRating")
            encoder.encode(hasThemeSong, forKey: "hasThemeSong")
            encoder.encode(hasThemeVideo, forKey: "hasThemeVideo")
            encoder.encode(hasSubtitles, forKey: "hasSubtitles")
            encoder.encode(hasSpecialFeature, forKey: "hasSpecialFeature")
            encoder.encode(hasTrailer, forKey: "hasTrailer")
            encoder.encode(adjacentTo, forKey: "adjacentTo")
            encoder.encode(parentIndexNumber, forKey: "parentIndexNumber")
            encoder.encode(hasParentalRating, forKey: "hasParentalRating")
            encoder.encode(isHd, forKey: "isHd")
            encoder.encode(isIs4K, forKey: "is4K")
            encoder.encode(locationTypes, forKey: "locationTypes")
            encoder.encode(excludeLocationTypes, forKey: "excludeLocationTypes")
            encoder.encode(isMissing, forKey: "isMissing")
            encoder.encode(isUnaired, forKey: "isUnaired")
            encoder.encode(minCommunityRating, forKey: "minCommunityRating")
            encoder.encode(minCriticRating, forKey: "minCriticRating")
            encoder.encode(minPremiereDate, forKey: "minPremiereDate")
            encoder.encode(minDateLastSaved, forKey: "minDateLastSaved")
            encoder.encode(minDateLastSavedForUser, forKey: "minDateLastSavedForUser")
            encoder.encode(maxPremiereDate, forKey: "maxPremiereDate")
            encoder.encode(hasOverview, forKey: "hasOverview")
            encoder.encode(hasImdbID, forKey: "hasImdbId")
            encoder.encode(hasTmdbID, forKey: "hasTmdbId")
            encoder.encode(hasTvdbID, forKey: "hasTvdbId")
            encoder.encode(excludeItemIDs, forKey: "excludeItemIds")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isRecursive, forKey: "recursive")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(sortOrder, forKey: "sortOrder")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(filters, forKey: "filters")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(mediaTypes, forKey: "mediaTypes")
            encoder.encode(imageTypes, forKey: "imageTypes")
            encoder.encode(sortBy, forKey: "sortBy")
            encoder.encode(isPlayed, forKey: "isPlayed")
            encoder.encode(genres, forKey: "genres")
            encoder.encode(officialRatings, forKey: "officialRatings")
            encoder.encode(tags, forKey: "tags")
            encoder.encode(years, forKey: "years")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(person, forKey: "person")
            encoder.encode(personIDs, forKey: "personIds")
            encoder.encode(personTypes, forKey: "personTypes")
            encoder.encode(studios, forKey: "studios")
            encoder.encode(artists, forKey: "artists")
            encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
            encoder.encode(artistIDs, forKey: "artistIds")
            encoder.encode(albumArtistIDs, forKey: "albumArtistIds")
            encoder.encode(contributingArtistIDs, forKey: "contributingArtistIds")
            encoder.encode(albums, forKey: "albums")
            encoder.encode(albumIDs, forKey: "albumIds")
            encoder.encode(ids, forKey: "ids")
            encoder.encode(videoTypes, forKey: "videoTypes")
            encoder.encode(minOfficialRating, forKey: "minOfficialRating")
            encoder.encode(isLocked, forKey: "isLocked")
            encoder.encode(isPlaceHolder, forKey: "isPlaceHolder")
            encoder.encode(hasOfficialRating, forKey: "hasOfficialRating")
            encoder.encode(isCollapseBoxSetItems, forKey: "collapseBoxSetItems")
            encoder.encode(minWidth, forKey: "minWidth")
            encoder.encode(minHeight, forKey: "minHeight")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(isIs3D, forKey: "is3D")
            encoder.encode(seriesStatus, forKey: "seriesStatus")
            encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
            encoder.encode(nameStartsWith, forKey: "nameStartsWith")
            encoder.encode(nameLessThan, forKey: "nameLessThan")
            encoder.encode(studioIDs, forKey: "studioIds")
            encoder.encode(genreIDs, forKey: "genreIds")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            encoder.encode(enableImages, forKey: "enableImages")
            return encoder.items
        }
    }
}

extension Paths {
    static public var getMediaInfoImages: Request<[JellyfinAPI.ImageByNameInfo]> {
        .get("/Images/MediaInfo")
    }
}

extension Paths {
    static public func getArtistByName(name: String, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/Artists/\(name)", query: makeGetArtistByNameQuery(userID))
    }

    private static func makeGetArtistByNameQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func getContentDirectory3(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/ContentDirectory/ContentDirectory.xml")
    }
}

extension Paths {
    static public var getCultures: Request<[JellyfinAPI.CultureDto]> {
        .get("/Localization/Cultures")
    }
}

extension Paths {
    static public func updateItem(itemID: String, _ body: JellyfinAPI.BaseItemDto) -> Request<Void> {
        .post("/Items/\(itemID)", body: body)
    }
}

extension Paths {
    static public func deleteItem(itemID: String) -> Request<Void> {
        .delete("/Items/\(itemID)")
    }
}

extension Paths {
    static public func getHlsPlaylistLegacy(itemID: String, playlistID: String) -> Request<Data> {
        .get("/Videos/\(itemID)/hls/\(playlistID)/stream.m3u8")
    }
}

extension Paths {
    static public func getThemeVideos(itemID: String, userID: String? = nil, isInheritFromParent: Bool? = nil) -> Request<JellyfinAPI.ThemeMediaResult> {
        .get("/Items/\(itemID)/ThemeVideos", query: makeGetThemeVideosQuery(userID, isInheritFromParent))
    }

    private static func makeGetThemeVideosQuery(_ userID: String?, _ isInheritFromParent: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        encoder.encode(isInheritFromParent, forKey: "inheritFromParent")
        return encoder.items
    }
}

extension Paths {
    static public func getQueryFilters(parameters: GetQueryFiltersParameters? = nil) -> Request<JellyfinAPI.QueryFilters> {
        .get("/Items/Filters2", query: parameters?.asQuery)
    }

    public struct GetQueryFiltersParameters {
        public var userID: String?
        public var parentID: String?
        public var includeItemTypes: [String]?
        public var isAiring: Bool?
        public var isMovie: Bool?
        public var isSports: Bool?
        public var isKids: Bool?
        public var isNews: Bool?
        public var isSeries: Bool?
        public var isRecursive: Bool?

        public init(userID: String? = nil, parentID: String? = nil, includeItemTypes: [String]? = nil, isAiring: Bool? = nil, isMovie: Bool? = nil, isSports: Bool? = nil, isKids: Bool? = nil, isNews: Bool? = nil, isSeries: Bool? = nil, isRecursive: Bool? = nil) {
            self.userID = userID
            self.parentID = parentID
            self.includeItemTypes = includeItemTypes
            self.isAiring = isAiring
            self.isMovie = isMovie
            self.isSports = isSports
            self.isKids = isKids
            self.isNews = isNews
            self.isSeries = isSeries
            self.isRecursive = isRecursive
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(isAiring, forKey: "isAiring")
            encoder.encode(isMovie, forKey: "isMovie")
            encoder.encode(isSports, forKey: "isSports")
            encoder.encode(isKids, forKey: "isKids")
            encoder.encode(isNews, forKey: "isNews")
            encoder.encode(isSeries, forKey: "isSeries")
            encoder.encode(isRecursive, forKey: "recursive")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getPersons(parameters: GetPersonsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Persons", query: parameters?.asQuery)
    }

    public struct GetPersonsParameters {
        public var limit: Int?
        public var searchTerm: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var filters: [JellyfinAPI.ItemFilter]?
        public var isFavorite: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var excludePersonTypes: [String]?
        public var personTypes: [String]?
        public var appearsInItemID: String?
        public var userID: String?
        public var enableImages: Bool?

        public init(limit: Int? = nil, searchTerm: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, excludePersonTypes: [String]? = nil, personTypes: [String]? = nil, appearsInItemID: String? = nil, userID: String? = nil, enableImages: Bool? = nil) {
            self.limit = limit
            self.searchTerm = searchTerm
            self.fields = fields
            self.filters = filters
            self.isFavorite = isFavorite
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.excludePersonTypes = excludePersonTypes
            self.personTypes = personTypes
            self.appearsInItemID = appearsInItemID
            self.userID = userID
            self.enableImages = enableImages
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(filters, forKey: "filters")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(excludePersonTypes, forKey: "excludePersonTypes")
            encoder.encode(personTypes, forKey: "personTypes")
            encoder.encode(appearsInItemID, forKey: "appearsInItemId")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(enableImages, forKey: "enableImages")
            return encoder.items
        }
    }
}

extension Paths {
    static public func syncPlayPing(_ body: JellyfinAPI.PingRequestDto) -> Request<Void> {
        .post("/SyncPlay/Ping", body: body)
    }
}

extension Paths {
    static public var getPublicSystemInfo: Request<JellyfinAPI.PublicSystemInfo> {
        .get("/System/Info/Public")
    }
}

extension Paths {
    static public var getKeys: Request<JellyfinAPI.AuthenticationInfoQueryResult> {
        .get("/Auth/Keys")
    }
}

extension Paths {
    static public func createKey(app: String) -> Request<Void> {
        .post("/Auth/Keys", query: [("app", app)])
    }
}

extension Paths {
    static public func getInstantMixFromArtists2(parameters: GetInstantMixFromArtists2Parameters) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Artists/InstantMix", query: parameters.asQuery)
    }

    public struct GetInstantMixFromArtists2Parameters {
        public var id: String
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(id: String, userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.id = id
            self.userID = userID
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getConnectionManager(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/ConnectionManager")
    }
}

extension Paths {
    static public func updateMediaPath(_ body: JellyfinAPI.UpdateMediaPathRequestDto) -> Request<Void> {
        .post("/Library/VirtualFolders/Paths/Update", body: body)
    }
}

extension Paths {
    static public func getLogEntries(parameters: GetLogEntriesParameters? = nil) -> Request<JellyfinAPI.ActivityLogEntryQueryResult> {
        .get("/System/ActivityLog/Entries", query: parameters?.asQuery)
    }

    public struct GetLogEntriesParameters {
        public var startIndex: Int?
        public var limit: Int?
        public var minDate: Date?
        public var hasUserID: Bool?

        public init(startIndex: Int? = nil, limit: Int? = nil, minDate: Date? = nil, hasUserID: Bool? = nil) {
            self.startIndex = startIndex
            self.limit = limit
            self.minDate = minDate
            self.hasUserID = hasUserID
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(minDate, forKey: "minDate")
            encoder.encode(hasUserID, forKey: "hasUserId")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getMasterHlsVideoPlaylist(itemID: String, parameters: GetMasterHlsVideoPlaylistParameters) -> Request<Data> {
        .get("/Videos/\(itemID)/master.m3u8", query: parameters.asQuery)
    }

    public struct GetMasterHlsVideoPlaylistParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?
        public var enableAdaptiveBitrateStreaming: Bool?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, enableAdaptiveBitrateStreaming: Bool? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
            self.enableAdaptiveBitrateStreaming = enableAdaptiveBitrateStreaming
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            encoder.encode(enableAdaptiveBitrateStreaming, forKey: "enableAdaptiveBitrateStreaming")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headMasterHlsVideoPlaylist(itemID: String, parameters: HeadMasterHlsVideoPlaylistParameters) -> Request<Data> {
        .head("/Videos/\(itemID)/master.m3u8", query: parameters.asQuery)
    }

    public struct HeadMasterHlsVideoPlaylistParameters {
        public var isStatic: Bool?
        public var params: String?
        public var tag: String?
        public var deviceProfileID: String?
        public var playSessionID: String?
        public var segmentContainer: String?
        public var segmentLength: Int?
        public var minSegments: Int?
        public var mediaSourceID: String
        public var deviceID: String?
        public var audioCodec: String?
        public var enableAutoStreamCopy: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?
        public var isBreakOnNonKeyFrames: Bool?
        public var audioSampleRate: Int?
        public var maxAudioBitDepth: Int?
        public var audioBitRate: Int?
        public var audioChannels: Int?
        public var maxAudioChannels: Int?
        public var profile: String?
        public var level: String?
        public var framerate: Double?
        public var maxFramerate: Double?
        public var isCopyTimestamps: Bool?
        public var startTimeTicks: Int?
        public var width: Int?
        public var height: Int?
        public var videoBitRate: Int?
        public var subtitleStreamIndex: Int?
        public var subtitleMethod: SubtitleMethod?
        public var maxRefFrames: Int?
        public var maxVideoBitDepth: Int?
        public var requireAvc: Bool?
        public var isDeInterlace: Bool?
        public var requireNonAnamorphic: Bool?
        public var transcodingMaxAudioChannels: Int?
        public var cpuCoreLimit: Int?
        public var liveStreamID: String?
        public var enableMpegtsM2TsMode: Bool?
        public var videoCodec: String?
        public var subtitleCodec: String?
        public var transcodeReasons: String?
        public var audioStreamIndex: Int?
        public var videoStreamIndex: Int?
        public var context: Context?
        public var streamOptions: StreamOptions?
        public var enableAdaptiveBitrateStreaming: Bool?

        public typealias SubtitleMethod = JellyfinAPI.SubtitleDeliveryMethod

        public typealias Context = JellyfinAPI.EncodingContext

        public typealias StreamOptions = [String: String]

        public init(isStatic: Bool? = nil, params: String? = nil, tag: String? = nil, deviceProfileID: String? = nil, playSessionID: String? = nil, segmentContainer: String? = nil, segmentLength: Int? = nil, minSegments: Int? = nil, mediaSourceID: String, deviceID: String? = nil, audioCodec: String? = nil, enableAutoStreamCopy: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, isBreakOnNonKeyFrames: Bool? = nil, audioSampleRate: Int? = nil, maxAudioBitDepth: Int? = nil, audioBitRate: Int? = nil, audioChannels: Int? = nil, maxAudioChannels: Int? = nil, profile: String? = nil, level: String? = nil, framerate: Double? = nil, maxFramerate: Double? = nil, isCopyTimestamps: Bool? = nil, startTimeTicks: Int? = nil, width: Int? = nil, height: Int? = nil, videoBitRate: Int? = nil, subtitleStreamIndex: Int? = nil, subtitleMethod: SubtitleMethod? = nil, maxRefFrames: Int? = nil, maxVideoBitDepth: Int? = nil, requireAvc: Bool? = nil, isDeInterlace: Bool? = nil, requireNonAnamorphic: Bool? = nil, transcodingMaxAudioChannels: Int? = nil, cpuCoreLimit: Int? = nil, liveStreamID: String? = nil, enableMpegtsM2TsMode: Bool? = nil, videoCodec: String? = nil, subtitleCodec: String? = nil, transcodeReasons: String? = nil, audioStreamIndex: Int? = nil, videoStreamIndex: Int? = nil, context: Context? = nil, streamOptions: StreamOptions? = nil, enableAdaptiveBitrateStreaming: Bool? = nil) {
            self.isStatic = isStatic
            self.params = params
            self.tag = tag
            self.deviceProfileID = deviceProfileID
            self.playSessionID = playSessionID
            self.segmentContainer = segmentContainer
            self.segmentLength = segmentLength
            self.minSegments = minSegments
            self.mediaSourceID = mediaSourceID
            self.deviceID = deviceID
            self.audioCodec = audioCodec
            self.enableAutoStreamCopy = enableAutoStreamCopy
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
            self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
            self.audioSampleRate = audioSampleRate
            self.maxAudioBitDepth = maxAudioBitDepth
            self.audioBitRate = audioBitRate
            self.audioChannels = audioChannels
            self.maxAudioChannels = maxAudioChannels
            self.profile = profile
            self.level = level
            self.framerate = framerate
            self.maxFramerate = maxFramerate
            self.isCopyTimestamps = isCopyTimestamps
            self.startTimeTicks = startTimeTicks
            self.width = width
            self.height = height
            self.videoBitRate = videoBitRate
            self.subtitleStreamIndex = subtitleStreamIndex
            self.subtitleMethod = subtitleMethod
            self.maxRefFrames = maxRefFrames
            self.maxVideoBitDepth = maxVideoBitDepth
            self.requireAvc = requireAvc
            self.isDeInterlace = isDeInterlace
            self.requireNonAnamorphic = requireNonAnamorphic
            self.transcodingMaxAudioChannels = transcodingMaxAudioChannels
            self.cpuCoreLimit = cpuCoreLimit
            self.liveStreamID = liveStreamID
            self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
            self.videoCodec = videoCodec
            self.subtitleCodec = subtitleCodec
            self.transcodeReasons = transcodeReasons
            self.audioStreamIndex = audioStreamIndex
            self.videoStreamIndex = videoStreamIndex
            self.context = context
            self.streamOptions = streamOptions
            self.enableAdaptiveBitrateStreaming = enableAdaptiveBitrateStreaming
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStatic, forKey: "static")
            encoder.encode(params, forKey: "params")
            encoder.encode(tag, forKey: "tag")
            encoder.encode(deviceProfileID, forKey: "deviceProfileId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(segmentContainer, forKey: "segmentContainer")
            encoder.encode(segmentLength, forKey: "segmentLength")
            encoder.encode(minSegments, forKey: "minSegments")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(deviceID, forKey: "deviceId")
            encoder.encode(audioCodec, forKey: "audioCodec")
            encoder.encode(enableAutoStreamCopy, forKey: "enableAutoStreamCopy")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            encoder.encode(isBreakOnNonKeyFrames, forKey: "breakOnNonKeyFrames")
            encoder.encode(audioSampleRate, forKey: "audioSampleRate")
            encoder.encode(maxAudioBitDepth, forKey: "maxAudioBitDepth")
            encoder.encode(audioBitRate, forKey: "audioBitRate")
            encoder.encode(audioChannels, forKey: "audioChannels")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(profile, forKey: "profile")
            encoder.encode(level, forKey: "level")
            encoder.encode(framerate, forKey: "framerate")
            encoder.encode(maxFramerate, forKey: "maxFramerate")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(videoBitRate, forKey: "videoBitRate")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(subtitleMethod, forKey: "subtitleMethod")
            encoder.encode(maxRefFrames, forKey: "maxRefFrames")
            encoder.encode(maxVideoBitDepth, forKey: "maxVideoBitDepth")
            encoder.encode(requireAvc, forKey: "requireAvc")
            encoder.encode(isDeInterlace, forKey: "deInterlace")
            encoder.encode(requireNonAnamorphic, forKey: "requireNonAnamorphic")
            encoder.encode(transcodingMaxAudioChannels, forKey: "transcodingMaxAudioChannels")
            encoder.encode(cpuCoreLimit, forKey: "cpuCoreLimit")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(enableMpegtsM2TsMode, forKey: "enableMpegtsM2TsMode")
            encoder.encode(videoCodec, forKey: "videoCodec")
            encoder.encode(subtitleCodec, forKey: "subtitleCodec")
            encoder.encode(transcodeReasons, forKey: "transcodeReasons")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(videoStreamIndex, forKey: "videoStreamIndex")
            encoder.encode(context, forKey: "context")
            encoder.encode(streamOptions, forKey: "streamOptions")
            encoder.encode(enableAdaptiveBitrateStreaming, forKey: "enableAdaptiveBitrateStreaming")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getPlaybackInfo(itemID: String, userID: String) -> Request<JellyfinAPI.PlaybackInfoResponse> {
        .get("/Items/\(itemID)/PlaybackInfo", query: [("userId", userID)])
    }
}

extension Paths {
    static public func getPostedPlaybackInfo(itemID: String, parameters: GetPostedPlaybackInfoParameters? = nil, _ body: JellyfinAPI.PlaybackInfoDto? = nil) -> Request<JellyfinAPI.PlaybackInfoResponse> {
        .post("/Items/\(itemID)/PlaybackInfo", query: parameters?.asQuery, body: body)
    }

    public struct GetPostedPlaybackInfoParameters {
        public var userID: String?
        public var maxStreamingBitrate: Int?
        public var startTimeTicks: Int?
        public var audioStreamIndex: Int?
        public var subtitleStreamIndex: Int?
        public var maxAudioChannels: Int?
        public var mediaSourceID: String?
        public var liveStreamID: String?
        public var isAutoOpenLiveStream: Bool?
        public var enableDirectPlay: Bool?
        public var enableDirectStream: Bool?
        public var enableTranscoding: Bool?
        public var allowVideoStreamCopy: Bool?
        public var allowAudioStreamCopy: Bool?

        public init(userID: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, mediaSourceID: String? = nil, liveStreamID: String? = nil, isAutoOpenLiveStream: Bool? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, enableTranscoding: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil) {
            self.userID = userID
            self.maxStreamingBitrate = maxStreamingBitrate
            self.startTimeTicks = startTimeTicks
            self.audioStreamIndex = audioStreamIndex
            self.subtitleStreamIndex = subtitleStreamIndex
            self.maxAudioChannels = maxAudioChannels
            self.mediaSourceID = mediaSourceID
            self.liveStreamID = liveStreamID
            self.isAutoOpenLiveStream = isAutoOpenLiveStream
            self.enableDirectPlay = enableDirectPlay
            self.enableDirectStream = enableDirectStream
            self.enableTranscoding = enableTranscoding
            self.allowVideoStreamCopy = allowVideoStreamCopy
            self.allowAudioStreamCopy = allowAudioStreamCopy
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(maxStreamingBitrate, forKey: "maxStreamingBitrate")
            encoder.encode(startTimeTicks, forKey: "startTimeTicks")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(maxAudioChannels, forKey: "maxAudioChannels")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(isAutoOpenLiveStream, forKey: "autoOpenLiveStream")
            encoder.encode(enableDirectPlay, forKey: "enableDirectPlay")
            encoder.encode(enableDirectStream, forKey: "enableDirectStream")
            encoder.encode(enableTranscoding, forKey: "enableTranscoding")
            encoder.encode(allowVideoStreamCopy, forKey: "allowVideoStreamCopy")
            encoder.encode(allowAudioStreamCopy, forKey: "allowAudioStreamCopy")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getUpcomingEpisodes(parameters: GetUpcomingEpisodesParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Shows/Upcoming", query: parameters?.asQuery)
    }

    public struct GetUpcomingEpisodesParameters {
        public var userID: String?
        public var startIndex: Int?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var parentID: String?
        public var enableImges: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var enableUserData: Bool?

        public init(userID: String? = nil, startIndex: Int? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, parentID: String? = nil, enableImges: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, enableUserData: Bool? = nil) {
            self.userID = userID
            self.startIndex = startIndex
            self.limit = limit
            self.fields = fields
            self.parentID = parentID
            self.enableImges = enableImges
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.enableUserData = enableUserData
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(enableImges, forKey: "enableImges")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(enableUserData, forKey: "enableUserData")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getDeviceInfo(id: String) -> Request<JellyfinAPI.DeviceInfo> {
        .get("/Devices/Info", query: [("id", id)])
    }
}

extension Paths {
    static public func getDownload(itemID: String) -> Request<Data> {
        .get("/Items/\(itemID)/Download")
    }
}

extension Paths {
    static public func getDeviceOptions(id: String) -> Request<JellyfinAPI.DeviceOptions> {
        .get("/Devices/Options", query: [("id", id)])
    }
}

extension Paths {
    static public func updateDeviceOptions(id: String, _ body: JellyfinAPI.DeviceOptions) -> Request<Void> {
        .post("/Devices/Options", query: [("id", id)], body: body)
    }
}

extension Paths {
    static public var getFallbackFontList: Request<[JellyfinAPI.FontFile]> {
        .get("/FallbackFont/Fonts")
    }
}

extension Paths {
    static public func play(sessionID: String, parameters: PlayParameters) -> Request<Void> {
        .post("/Sessions/\(sessionID)/Playing", query: parameters.asQuery)
    }

    public struct PlayParameters {
        public var playCommand: PlayCommand
        public var itemIDs: [String]
        public var startPositionTicks: Int?
        public var mediaSourceID: String?
        public var audioStreamIndex: Int?
        public var subtitleStreamIndex: Int?
        public var startIndex: Int?

        public typealias PlayCommand = JellyfinAPI.PlayCommand

        public init(playCommand: PlayCommand, itemIDs: [String], startPositionTicks: Int? = nil, mediaSourceID: String? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, startIndex: Int? = nil) {
            self.playCommand = playCommand
            self.itemIDs = itemIDs
            self.startPositionTicks = startPositionTicks
            self.mediaSourceID = mediaSourceID
            self.audioStreamIndex = audioStreamIndex
            self.subtitleStreamIndex = subtitleStreamIndex
            self.startIndex = startIndex
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(playCommand, forKey: "playCommand")
            encoder.encode(itemIDs, forKey: "itemIds")
            encoder.encode(startPositionTicks, forKey: "startPositionTicks")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(startIndex, forKey: "startIndex")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getMusicArtistRemoteSearchResults(_ body: JellyfinAPI.ArtistInfoRemoteSearchQuery) -> Request<[JellyfinAPI.RemoteSearchResult]> {
        .post("/Items/RemoteSearch/MusicArtist", body: body)
    }
}

extension Paths {
    static public func getItemsByUserID(userID: String, parameters: GetItemsByUserIDParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Users/\(userID)/Items", query: parameters?.asQuery)
    }

    public struct GetItemsByUserIDParameters {
        public var maxOfficialRating: String?
        public var hasThemeSong: Bool?
        public var hasThemeVideo: Bool?
        public var hasSubtitles: Bool?
        public var hasSpecialFeature: Bool?
        public var hasTrailer: Bool?
        public var adjacentTo: String?
        public var parentIndexNumber: Int?
        public var hasParentalRating: Bool?
        public var isHd: Bool?
        public var isIs4K: Bool?
        public var locationTypes: [JellyfinAPI.LocationType]?
        public var excludeLocationTypes: [JellyfinAPI.LocationType]?
        public var isMissing: Bool?
        public var isUnaired: Bool?
        public var minCommunityRating: Double?
        public var minCriticRating: Double?
        public var minPremiereDate: Date?
        public var minDateLastSaved: Date?
        public var minDateLastSavedForUser: Date?
        public var maxPremiereDate: Date?
        public var hasOverview: Bool?
        public var hasImdbID: Bool?
        public var hasTmdbID: Bool?
        public var hasTvdbID: Bool?
        public var excludeItemIDs: [String]?
        public var startIndex: Int?
        public var limit: Int?
        public var isRecursive: Bool?
        public var searchTerm: String?
        public var sortOrder: [JellyfinAPI.SortOrder]?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var excludeItemTypes: [String]?
        public var includeItemTypes: [String]?
        public var filters: [JellyfinAPI.ItemFilter]?
        public var isFavorite: Bool?
        public var mediaTypes: [String]?
        public var imageTypes: [JellyfinAPI.ImageType]?
        public var sortBy: [String]?
        public var isPlayed: Bool?
        public var genres: [String]?
        public var officialRatings: [String]?
        public var tags: [String]?
        public var years: [Int]?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var person: String?
        public var personIDs: [String]?
        public var personTypes: [String]?
        public var studios: [String]?
        public var artists: [String]?
        public var excludeArtistIDs: [String]?
        public var artistIDs: [String]?
        public var albumArtistIDs: [String]?
        public var contributingArtistIDs: [String]?
        public var albums: [String]?
        public var albumIDs: [String]?
        public var ids: [String]?
        public var videoTypes: [JellyfinAPI.VideoType]?
        public var minOfficialRating: String?
        public var isLocked: Bool?
        public var isPlaceHolder: Bool?
        public var hasOfficialRating: Bool?
        public var isCollapseBoxSetItems: Bool?
        public var minWidth: Int?
        public var minHeight: Int?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var isIs3D: Bool?
        public var seriesStatus: [JellyfinAPI.SeriesStatus]?
        public var nameStartsWithOrGreater: String?
        public var nameStartsWith: String?
        public var nameLessThan: String?
        public var studioIDs: [String]?
        public var genreIDs: [String]?
        public var enableTotalRecordCount: Bool?
        public var enableImages: Bool?

        public init(maxOfficialRating: String? = nil, hasThemeSong: Bool? = nil, hasThemeVideo: Bool? = nil, hasSubtitles: Bool? = nil, hasSpecialFeature: Bool? = nil, hasTrailer: Bool? = nil, adjacentTo: String? = nil, parentIndexNumber: Int? = nil, hasParentalRating: Bool? = nil, isHd: Bool? = nil, isIs4K: Bool? = nil, locationTypes: [JellyfinAPI.LocationType]? = nil, excludeLocationTypes: [JellyfinAPI.LocationType]? = nil, isMissing: Bool? = nil, isUnaired: Bool? = nil, minCommunityRating: Double? = nil, minCriticRating: Double? = nil, minPremiereDate: Date? = nil, minDateLastSaved: Date? = nil, minDateLastSavedForUser: Date? = nil, maxPremiereDate: Date? = nil, hasOverview: Bool? = nil, hasImdbID: Bool? = nil, hasTmdbID: Bool? = nil, hasTvdbID: Bool? = nil, excludeItemIDs: [String]? = nil, startIndex: Int? = nil, limit: Int? = nil, isRecursive: Bool? = nil, searchTerm: String? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, imageTypes: [JellyfinAPI.ImageType]? = nil, sortBy: [String]? = nil, isPlayed: Bool? = nil, genres: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, artists: [String]? = nil, excludeArtistIDs: [String]? = nil, artistIDs: [String]? = nil, albumArtistIDs: [String]? = nil, contributingArtistIDs: [String]? = nil, albums: [String]? = nil, albumIDs: [String]? = nil, ids: [String]? = nil, videoTypes: [JellyfinAPI.VideoType]? = nil, minOfficialRating: String? = nil, isLocked: Bool? = nil, isPlaceHolder: Bool? = nil, hasOfficialRating: Bool? = nil, isCollapseBoxSetItems: Bool? = nil, minWidth: Int? = nil, minHeight: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, isIs3D: Bool? = nil, seriesStatus: [JellyfinAPI.SeriesStatus]? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, studioIDs: [String]? = nil, genreIDs: [String]? = nil, enableTotalRecordCount: Bool? = nil, enableImages: Bool? = nil) {
            self.maxOfficialRating = maxOfficialRating
            self.hasThemeSong = hasThemeSong
            self.hasThemeVideo = hasThemeVideo
            self.hasSubtitles = hasSubtitles
            self.hasSpecialFeature = hasSpecialFeature
            self.hasTrailer = hasTrailer
            self.adjacentTo = adjacentTo
            self.parentIndexNumber = parentIndexNumber
            self.hasParentalRating = hasParentalRating
            self.isHd = isHd
            self.isIs4K = isIs4K
            self.locationTypes = locationTypes
            self.excludeLocationTypes = excludeLocationTypes
            self.isMissing = isMissing
            self.isUnaired = isUnaired
            self.minCommunityRating = minCommunityRating
            self.minCriticRating = minCriticRating
            self.minPremiereDate = minPremiereDate
            self.minDateLastSaved = minDateLastSaved
            self.minDateLastSavedForUser = minDateLastSavedForUser
            self.maxPremiereDate = maxPremiereDate
            self.hasOverview = hasOverview
            self.hasImdbID = hasImdbID
            self.hasTmdbID = hasTmdbID
            self.hasTvdbID = hasTvdbID
            self.excludeItemIDs = excludeItemIDs
            self.startIndex = startIndex
            self.limit = limit
            self.isRecursive = isRecursive
            self.searchTerm = searchTerm
            self.sortOrder = sortOrder
            self.parentID = parentID
            self.fields = fields
            self.excludeItemTypes = excludeItemTypes
            self.includeItemTypes = includeItemTypes
            self.filters = filters
            self.isFavorite = isFavorite
            self.mediaTypes = mediaTypes
            self.imageTypes = imageTypes
            self.sortBy = sortBy
            self.isPlayed = isPlayed
            self.genres = genres
            self.officialRatings = officialRatings
            self.tags = tags
            self.years = years
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.person = person
            self.personIDs = personIDs
            self.personTypes = personTypes
            self.studios = studios
            self.artists = artists
            self.excludeArtistIDs = excludeArtistIDs
            self.artistIDs = artistIDs
            self.albumArtistIDs = albumArtistIDs
            self.contributingArtistIDs = contributingArtistIDs
            self.albums = albums
            self.albumIDs = albumIDs
            self.ids = ids
            self.videoTypes = videoTypes
            self.minOfficialRating = minOfficialRating
            self.isLocked = isLocked
            self.isPlaceHolder = isPlaceHolder
            self.hasOfficialRating = hasOfficialRating
            self.isCollapseBoxSetItems = isCollapseBoxSetItems
            self.minWidth = minWidth
            self.minHeight = minHeight
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.isIs3D = isIs3D
            self.seriesStatus = seriesStatus
            self.nameStartsWithOrGreater = nameStartsWithOrGreater
            self.nameStartsWith = nameStartsWith
            self.nameLessThan = nameLessThan
            self.studioIDs = studioIDs
            self.genreIDs = genreIDs
            self.enableTotalRecordCount = enableTotalRecordCount
            self.enableImages = enableImages
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxOfficialRating, forKey: "maxOfficialRating")
            encoder.encode(hasThemeSong, forKey: "hasThemeSong")
            encoder.encode(hasThemeVideo, forKey: "hasThemeVideo")
            encoder.encode(hasSubtitles, forKey: "hasSubtitles")
            encoder.encode(hasSpecialFeature, forKey: "hasSpecialFeature")
            encoder.encode(hasTrailer, forKey: "hasTrailer")
            encoder.encode(adjacentTo, forKey: "adjacentTo")
            encoder.encode(parentIndexNumber, forKey: "parentIndexNumber")
            encoder.encode(hasParentalRating, forKey: "hasParentalRating")
            encoder.encode(isHd, forKey: "isHd")
            encoder.encode(isIs4K, forKey: "is4K")
            encoder.encode(locationTypes, forKey: "locationTypes")
            encoder.encode(excludeLocationTypes, forKey: "excludeLocationTypes")
            encoder.encode(isMissing, forKey: "isMissing")
            encoder.encode(isUnaired, forKey: "isUnaired")
            encoder.encode(minCommunityRating, forKey: "minCommunityRating")
            encoder.encode(minCriticRating, forKey: "minCriticRating")
            encoder.encode(minPremiereDate, forKey: "minPremiereDate")
            encoder.encode(minDateLastSaved, forKey: "minDateLastSaved")
            encoder.encode(minDateLastSavedForUser, forKey: "minDateLastSavedForUser")
            encoder.encode(maxPremiereDate, forKey: "maxPremiereDate")
            encoder.encode(hasOverview, forKey: "hasOverview")
            encoder.encode(hasImdbID, forKey: "hasImdbId")
            encoder.encode(hasTmdbID, forKey: "hasTmdbId")
            encoder.encode(hasTvdbID, forKey: "hasTvdbId")
            encoder.encode(excludeItemIDs, forKey: "excludeItemIds")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isRecursive, forKey: "recursive")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(sortOrder, forKey: "sortOrder")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(filters, forKey: "filters")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(mediaTypes, forKey: "mediaTypes")
            encoder.encode(imageTypes, forKey: "imageTypes")
            encoder.encode(sortBy, forKey: "sortBy")
            encoder.encode(isPlayed, forKey: "isPlayed")
            encoder.encode(genres, forKey: "genres")
            encoder.encode(officialRatings, forKey: "officialRatings")
            encoder.encode(tags, forKey: "tags")
            encoder.encode(years, forKey: "years")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(person, forKey: "person")
            encoder.encode(personIDs, forKey: "personIds")
            encoder.encode(personTypes, forKey: "personTypes")
            encoder.encode(studios, forKey: "studios")
            encoder.encode(artists, forKey: "artists")
            encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
            encoder.encode(artistIDs, forKey: "artistIds")
            encoder.encode(albumArtistIDs, forKey: "albumArtistIds")
            encoder.encode(contributingArtistIDs, forKey: "contributingArtistIds")
            encoder.encode(albums, forKey: "albums")
            encoder.encode(albumIDs, forKey: "albumIds")
            encoder.encode(ids, forKey: "ids")
            encoder.encode(videoTypes, forKey: "videoTypes")
            encoder.encode(minOfficialRating, forKey: "minOfficialRating")
            encoder.encode(isLocked, forKey: "isLocked")
            encoder.encode(isPlaceHolder, forKey: "isPlaceHolder")
            encoder.encode(hasOfficialRating, forKey: "hasOfficialRating")
            encoder.encode(isCollapseBoxSetItems, forKey: "collapseBoxSetItems")
            encoder.encode(minWidth, forKey: "minWidth")
            encoder.encode(minHeight, forKey: "minHeight")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(isIs3D, forKey: "is3D")
            encoder.encode(seriesStatus, forKey: "seriesStatus")
            encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
            encoder.encode(nameStartsWith, forKey: "nameStartsWith")
            encoder.encode(nameLessThan, forKey: "nameLessThan")
            encoder.encode(studioIDs, forKey: "studioIds")
            encoder.encode(genreIDs, forKey: "genreIds")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            encoder.encode(enableImages, forKey: "enableImages")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getInstantMixFromPlaylist(id: String, parameters: GetInstantMixFromPlaylistParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Playlists/\(id)/InstantMix", query: parameters?.asQuery)
    }

    public struct GetInstantMixFromPlaylistParameters {
        public var userID: String?
        public var limit: Int?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableImages: Bool?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?

        public init(userID: String? = nil, limit: Int? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableImages: Bool? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil) {
            self.userID = userID
            self.limit = limit
            self.fields = fields
            self.enableImages = enableImages
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getGroupingOptions(userID: String) -> Request<[JellyfinAPI.SpecialViewOptionDto]> {
        .get("/Users/\(userID)/GroupingOptions")
    }
}

extension Paths {
    static public var getPingSystem: Request<String> {
        .get("/System/Ping")
    }
}

extension Paths {
    static public var postPingSystem: Request<String> {
        .post("/System/Ping")
    }
}

extension Paths {
    static public func getNotifications(userID: String) -> Request<JellyfinAPI.NotificationResultDto> {
        .get("/Notifications/\(userID)")
    }
}

extension Paths {
    static public func getDefaultTimer(programID: String? = nil) -> Request<JellyfinAPI.SeriesTimerInfoDto> {
        .get("/LiveTv/Timers/Defaults", query: makeGetDefaultTimerQuery(programID))
    }

    private static func makeGetDefaultTimerQuery(_ programID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(programID, forKey: "programId")
        return encoder.items
    }
}

extension Paths {
    static public func getTimers(parameters: GetTimersParameters? = nil) -> Request<JellyfinAPI.TimerInfoDtoQueryResult> {
        .get("/LiveTv/Timers", query: parameters?.asQuery)
    }

    public struct GetTimersParameters {
        public var channelID: String?
        public var seriesTimerID: String?
        public var isActive: Bool?
        public var isScheduled: Bool?

        public init(channelID: String? = nil, seriesTimerID: String? = nil, isActive: Bool? = nil, isScheduled: Bool? = nil) {
            self.channelID = channelID
            self.seriesTimerID = seriesTimerID
            self.isActive = isActive
            self.isScheduled = isScheduled
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(channelID, forKey: "channelId")
            encoder.encode(seriesTimerID, forKey: "seriesTimerId")
            encoder.encode(isActive, forKey: "isActive")
            encoder.encode(isScheduled, forKey: "isScheduled")
            return encoder.items
        }
    }
}

extension Paths {
    static public func createTimer(_ body: JellyfinAPI.TimerInfoDto? = nil) -> Request<Void> {
        .post("/LiveTv/Timers", body: body)
    }
}

extension Paths {
    static public func authenticateWithQuickConnect(_ body: JellyfinAPI.QuickConnectDto) -> Request<JellyfinAPI.AuthenticationResult> {
        .post("/Users/AuthenticateWithQuickConnect", body: body)
    }
}

extension Paths {
    static public func uninstallPlugin(pluginID: String) -> Request<Void> {
        .delete("/Plugins/\(pluginID)")
    }
}

extension Paths {
    static public var getCountries: Request<[JellyfinAPI.CountryInfo]> {
        .get("/Localization/Countries")
    }
}

extension Paths {
    static public var getStatus: Request<JellyfinAPI.QuickConnectState> {
        .get("/QuickConnect/Status")
    }
}

extension Paths {
    static public func getMusicGenres(parameters: GetMusicGenresParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/MusicGenres", query: parameters?.asQuery)
    }

    public struct GetMusicGenresParameters {
        public var startIndex: Int?
        public var limit: Int?
        public var searchTerm: String?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var excludeItemTypes: [String]?
        public var includeItemTypes: [String]?
        public var isFavorite: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var userID: String?
        public var nameStartsWithOrGreater: String?
        public var nameStartsWith: String?
        public var nameLessThan: String?
        public var enableImages: Bool?
        public var enableTotalRecordCount: Bool?

        public init(startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, isFavorite: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
            self.startIndex = startIndex
            self.limit = limit
            self.searchTerm = searchTerm
            self.parentID = parentID
            self.fields = fields
            self.excludeItemTypes = excludeItemTypes
            self.includeItemTypes = includeItemTypes
            self.isFavorite = isFavorite
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.userID = userID
            self.nameStartsWithOrGreater = nameStartsWithOrGreater
            self.nameStartsWith = nameStartsWith
            self.nameLessThan = nameLessThan
            self.enableImages = enableImages
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
            encoder.encode(nameStartsWith, forKey: "nameStartsWith")
            encoder.encode(nameLessThan, forKey: "nameLessThan")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getStudio(name: String, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/Studios/\(name)", query: makeGetStudioQuery(userID))
    }

    private static func makeGetStudioQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func createAdminNotification(_ body: JellyfinAPI.AdminNotificationDto) -> Request<Void> {
        .post("/Notifications/Admin", body: body)
    }
}

extension Paths {
    static public func getUserViews(userID: String, parameters: GetUserViewsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Users/\(userID)/Views", query: parameters?.asQuery)
    }

    public struct GetUserViewsParameters {
        public var isIncludeExternalContent: Bool?
        public var presetViews: [String]?
        public var isIncludeHidden: Bool?

        public init(isIncludeExternalContent: Bool? = nil, presetViews: [String]? = nil, isIncludeHidden: Bool? = nil) {
            self.isIncludeExternalContent = isIncludeExternalContent
            self.presetViews = presetViews
            self.isIncludeHidden = isIncludeHidden
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isIncludeExternalContent, forKey: "includeExternalContent")
            encoder.encode(presetViews, forKey: "presetViews")
            encoder.encode(isIncludeHidden, forKey: "includeHidden")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getLogFile(name: String) -> Request<String> {
        .get("/System/Logs/Log", query: [("name", name)])
    }
}

extension Paths {
    static public func moveItem(playlistID: String, itemID: String, newIndex: Int) -> Request<Void> {
        .post("/Playlists/\(playlistID)/Items/\(itemID)/Move/\(newIndex)")
    }
}

extension Paths {
    static public var getPlugins: Request<[JellyfinAPI.PluginInfo]> {
        .get("/Plugins")
    }
}

extension Paths {
    static public func getArtists(parameters: GetArtistsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Artists", query: parameters?.asQuery)
    }

    public struct GetArtistsParameters {
        public var minCommunityRating: Double?
        public var startIndex: Int?
        public var limit: Int?
        public var searchTerm: String?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var excludeItemTypes: [String]?
        public var includeItemTypes: [String]?
        public var filters: [JellyfinAPI.ItemFilter]?
        public var isFavorite: Bool?
        public var mediaTypes: [String]?
        public var genres: [String]?
        public var genreIDs: [String]?
        public var officialRatings: [String]?
        public var tags: [String]?
        public var years: [Int]?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var person: String?
        public var personIDs: [String]?
        public var personTypes: [String]?
        public var studios: [String]?
        public var studioIDs: [String]?
        public var userID: String?
        public var nameStartsWithOrGreater: String?
        public var nameStartsWith: String?
        public var nameLessThan: String?
        public var enableImages: Bool?
        public var enableTotalRecordCount: Bool?

        public init(minCommunityRating: Double? = nil, startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, genres: [String]? = nil, genreIDs: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, studioIDs: [String]? = nil, userID: String? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, enableImages: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
            self.minCommunityRating = minCommunityRating
            self.startIndex = startIndex
            self.limit = limit
            self.searchTerm = searchTerm
            self.parentID = parentID
            self.fields = fields
            self.excludeItemTypes = excludeItemTypes
            self.includeItemTypes = includeItemTypes
            self.filters = filters
            self.isFavorite = isFavorite
            self.mediaTypes = mediaTypes
            self.genres = genres
            self.genreIDs = genreIDs
            self.officialRatings = officialRatings
            self.tags = tags
            self.years = years
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.person = person
            self.personIDs = personIDs
            self.personTypes = personTypes
            self.studios = studios
            self.studioIDs = studioIDs
            self.userID = userID
            self.nameStartsWithOrGreater = nameStartsWithOrGreater
            self.nameStartsWith = nameStartsWith
            self.nameLessThan = nameLessThan
            self.enableImages = enableImages
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(minCommunityRating, forKey: "minCommunityRating")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(filters, forKey: "filters")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(mediaTypes, forKey: "mediaTypes")
            encoder.encode(genres, forKey: "genres")
            encoder.encode(genreIDs, forKey: "genreIds")
            encoder.encode(officialRatings, forKey: "officialRatings")
            encoder.encode(tags, forKey: "tags")
            encoder.encode(years, forKey: "years")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(person, forKey: "person")
            encoder.encode(personIDs, forKey: "personIds")
            encoder.encode(personTypes, forKey: "personTypes")
            encoder.encode(studios, forKey: "studios")
            encoder.encode(studioIDs, forKey: "studioIds")
            encoder.encode(userID, forKey: "userId")
            encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
            encoder.encode(nameStartsWith, forKey: "nameStartsWith")
            encoder.encode(nameLessThan, forKey: "nameLessThan")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getChannelFeatures(channelID: String) -> Request<JellyfinAPI.ChannelFeatures> {
        .get("/Channels/\(channelID)/Features")
    }
}

extension Paths {
    static public func reportPlaybackStart(_ body: JellyfinAPI.PlaybackStartInfo? = nil) -> Request<Void> {
        .post("/Sessions/Playing", body: body)
    }
}

extension Paths {
    static public func getResumeItems(userID: String, parameters: GetResumeItemsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Users/\(userID)/Items/Resume", query: parameters?.asQuery)
    }

    public struct GetResumeItemsParameters {
        public var startIndex: Int?
        public var limit: Int?
        public var searchTerm: String?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var mediaTypes: [String]?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var excludeItemTypes: [String]?
        public var includeItemTypes: [String]?
        public var enableTotalRecordCount: Bool?
        public var enableImages: Bool?

        public init(startIndex: Int? = nil, limit: Int? = nil, searchTerm: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, mediaTypes: [String]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, enableTotalRecordCount: Bool? = nil, enableImages: Bool? = nil) {
            self.startIndex = startIndex
            self.limit = limit
            self.searchTerm = searchTerm
            self.parentID = parentID
            self.fields = fields
            self.mediaTypes = mediaTypes
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.excludeItemTypes = excludeItemTypes
            self.includeItemTypes = includeItemTypes
            self.enableTotalRecordCount = enableTotalRecordCount
            self.enableImages = enableImages
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(mediaTypes, forKey: "mediaTypes")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            encoder.encode(enableImages, forKey: "enableImages")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getYear(year: Int, userID: String? = nil) -> Request<JellyfinAPI.BaseItemDto> {
        .get("/Years/\(year)", query: makeGetYearQuery(userID))
    }

    private static func makeGetYearQuery(_ userID: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(userID, forKey: "userId")
        return encoder.items
    }
}

extension Paths {
    static public func getRecommendedPrograms(parameters: GetRecommendedProgramsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/LiveTv/Programs/Recommended", query: parameters?.asQuery)
    }

    public struct GetRecommendedProgramsParameters {
        public var userID: String?
        public var limit: Int?
        public var isAiring: Bool?
        public var hasAired: Bool?
        public var isSeries: Bool?
        public var isMovie: Bool?
        public var isNews: Bool?
        public var isKids: Bool?
        public var isSports: Bool?
        public var enableImages: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var genreIDs: [String]?
        public var fields: [JellyfinAPI.ItemFields]?
        public var enableUserData: Bool?
        public var enableTotalRecordCount: Bool?

        public init(userID: String? = nil, limit: Int? = nil, isAiring: Bool? = nil, hasAired: Bool? = nil, isSeries: Bool? = nil, isMovie: Bool? = nil, isNews: Bool? = nil, isKids: Bool? = nil, isSports: Bool? = nil, enableImages: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, genreIDs: [String]? = nil, fields: [JellyfinAPI.ItemFields]? = nil, enableUserData: Bool? = nil, enableTotalRecordCount: Bool? = nil) {
            self.userID = userID
            self.limit = limit
            self.isAiring = isAiring
            self.hasAired = hasAired
            self.isSeries = isSeries
            self.isMovie = isMovie
            self.isNews = isNews
            self.isKids = isKids
            self.isSports = isSports
            self.enableImages = enableImages
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.genreIDs = genreIDs
            self.fields = fields
            self.enableUserData = enableUserData
            self.enableTotalRecordCount = enableTotalRecordCount
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isAiring, forKey: "isAiring")
            encoder.encode(hasAired, forKey: "hasAired")
            encoder.encode(isSeries, forKey: "isSeries")
            encoder.encode(isMovie, forKey: "isMovie")
            encoder.encode(isNews, forKey: "isNews")
            encoder.encode(isKids, forKey: "isKids")
            encoder.encode(isSports, forKey: "isSports")
            encoder.encode(enableImages, forKey: "enableImages")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(genreIDs, forKey: "genreIds")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            return encoder.items
        }
    }
}

extension Paths {
    static public func syncPlayReady(_ body: JellyfinAPI.ReadyRequestDto) -> Request<Void> {
        .post("/SyncPlay/Ready", body: body)
    }
}

extension Paths {
    static public func getConnectionManager2(serverID: String) -> Request<String> {
        .get("/Dlna/\(serverID)/ConnectionManager/ConnectionManager")
    }
}

extension Paths {
    static public func getUserImageByIndex(userID: String, imageType: String, imageIndex: Int, parameters: GetUserImageByIndexParameters? = nil) -> Request<Data> {
        .get("/Users/\(userID)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct GetUserImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func headUserImageByIndex(userID: String, imageType: String, imageIndex: Int, parameters: HeadUserImageByIndexParameters? = nil) -> Request<Data> {
        .head("/Users/\(userID)/Images/\(imageType)/\(imageIndex)", query: parameters?.asQuery)
    }

    public struct HeadUserImageByIndexParameters {
        public var tag: String?
        public var format: Format?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var percentPlayed: Double?
        public var unplayedCount: Int?
        public var width: Int?
        public var height: Int?
        public var quality: Int?
        public var fillWidth: Int?
        public var fillHeight: Int?
        public var isCropWhitespace: Bool?
        public var isAddPlayedIndicator: Bool?
        public var blur: Int?
        public var backgroundColor: String?
        public var foregroundLayer: String?

        public typealias Format = JellyfinAPI.ImageFormat

        public init(tag: String? = nil, format: Format? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, percentPlayed: Double? = nil, unplayedCount: Int? = nil, width: Int? = nil, height: Int? = nil, quality: Int? = nil, fillWidth: Int? = nil, fillHeight: Int? = nil, isCropWhitespace: Bool? = nil, isAddPlayedIndicator: Bool? = nil, blur: Int? = nil, backgroundColor: String? = nil, foregroundLayer: String? = nil) {
            self.tag = tag
            self.format = format
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.percentPlayed = percentPlayed
            self.unplayedCount = unplayedCount
            self.width = width
            self.height = height
            self.quality = quality
            self.fillWidth = fillWidth
            self.fillHeight = fillHeight
            self.isCropWhitespace = isCropWhitespace
            self.isAddPlayedIndicator = isAddPlayedIndicator
            self.blur = blur
            self.backgroundColor = backgroundColor
            self.foregroundLayer = foregroundLayer
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            encoder.encode(format, forKey: "format")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(percentPlayed, forKey: "percentPlayed")
            encoder.encode(unplayedCount, forKey: "unplayedCount")
            encoder.encode(width, forKey: "width")
            encoder.encode(height, forKey: "height")
            encoder.encode(quality, forKey: "quality")
            encoder.encode(fillWidth, forKey: "fillWidth")
            encoder.encode(fillHeight, forKey: "fillHeight")
            encoder.encode(isCropWhitespace, forKey: "cropWhitespace")
            encoder.encode(isAddPlayedIndicator, forKey: "addPlayedIndicator")
            encoder.encode(blur, forKey: "blur")
            encoder.encode(backgroundColor, forKey: "backgroundColor")
            encoder.encode(foregroundLayer, forKey: "foregroundLayer")
            return encoder.items
        }
    }
}

extension Paths {
    static public func getItems(parameters: GetItemsParameters? = nil) -> Request<JellyfinAPI.BaseItemDtoQueryResult> {
        .get("/Items", query: parameters?.asQuery)
    }

    public struct GetItemsParameters {
        public var userID: String?
        public var maxOfficialRating: String?
        public var hasThemeSong: Bool?
        public var hasThemeVideo: Bool?
        public var hasSubtitles: Bool?
        public var hasSpecialFeature: Bool?
        public var hasTrailer: Bool?
        public var adjacentTo: String?
        public var parentIndexNumber: Int?
        public var hasParentalRating: Bool?
        public var isHd: Bool?
        public var isIs4K: Bool?
        public var locationTypes: [JellyfinAPI.LocationType]?
        public var excludeLocationTypes: [JellyfinAPI.LocationType]?
        public var isMissing: Bool?
        public var isUnaired: Bool?
        public var minCommunityRating: Double?
        public var minCriticRating: Double?
        public var minPremiereDate: Date?
        public var minDateLastSaved: Date?
        public var minDateLastSavedForUser: Date?
        public var maxPremiereDate: Date?
        public var hasOverview: Bool?
        public var hasImdbID: Bool?
        public var hasTmdbID: Bool?
        public var hasTvdbID: Bool?
        public var excludeItemIDs: [String]?
        public var startIndex: Int?
        public var limit: Int?
        public var isRecursive: Bool?
        public var searchTerm: String?
        public var sortOrder: [JellyfinAPI.SortOrder]?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var excludeItemTypes: [String]?
        public var includeItemTypes: [String]?
        public var filters: [JellyfinAPI.ItemFilter]?
        public var isFavorite: Bool?
        public var mediaTypes: [String]?
        public var imageTypes: [JellyfinAPI.ImageType]?
        public var sortBy: [String]?
        public var isPlayed: Bool?
        public var genres: [String]?
        public var officialRatings: [String]?
        public var tags: [String]?
        public var years: [Int]?
        public var enableUserData: Bool?
        public var imageTypeLimit: Int?
        public var enableImageTypes: [JellyfinAPI.ImageType]?
        public var person: String?
        public var personIDs: [String]?
        public var personTypes: [String]?
        public var studios: [String]?
        public var artists: [String]?
        public var excludeArtistIDs: [String]?
        public var artistIDs: [String]?
        public var albumArtistIDs: [String]?
        public var contributingArtistIDs: [String]?
        public var albums: [String]?
        public var albumIDs: [String]?
        public var ids: [String]?
        public var videoTypes: [JellyfinAPI.VideoType]?
        public var minOfficialRating: String?
        public var isLocked: Bool?
        public var isPlaceHolder: Bool?
        public var hasOfficialRating: Bool?
        public var isCollapseBoxSetItems: Bool?
        public var minWidth: Int?
        public var minHeight: Int?
        public var maxWidth: Int?
        public var maxHeight: Int?
        public var isIs3D: Bool?
        public var seriesStatus: [JellyfinAPI.SeriesStatus]?
        public var nameStartsWithOrGreater: String?
        public var nameStartsWith: String?
        public var nameLessThan: String?
        public var studioIDs: [String]?
        public var genreIDs: [String]?
        public var enableTotalRecordCount: Bool?
        public var enableImages: Bool?

        public init(userID: String? = nil, maxOfficialRating: String? = nil, hasThemeSong: Bool? = nil, hasThemeVideo: Bool? = nil, hasSubtitles: Bool? = nil, hasSpecialFeature: Bool? = nil, hasTrailer: Bool? = nil, adjacentTo: String? = nil, parentIndexNumber: Int? = nil, hasParentalRating: Bool? = nil, isHd: Bool? = nil, isIs4K: Bool? = nil, locationTypes: [JellyfinAPI.LocationType]? = nil, excludeLocationTypes: [JellyfinAPI.LocationType]? = nil, isMissing: Bool? = nil, isUnaired: Bool? = nil, minCommunityRating: Double? = nil, minCriticRating: Double? = nil, minPremiereDate: Date? = nil, minDateLastSaved: Date? = nil, minDateLastSavedForUser: Date? = nil, maxPremiereDate: Date? = nil, hasOverview: Bool? = nil, hasImdbID: Bool? = nil, hasTmdbID: Bool? = nil, hasTvdbID: Bool? = nil, excludeItemIDs: [String]? = nil, startIndex: Int? = nil, limit: Int? = nil, isRecursive: Bool? = nil, searchTerm: String? = nil, sortOrder: [JellyfinAPI.SortOrder]? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, excludeItemTypes: [String]? = nil, includeItemTypes: [String]? = nil, filters: [JellyfinAPI.ItemFilter]? = nil, isFavorite: Bool? = nil, mediaTypes: [String]? = nil, imageTypes: [JellyfinAPI.ImageType]? = nil, sortBy: [String]? = nil, isPlayed: Bool? = nil, genres: [String]? = nil, officialRatings: [String]? = nil, tags: [String]? = nil, years: [Int]? = nil, enableUserData: Bool? = nil, imageTypeLimit: Int? = nil, enableImageTypes: [JellyfinAPI.ImageType]? = nil, person: String? = nil, personIDs: [String]? = nil, personTypes: [String]? = nil, studios: [String]? = nil, artists: [String]? = nil, excludeArtistIDs: [String]? = nil, artistIDs: [String]? = nil, albumArtistIDs: [String]? = nil, contributingArtistIDs: [String]? = nil, albums: [String]? = nil, albumIDs: [String]? = nil, ids: [String]? = nil, videoTypes: [JellyfinAPI.VideoType]? = nil, minOfficialRating: String? = nil, isLocked: Bool? = nil, isPlaceHolder: Bool? = nil, hasOfficialRating: Bool? = nil, isCollapseBoxSetItems: Bool? = nil, minWidth: Int? = nil, minHeight: Int? = nil, maxWidth: Int? = nil, maxHeight: Int? = nil, isIs3D: Bool? = nil, seriesStatus: [JellyfinAPI.SeriesStatus]? = nil, nameStartsWithOrGreater: String? = nil, nameStartsWith: String? = nil, nameLessThan: String? = nil, studioIDs: [String]? = nil, genreIDs: [String]? = nil, enableTotalRecordCount: Bool? = nil, enableImages: Bool? = nil) {
            self.userID = userID
            self.maxOfficialRating = maxOfficialRating
            self.hasThemeSong = hasThemeSong
            self.hasThemeVideo = hasThemeVideo
            self.hasSubtitles = hasSubtitles
            self.hasSpecialFeature = hasSpecialFeature
            self.hasTrailer = hasTrailer
            self.adjacentTo = adjacentTo
            self.parentIndexNumber = parentIndexNumber
            self.hasParentalRating = hasParentalRating
            self.isHd = isHd
            self.isIs4K = isIs4K
            self.locationTypes = locationTypes
            self.excludeLocationTypes = excludeLocationTypes
            self.isMissing = isMissing
            self.isUnaired = isUnaired
            self.minCommunityRating = minCommunityRating
            self.minCriticRating = minCriticRating
            self.minPremiereDate = minPremiereDate
            self.minDateLastSaved = minDateLastSaved
            self.minDateLastSavedForUser = minDateLastSavedForUser
            self.maxPremiereDate = maxPremiereDate
            self.hasOverview = hasOverview
            self.hasImdbID = hasImdbID
            self.hasTmdbID = hasTmdbID
            self.hasTvdbID = hasTvdbID
            self.excludeItemIDs = excludeItemIDs
            self.startIndex = startIndex
            self.limit = limit
            self.isRecursive = isRecursive
            self.searchTerm = searchTerm
            self.sortOrder = sortOrder
            self.parentID = parentID
            self.fields = fields
            self.excludeItemTypes = excludeItemTypes
            self.includeItemTypes = includeItemTypes
            self.filters = filters
            self.isFavorite = isFavorite
            self.mediaTypes = mediaTypes
            self.imageTypes = imageTypes
            self.sortBy = sortBy
            self.isPlayed = isPlayed
            self.genres = genres
            self.officialRatings = officialRatings
            self.tags = tags
            self.years = years
            self.enableUserData = enableUserData
            self.imageTypeLimit = imageTypeLimit
            self.enableImageTypes = enableImageTypes
            self.person = person
            self.personIDs = personIDs
            self.personTypes = personTypes
            self.studios = studios
            self.artists = artists
            self.excludeArtistIDs = excludeArtistIDs
            self.artistIDs = artistIDs
            self.albumArtistIDs = albumArtistIDs
            self.contributingArtistIDs = contributingArtistIDs
            self.albums = albums
            self.albumIDs = albumIDs
            self.ids = ids
            self.videoTypes = videoTypes
            self.minOfficialRating = minOfficialRating
            self.isLocked = isLocked
            self.isPlaceHolder = isPlaceHolder
            self.hasOfficialRating = hasOfficialRating
            self.isCollapseBoxSetItems = isCollapseBoxSetItems
            self.minWidth = minWidth
            self.minHeight = minHeight
            self.maxWidth = maxWidth
            self.maxHeight = maxHeight
            self.isIs3D = isIs3D
            self.seriesStatus = seriesStatus
            self.nameStartsWithOrGreater = nameStartsWithOrGreater
            self.nameStartsWith = nameStartsWith
            self.nameLessThan = nameLessThan
            self.studioIDs = studioIDs
            self.genreIDs = genreIDs
            self.enableTotalRecordCount = enableTotalRecordCount
            self.enableImages = enableImages
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(maxOfficialRating, forKey: "maxOfficialRating")
            encoder.encode(hasThemeSong, forKey: "hasThemeSong")
            encoder.encode(hasThemeVideo, forKey: "hasThemeVideo")
            encoder.encode(hasSubtitles, forKey: "hasSubtitles")
            encoder.encode(hasSpecialFeature, forKey: "hasSpecialFeature")
            encoder.encode(hasTrailer, forKey: "hasTrailer")
            encoder.encode(adjacentTo, forKey: "adjacentTo")
            encoder.encode(parentIndexNumber, forKey: "parentIndexNumber")
            encoder.encode(hasParentalRating, forKey: "hasParentalRating")
            encoder.encode(isHd, forKey: "isHd")
            encoder.encode(isIs4K, forKey: "is4K")
            encoder.encode(locationTypes, forKey: "locationTypes")
            encoder.encode(excludeLocationTypes, forKey: "excludeLocationTypes")
            encoder.encode(isMissing, forKey: "isMissing")
            encoder.encode(isUnaired, forKey: "isUnaired")
            encoder.encode(minCommunityRating, forKey: "minCommunityRating")
            encoder.encode(minCriticRating, forKey: "minCriticRating")
            encoder.encode(minPremiereDate, forKey: "minPremiereDate")
            encoder.encode(minDateLastSaved, forKey: "minDateLastSaved")
            encoder.encode(minDateLastSavedForUser, forKey: "minDateLastSavedForUser")
            encoder.encode(maxPremiereDate, forKey: "maxPremiereDate")
            encoder.encode(hasOverview, forKey: "hasOverview")
            encoder.encode(hasImdbID, forKey: "hasImdbId")
            encoder.encode(hasTmdbID, forKey: "hasTmdbId")
            encoder.encode(hasTvdbID, forKey: "hasTvdbId")
            encoder.encode(excludeItemIDs, forKey: "excludeItemIds")
            encoder.encode(startIndex, forKey: "startIndex")
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isRecursive, forKey: "recursive")
            encoder.encode(searchTerm, forKey: "searchTerm")
            encoder.encode(sortOrder, forKey: "sortOrder")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(excludeItemTypes, forKey: "excludeItemTypes")
            encoder.encode(includeItemTypes, forKey: "includeItemTypes")
            encoder.encode(filters, forKey: "filters")
            encoder.encode(isFavorite, forKey: "isFavorite")
            encoder.encode(mediaTypes, forKey: "mediaTypes")
            encoder.encode(imageTypes, forKey: "imageTypes")
            encoder.encode(sortBy, forKey: "sortBy")
            encoder.encode(isPlayed, forKey: "isPlayed")
            encoder.encode(genres, forKey: "genres")
            encoder.encode(officialRatings, forKey: "officialRatings")
            encoder.encode(tags, forKey: "tags")
            encoder.encode(years, forKey: "years")
            encoder.encode(enableUserData, forKey: "enableUserData")
            encoder.encode(imageTypeLimit, forKey: "imageTypeLimit")
            encoder.encode(enableImageTypes, forKey: "enableImageTypes")
            encoder.encode(person, forKey: "person")
            encoder.encode(personIDs, forKey: "personIds")
            encoder.encode(personTypes, forKey: "personTypes")
            encoder.encode(studios, forKey: "studios")
            encoder.encode(artists, forKey: "artists")
            encoder.encode(excludeArtistIDs, forKey: "excludeArtistIds")
            encoder.encode(artistIDs, forKey: "artistIds")
            encoder.encode(albumArtistIDs, forKey: "albumArtistIds")
            encoder.encode(contributingArtistIDs, forKey: "contributingArtistIds")
            encoder.encode(albums, forKey: "albums")
            encoder.encode(albumIDs, forKey: "albumIds")
            encoder.encode(ids, forKey: "ids")
            encoder.encode(videoTypes, forKey: "videoTypes")
            encoder.encode(minOfficialRating, forKey: "minOfficialRating")
            encoder.encode(isLocked, forKey: "isLocked")
            encoder.encode(isPlaceHolder, forKey: "isPlaceHolder")
            encoder.encode(hasOfficialRating, forKey: "hasOfficialRating")
            encoder.encode(isCollapseBoxSetItems, forKey: "collapseBoxSetItems")
            encoder.encode(minWidth, forKey: "minWidth")
            encoder.encode(minHeight, forKey: "minHeight")
            encoder.encode(maxWidth, forKey: "maxWidth")
            encoder.encode(maxHeight, forKey: "maxHeight")
            encoder.encode(isIs3D, forKey: "is3D")
            encoder.encode(seriesStatus, forKey: "seriesStatus")
            encoder.encode(nameStartsWithOrGreater, forKey: "nameStartsWithOrGreater")
            encoder.encode(nameStartsWith, forKey: "nameStartsWith")
            encoder.encode(nameLessThan, forKey: "nameLessThan")
            encoder.encode(studioIDs, forKey: "studioIds")
            encoder.encode(genreIDs, forKey: "genreIds")
            encoder.encode(enableTotalRecordCount, forKey: "enableTotalRecordCount")
            encoder.encode(enableImages, forKey: "enableImages")
            return encoder.items
        }
    }
}

extension Paths {
    static public func deleteItems(ids: [String]? = nil) -> Request<Void> {
        .delete("/Items", query: makeDeleteItemsQuery(ids))
    }

    private static func makeDeleteItemsQuery(_ ids: [String]?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(ids, forKey: "ids")
        return encoder.items
    }
}

extension Paths {
    static public var getVirtualFolders: Request<[JellyfinAPI.VirtualFolderInfo]> {
        .get("/Library/VirtualFolders")
    }
}

extension Paths {
    static public func addVirtualFolder(parameters: AddVirtualFolderParameters? = nil, _ body: JellyfinAPI.AddVirtualFolderDto? = nil) -> Request<Void> {
        .post("/Library/VirtualFolders", query: parameters?.asQuery, body: body)
    }

    public struct AddVirtualFolderParameters {
        public var name: String?
        public var collectionType: CollectionType?
        public var paths: [String]?
        public var isRefreshLibrary: Bool?

        public typealias CollectionType = JellyfinAPI.CollectionTypeOptions

        public init(name: String? = nil, collectionType: CollectionType? = nil, paths: [String]? = nil, isRefreshLibrary: Bool? = nil) {
            self.name = name
            self.collectionType = collectionType
            self.paths = paths
            self.isRefreshLibrary = isRefreshLibrary
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(name, forKey: "name")
            encoder.encode(collectionType, forKey: "collectionType")
            encoder.encode(paths, forKey: "paths")
            encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
            return encoder.items
        }
    }
}

extension Paths {
    static public func removeVirtualFolder(name: String? = nil, isRefreshLibrary: Bool? = nil) -> Request<Void> {
        .delete("/Library/VirtualFolders", query: makeRemoveVirtualFolderQuery(name, isRefreshLibrary))
    }

    private static func makeRemoveVirtualFolderQuery(_ name: String?, _ isRefreshLibrary: Bool?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(name, forKey: "name")
        encoder.encode(isRefreshLibrary, forKey: "refreshLibrary")
        return encoder.items
    }
}

extension Paths {
    static public func getMovieRecommendations(parameters: GetMovieRecommendationsParameters? = nil) -> Request<[JellyfinAPI.RecommendationDto]> {
        .get("/Movies/Recommendations", query: parameters?.asQuery)
    }

    public struct GetMovieRecommendationsParameters {
        public var userID: String?
        public var parentID: String?
        public var fields: [JellyfinAPI.ItemFields]?
        public var categoryLimit: Int?
        public var itemLimit: Int?

        public init(userID: String? = nil, parentID: String? = nil, fields: [JellyfinAPI.ItemFields]? = nil, categoryLimit: Int? = nil, itemLimit: Int? = nil) {
            self.userID = userID
            self.parentID = parentID
            self.fields = fields
            self.categoryLimit = categoryLimit
            self.itemLimit = itemLimit
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userID, forKey: "userId")
            encoder.encode(parentID, forKey: "parentId")
            encoder.encode(fields, forKey: "fields")
            encoder.encode(categoryLimit, forKey: "categoryLimit")
            encoder.encode(itemLimit, forKey: "itemLimit")
            return encoder.items
        }
    }
}

extension Paths {
    static public func sendGeneralCommand(sessionID: String, command: String) -> Request<Void> {
        .post("/Sessions/\(sessionID)/Command/\(command)")
    }
}

extension Paths {
    static public func closeLiveStream(liveStreamID: String) -> Request<Void> {
        .post("/LiveStreams/Close", query: [("liveStreamId", liveStreamID)])
    }
}

extension Paths {
    static public func getDashboardConfigurationPage(name: String? = nil) -> Request<String> {
        .get("/web/ConfigurationPage", query: makeGetDashboardConfigurationPageQuery(name))
    }

    private static func makeGetDashboardConfigurationPageQuery(_ name: String?) -> [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(name, forKey: "name")
        return encoder.items
    }
}

extension Paths {
    static public func getSeriesTimers(parameters: GetSeriesTimersParameters? = nil) -> Request<JellyfinAPI.SeriesTimerInfoDtoQueryResult> {
        .get("/LiveTv/SeriesTimers", query: parameters?.asQuery)
    }

    public struct GetSeriesTimersParameters {
        public var sortBy: String?
        public var sortOrder: SortOrder?

        public typealias SortOrder = JellyfinAPI.SortOrder

        public init(sortBy: String? = nil, sortOrder: SortOrder? = nil) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(sortBy, forKey: "sortBy")
            encoder.encode(sortOrder, forKey: "sortOrder")
            return encoder.items
        }
    }
}

extension Paths {
    static public func createSeriesTimer(_ body: JellyfinAPI.SeriesTimerInfoDto? = nil) -> Request<Void> {
        .post("/LiveTv/SeriesTimers", body: body)
    }
}

extension Paths {
    static public func getSubtitle(routeItemID: String, routeMediaSourceID: String, routeIndex: Int, routeFormat: String, parameters: GetSubtitleParameters? = nil) -> Request<String> {
        .get("/Videos/\(routeItemID)/\(routeMediaSourceID)/Subtitles/\(routeIndex)/Stream.\(routeFormat)", query: parameters?.asQuery)
    }

    public struct GetSubtitleParameters {
        public var itemID: String?
        public var mediaSourceID: String?
        public var index: Int?
        public var format: String?
        public var endPositionTicks: Int?
        public var isCopyTimestamps: Bool?
        public var isAddVttTimeMap: Bool?
        public var startPositionTicks: Int?

        public init(itemID: String? = nil, mediaSourceID: String? = nil, index: Int? = nil, format: String? = nil, endPositionTicks: Int? = nil, isCopyTimestamps: Bool? = nil, isAddVttTimeMap: Bool? = nil, startPositionTicks: Int? = nil) {
            self.itemID = itemID
            self.mediaSourceID = mediaSourceID
            self.index = index
            self.format = format
            self.endPositionTicks = endPositionTicks
            self.isCopyTimestamps = isCopyTimestamps
            self.isAddVttTimeMap = isAddVttTimeMap
            self.startPositionTicks = startPositionTicks
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(itemID, forKey: "itemId")
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(index, forKey: "index")
            encoder.encode(format, forKey: "format")
            encoder.encode(endPositionTicks, forKey: "endPositionTicks")
            encoder.encode(isCopyTimestamps, forKey: "copyTimestamps")
            encoder.encode(isAddVttTimeMap, forKey: "addVttTimeMap")
            encoder.encode(startPositionTicks, forKey: "startPositionTicks")
            return encoder.items
        }
    }
}

extension Paths {
    static public var getFirstUser: Request<JellyfinAPI.StartupUserDto> {
        .get("/Startup/User")
    }
}

extension Paths {
    static public func updateStartupUser(_ body: JellyfinAPI.StartupUserDto? = nil) -> Request<Void> {
        .post("/Startup/User", body: body)
    }
}

extension Paths {
    static public func onPlaybackProgress(userID: String, itemID: String, parameters: OnPlaybackProgressParameters? = nil) -> Request<Void> {
        .post("/Users/\(userID)/PlayingItems/\(itemID)/Progress", query: parameters?.asQuery)
    }

    public struct OnPlaybackProgressParameters {
        public var mediaSourceID: String?
        public var positionTicks: Int?
        public var audioStreamIndex: Int?
        public var subtitleStreamIndex: Int?
        public var volumeLevel: Int?
        public var playMethod: PlayMethod?
        public var liveStreamID: String?
        public var playSessionID: String?
        public var repeatMode: RepeatMode?
        public var isPaused: Bool?
        public var isMuted: Bool?

        public typealias PlayMethod = JellyfinAPI.PlayMethod

        public typealias RepeatMode = JellyfinAPI.RepeatMode

        public init(mediaSourceID: String? = nil, positionTicks: Int? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, volumeLevel: Int? = nil, playMethod: PlayMethod? = nil, liveStreamID: String? = nil, playSessionID: String? = nil, repeatMode: RepeatMode? = nil, isPaused: Bool? = nil, isMuted: Bool? = nil) {
            self.mediaSourceID = mediaSourceID
            self.positionTicks = positionTicks
            self.audioStreamIndex = audioStreamIndex
            self.subtitleStreamIndex = subtitleStreamIndex
            self.volumeLevel = volumeLevel
            self.playMethod = playMethod
            self.liveStreamID = liveStreamID
            self.playSessionID = playSessionID
            self.repeatMode = repeatMode
            self.isPaused = isPaused
            self.isMuted = isMuted
        }

        public var asQuery: [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(mediaSourceID, forKey: "mediaSourceId")
            encoder.encode(positionTicks, forKey: "positionTicks")
            encoder.encode(audioStreamIndex, forKey: "audioStreamIndex")
            encoder.encode(subtitleStreamIndex, forKey: "subtitleStreamIndex")
            encoder.encode(volumeLevel, forKey: "volumeLevel")
            encoder.encode(playMethod, forKey: "playMethod")
            encoder.encode(liveStreamID, forKey: "liveStreamId")
            encoder.encode(playSessionID, forKey: "playSessionId")
            encoder.encode(repeatMode, forKey: "repeatMode")
            encoder.encode(isPaused, forKey: "isPaused")
            encoder.encode(isMuted, forKey: "isMuted")
            return encoder.items
        }
    }
}

extension Paths {
    static public func sendSystemCommand(sessionID: String, command: String) -> Request<Void> {
        .post("/Sessions/\(sessionID)/System/\(command)")
    }
}

extension Paths {
    static public var deauthorize: Request<Int> {
        .post("/QuickConnect/Deauthorize")
    }
}

extension Paths {
    static public func getDisplayPreferences(displayPreferencesID: String, userID: String, client: String) -> Request<JellyfinAPI.DisplayPreferencesDto> {
        .get("/DisplayPreferences/\(displayPreferencesID)", query: [("userId", userID), ("client", client)])
    }
}

extension Paths {
    static public func updateDisplayPreferences(displayPreferencesID: String, userID: String, client: String, _ body: JellyfinAPI.DisplayPreferencesDto) -> Request<Void> {
        .post("/DisplayPreferences/\(displayPreferencesID)", query: [("userId", userID), ("client", client)], body: body)
    }
}

public enum Paths {}
