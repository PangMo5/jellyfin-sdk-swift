//
// SubtitleAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(Combine)
import Combine
#endif
#if canImport(AnyCodable)
import AnyCodable
#endif

open class SubtitleAPI {

    /**
     Deletes an external subtitle file.
     
     - parameter itemId: (path) The item id. 
     - parameter index: (path) The index of the subtitle file. 
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func deleteSubtitle(itemId: String, index: Int) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = deleteSubtitleWithRequestBuilder(itemId: itemId, index: index).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Deletes an external subtitle file.
     - DELETE /Videos/{itemId}/Subtitles/{index}
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter index: (path) The index of the subtitle file. 
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSubtitleWithRequestBuilder(itemId: String, index: Int) -> RequestBuilder<Void> {
        var localVariablePath = "/Videos/{itemId}/Subtitles/{index}"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let indexPreEscape = "\(APIHelper.mapValueToPathItem(index))"
        let indexPostEscape = indexPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{index}", with: indexPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Downloads a remote subtitle.
     
     - parameter itemId: (path) The item id. 
     - parameter subtitleId: (path) The subtitle id. 
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func downloadRemoteSubtitles(itemId: String, subtitleId: String) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = downloadRemoteSubtitlesWithRequestBuilder(itemId: itemId, subtitleId: subtitleId).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Downloads a remote subtitle.
     - POST /Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter subtitleId: (path) The subtitle id. 
     - returns: RequestBuilder<Void> 
     */
    open class func downloadRemoteSubtitlesWithRequestBuilder(itemId: String, subtitleId: String) -> RequestBuilder<Void> {
        var localVariablePath = "/Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let subtitleIdPreEscape = "\(APIHelper.mapValueToPathItem(subtitleId))"
        let subtitleIdPostEscape = subtitleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{subtitleId}", with: subtitleIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Gets a fallback font file.
     
     - parameter name: (path) The name of the fallback font file to get. 
     - returns: AnyPublisher<URL, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getFallbackFont(name: String) -> AnyPublisher<URL, Error> {
        var requestTask: RequestTask?
        return Future<URL, Error> { promise in
            requestTask = getFallbackFontWithRequestBuilder(name: name).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Gets a fallback font file.
     - GET /FallbackFont/Fonts/{name}
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter name: (path) The name of the fallback font file to get. 
     - returns: RequestBuilder<URL> 
     */
    open class func getFallbackFontWithRequestBuilder(name: String) -> RequestBuilder<URL> {
        var localVariablePath = "/FallbackFont/Fonts/{name}"
        let namePreEscape = "\(APIHelper.mapValueToPathItem(name))"
        let namePostEscape = namePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{name}", with: namePostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<URL>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Gets a list of available fallback font files.
     
     - returns: AnyPublisher<[FontFile], Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getFallbackFontList() -> AnyPublisher<[FontFile], Error> {
        var requestTask: RequestTask?
        return Future<[FontFile], Error> { promise in
            requestTask = getFallbackFontListWithRequestBuilder().execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Gets a list of available fallback font files.
     - GET /FallbackFont/Fonts
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - returns: RequestBuilder<[FontFile]> 
     */
    open class func getFallbackFontListWithRequestBuilder() -> RequestBuilder<[FontFile]> {
        let localVariablePath = "/FallbackFont/Fonts"
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[FontFile]>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Gets the remote subtitles.
     
     - parameter id: (path) The item id. 
     - returns: AnyPublisher<URL, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getRemoteSubtitles(id: String) -> AnyPublisher<URL, Error> {
        var requestTask: RequestTask?
        return Future<URL, Error> { promise in
            requestTask = getRemoteSubtitlesWithRequestBuilder(id: id).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Gets the remote subtitles.
     - GET /Providers/Subtitles/Subtitles/{id}
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter id: (path) The item id. 
     - returns: RequestBuilder<URL> 
     */
    open class func getRemoteSubtitlesWithRequestBuilder(id: String) -> RequestBuilder<URL> {
        var localVariablePath = "/Providers/Subtitles/Subtitles/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<URL>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Gets subtitles in a specified format.
     
     - parameter routeItemId: (path) The (route) item id. 
     - parameter routeMediaSourceId: (path) The (route) media source id. 
     - parameter routeIndex: (path) The (route) subtitle stream index. 
     - parameter routeFormat: (path) The (route) format of the returned subtitle. 
     - parameter itemId: (query) The item id. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter index: (query) The subtitle stream index. (optional)
     - parameter format: (query) The format of the returned subtitle. (optional)
     - parameter endPositionTicks: (query) Optional. The end position of the subtitle in ticks. (optional)
     - parameter copyTimestamps: (query) Optional. Whether to copy the timestamps. (optional, default to false)
     - parameter addVttTimeMap: (query) Optional. Whether to add a VTT time map. (optional, default to false)
     - parameter startPositionTicks: (query) The start position of the subtitle in ticks. (optional, default to 0)
     - returns: AnyPublisher<URL, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getSubtitle(routeItemId: String, routeMediaSourceId: String, routeIndex: Int, routeFormat: String, itemId: String? = nil, mediaSourceId: String? = nil, index: Int? = nil, format: String? = nil, endPositionTicks: Int64? = nil, copyTimestamps: Bool? = nil, addVttTimeMap: Bool? = nil, startPositionTicks: Int64? = nil) -> AnyPublisher<URL, Error> {
        var requestTask: RequestTask?
        return Future<URL, Error> { promise in
            requestTask = getSubtitleWithRequestBuilder(routeItemId: routeItemId, routeMediaSourceId: routeMediaSourceId, routeIndex: routeIndex, routeFormat: routeFormat, itemId: itemId, mediaSourceId: mediaSourceId, index: index, format: format, endPositionTicks: endPositionTicks, copyTimestamps: copyTimestamps, addVttTimeMap: addVttTimeMap, startPositionTicks: startPositionTicks).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Gets subtitles in a specified format.
     - GET /Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/Stream.{routeFormat}
     - parameter routeItemId: (path) The (route) item id. 
     - parameter routeMediaSourceId: (path) The (route) media source id. 
     - parameter routeIndex: (path) The (route) subtitle stream index. 
     - parameter routeFormat: (path) The (route) format of the returned subtitle. 
     - parameter itemId: (query) The item id. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter index: (query) The subtitle stream index. (optional)
     - parameter format: (query) The format of the returned subtitle. (optional)
     - parameter endPositionTicks: (query) Optional. The end position of the subtitle in ticks. (optional)
     - parameter copyTimestamps: (query) Optional. Whether to copy the timestamps. (optional, default to false)
     - parameter addVttTimeMap: (query) Optional. Whether to add a VTT time map. (optional, default to false)
     - parameter startPositionTicks: (query) The start position of the subtitle in ticks. (optional, default to 0)
     - returns: RequestBuilder<URL> 
     */
    open class func getSubtitleWithRequestBuilder(routeItemId: String, routeMediaSourceId: String, routeIndex: Int, routeFormat: String, itemId: String? = nil, mediaSourceId: String? = nil, index: Int? = nil, format: String? = nil, endPositionTicks: Int64? = nil, copyTimestamps: Bool? = nil, addVttTimeMap: Bool? = nil, startPositionTicks: Int64? = nil) -> RequestBuilder<URL> {
        var localVariablePath = "/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/Stream.{routeFormat}"
        let routeItemIdPreEscape = "\(APIHelper.mapValueToPathItem(routeItemId))"
        let routeItemIdPostEscape = routeItemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{routeItemId}", with: routeItemIdPostEscape, options: .literal, range: nil)
        let routeMediaSourceIdPreEscape = "\(APIHelper.mapValueToPathItem(routeMediaSourceId))"
        let routeMediaSourceIdPostEscape = routeMediaSourceIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{routeMediaSourceId}", with: routeMediaSourceIdPostEscape, options: .literal, range: nil)
        let routeIndexPreEscape = "\(APIHelper.mapValueToPathItem(routeIndex))"
        let routeIndexPostEscape = routeIndexPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{routeIndex}", with: routeIndexPostEscape, options: .literal, range: nil)
        let routeFormatPreEscape = "\(APIHelper.mapValueToPathItem(routeFormat))"
        let routeFormatPostEscape = routeFormatPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{routeFormat}", with: routeFormatPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "itemId": itemId?.encodeToJSON(),
            "mediaSourceId": mediaSourceId?.encodeToJSON(),
            "index": index?.encodeToJSON(),
            "format": format?.encodeToJSON(),
            "endPositionTicks": endPositionTicks?.encodeToJSON(),
            "copyTimestamps": copyTimestamps?.encodeToJSON(),
            "addVttTimeMap": addVttTimeMap?.encodeToJSON(),
            "startPositionTicks": startPositionTicks?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<URL>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Gets an HLS subtitle playlist.
     
     - parameter itemId: (path) The item id. 
     - parameter index: (path) The subtitle stream index. 
     - parameter mediaSourceId: (path) The media source id. 
     - parameter segmentLength: (query) The subtitle segment length. 
     - returns: AnyPublisher<URL, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getSubtitlePlaylist(itemId: String, index: Int, mediaSourceId: String, segmentLength: Int) -> AnyPublisher<URL, Error> {
        var requestTask: RequestTask?
        return Future<URL, Error> { promise in
            requestTask = getSubtitlePlaylistWithRequestBuilder(itemId: itemId, index: index, mediaSourceId: mediaSourceId, segmentLength: segmentLength).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Gets an HLS subtitle playlist.
     - GET /Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter index: (path) The subtitle stream index. 
     - parameter mediaSourceId: (path) The media source id. 
     - parameter segmentLength: (query) The subtitle segment length. 
     - returns: RequestBuilder<URL> 
     */
    open class func getSubtitlePlaylistWithRequestBuilder(itemId: String, index: Int, mediaSourceId: String, segmentLength: Int) -> RequestBuilder<URL> {
        var localVariablePath = "/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let indexPreEscape = "\(APIHelper.mapValueToPathItem(index))"
        let indexPostEscape = indexPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{index}", with: indexPostEscape, options: .literal, range: nil)
        let mediaSourceIdPreEscape = "\(APIHelper.mapValueToPathItem(mediaSourceId))"
        let mediaSourceIdPostEscape = mediaSourceIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{mediaSourceId}", with: mediaSourceIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "segmentLength": segmentLength.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<URL>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Gets subtitles in a specified format.
     
     - parameter routeItemId: (path) The (route) item id. 
     - parameter routeMediaSourceId: (path) The (route) media source id. 
     - parameter routeIndex: (path) The (route) subtitle stream index. 
     - parameter routeStartPositionTicks: (path) The (route) start position of the subtitle in ticks. 
     - parameter routeFormat: (path) The (route) format of the returned subtitle. 
     - parameter itemId: (query) The item id. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter index: (query) The subtitle stream index. (optional)
     - parameter startPositionTicks: (query) The start position of the subtitle in ticks. (optional)
     - parameter format: (query) The format of the returned subtitle. (optional)
     - parameter endPositionTicks: (query) Optional. The end position of the subtitle in ticks. (optional)
     - parameter copyTimestamps: (query) Optional. Whether to copy the timestamps. (optional, default to false)
     - parameter addVttTimeMap: (query) Optional. Whether to add a VTT time map. (optional, default to false)
     - returns: AnyPublisher<URL, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getSubtitleWithTicks(routeItemId: String, routeMediaSourceId: String, routeIndex: Int, routeStartPositionTicks: Int64, routeFormat: String, itemId: String? = nil, mediaSourceId: String? = nil, index: Int? = nil, startPositionTicks: Int64? = nil, format: String? = nil, endPositionTicks: Int64? = nil, copyTimestamps: Bool? = nil, addVttTimeMap: Bool? = nil) -> AnyPublisher<URL, Error> {
        var requestTask: RequestTask?
        return Future<URL, Error> { promise in
            requestTask = getSubtitleWithTicksWithRequestBuilder(routeItemId: routeItemId, routeMediaSourceId: routeMediaSourceId, routeIndex: routeIndex, routeStartPositionTicks: routeStartPositionTicks, routeFormat: routeFormat, itemId: itemId, mediaSourceId: mediaSourceId, index: index, startPositionTicks: startPositionTicks, format: format, endPositionTicks: endPositionTicks, copyTimestamps: copyTimestamps, addVttTimeMap: addVttTimeMap).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Gets subtitles in a specified format.
     - GET /Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/{routeStartPositionTicks}/Stream.{routeFormat}
     - parameter routeItemId: (path) The (route) item id. 
     - parameter routeMediaSourceId: (path) The (route) media source id. 
     - parameter routeIndex: (path) The (route) subtitle stream index. 
     - parameter routeStartPositionTicks: (path) The (route) start position of the subtitle in ticks. 
     - parameter routeFormat: (path) The (route) format of the returned subtitle. 
     - parameter itemId: (query) The item id. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter index: (query) The subtitle stream index. (optional)
     - parameter startPositionTicks: (query) The start position of the subtitle in ticks. (optional)
     - parameter format: (query) The format of the returned subtitle. (optional)
     - parameter endPositionTicks: (query) Optional. The end position of the subtitle in ticks. (optional)
     - parameter copyTimestamps: (query) Optional. Whether to copy the timestamps. (optional, default to false)
     - parameter addVttTimeMap: (query) Optional. Whether to add a VTT time map. (optional, default to false)
     - returns: RequestBuilder<URL> 
     */
    open class func getSubtitleWithTicksWithRequestBuilder(routeItemId: String, routeMediaSourceId: String, routeIndex: Int, routeStartPositionTicks: Int64, routeFormat: String, itemId: String? = nil, mediaSourceId: String? = nil, index: Int? = nil, startPositionTicks: Int64? = nil, format: String? = nil, endPositionTicks: Int64? = nil, copyTimestamps: Bool? = nil, addVttTimeMap: Bool? = nil) -> RequestBuilder<URL> {
        var localVariablePath = "/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/{routeStartPositionTicks}/Stream.{routeFormat}"
        let routeItemIdPreEscape = "\(APIHelper.mapValueToPathItem(routeItemId))"
        let routeItemIdPostEscape = routeItemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{routeItemId}", with: routeItemIdPostEscape, options: .literal, range: nil)
        let routeMediaSourceIdPreEscape = "\(APIHelper.mapValueToPathItem(routeMediaSourceId))"
        let routeMediaSourceIdPostEscape = routeMediaSourceIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{routeMediaSourceId}", with: routeMediaSourceIdPostEscape, options: .literal, range: nil)
        let routeIndexPreEscape = "\(APIHelper.mapValueToPathItem(routeIndex))"
        let routeIndexPostEscape = routeIndexPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{routeIndex}", with: routeIndexPostEscape, options: .literal, range: nil)
        let routeStartPositionTicksPreEscape = "\(APIHelper.mapValueToPathItem(routeStartPositionTicks))"
        let routeStartPositionTicksPostEscape = routeStartPositionTicksPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{routeStartPositionTicks}", with: routeStartPositionTicksPostEscape, options: .literal, range: nil)
        let routeFormatPreEscape = "\(APIHelper.mapValueToPathItem(routeFormat))"
        let routeFormatPostEscape = routeFormatPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{routeFormat}", with: routeFormatPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "itemId": itemId?.encodeToJSON(),
            "mediaSourceId": mediaSourceId?.encodeToJSON(),
            "index": index?.encodeToJSON(),
            "startPositionTicks": startPositionTicks?.encodeToJSON(),
            "format": format?.encodeToJSON(),
            "endPositionTicks": endPositionTicks?.encodeToJSON(),
            "copyTimestamps": copyTimestamps?.encodeToJSON(),
            "addVttTimeMap": addVttTimeMap?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<URL>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Search remote subtitles.
     
     - parameter itemId: (path) The item id. 
     - parameter language: (path) The language of the subtitles. 
     - parameter isPerfectMatch: (query) Optional. Only show subtitles which are a perfect match. (optional)
     - returns: AnyPublisher<[RemoteSubtitleInfo], Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func searchRemoteSubtitles(itemId: String, language: String, isPerfectMatch: Bool? = nil) -> AnyPublisher<[RemoteSubtitleInfo], Error> {
        var requestTask: RequestTask?
        return Future<[RemoteSubtitleInfo], Error> { promise in
            requestTask = searchRemoteSubtitlesWithRequestBuilder(itemId: itemId, language: language, isPerfectMatch: isPerfectMatch).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Search remote subtitles.
     - GET /Items/{itemId}/RemoteSearch/Subtitles/{language}
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter language: (path) The language of the subtitles. 
     - parameter isPerfectMatch: (query) Optional. Only show subtitles which are a perfect match. (optional)
     - returns: RequestBuilder<[RemoteSubtitleInfo]> 
     */
    open class func searchRemoteSubtitlesWithRequestBuilder(itemId: String, language: String, isPerfectMatch: Bool? = nil) -> RequestBuilder<[RemoteSubtitleInfo]> {
        var localVariablePath = "/Items/{itemId}/RemoteSearch/Subtitles/{language}"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let languagePreEscape = "\(APIHelper.mapValueToPathItem(language))"
        let languagePostEscape = languagePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{language}", with: languagePostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "isPerfectMatch": isPerfectMatch?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[RemoteSubtitleInfo]>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Upload an external subtitle file.
     
     - parameter itemId: (path) The item the subtitle belongs to. 
     - parameter uploadSubtitleRequest: (body) The request body. 
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func uploadSubtitle(itemId: String, uploadSubtitleRequest: UploadSubtitleRequest) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = uploadSubtitleWithRequestBuilder(itemId: itemId, uploadSubtitleRequest: uploadSubtitleRequest).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Upload an external subtitle file.
     - POST /Videos/{itemId}/Subtitles
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item the subtitle belongs to. 
     - parameter uploadSubtitleRequest: (body) The request body. 
     - returns: RequestBuilder<Void> 
     */
    open class func uploadSubtitleWithRequestBuilder(itemId: String, uploadSubtitleRequest: UploadSubtitleRequest) -> RequestBuilder<Void> {
        var localVariablePath = "/Videos/{itemId}/Subtitles"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: uploadSubtitleRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }
}
