//
// PlaystateAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(Combine)
import Combine
#endif
#if canImport(AnyCodable)
import AnyCodable
#endif

open class PlaystateAPI {

    /**
     Marks an item as played for user.
     
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - parameter datePlayed: (query) Optional. The date the item was played. (optional)
     - returns: AnyPublisher<UserItemDataDto, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func markPlayedItem(userId: String, itemId: String, datePlayed: Date? = nil) -> AnyPublisher<UserItemDataDto, Error> {
        var requestTask: RequestTask?
        return Future<UserItemDataDto, Error> { promise in
            requestTask = markPlayedItemWithRequestBuilder(userId: userId, itemId: itemId, datePlayed: datePlayed).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Marks an item as played for user.
     - POST /Users/{userId}/PlayedItems/{itemId}
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - parameter datePlayed: (query) Optional. The date the item was played. (optional)
     - returns: RequestBuilder<UserItemDataDto> 
     */
    open class func markPlayedItemWithRequestBuilder(userId: String, itemId: String, datePlayed: Date? = nil) -> RequestBuilder<UserItemDataDto> {
        var localVariablePath = "/Users/{userId}/PlayedItems/{itemId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "datePlayed": datePlayed?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<UserItemDataDto>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Marks an item as unplayed for user.
     
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - returns: AnyPublisher<UserItemDataDto, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func markUnplayedItem(userId: String, itemId: String) -> AnyPublisher<UserItemDataDto, Error> {
        var requestTask: RequestTask?
        return Future<UserItemDataDto, Error> { promise in
            requestTask = markUnplayedItemWithRequestBuilder(userId: userId, itemId: itemId).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Marks an item as unplayed for user.
     - DELETE /Users/{userId}/PlayedItems/{itemId}
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - returns: RequestBuilder<UserItemDataDto> 
     */
    open class func markUnplayedItemWithRequestBuilder(userId: String, itemId: String) -> RequestBuilder<UserItemDataDto> {
        var localVariablePath = "/Users/{userId}/PlayedItems/{itemId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<UserItemDataDto>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Reports a user's playback progress.
     
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - parameter mediaSourceId: (query) The id of the MediaSource. (optional)
     - parameter positionTicks: (query) Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter volumeLevel: (query) Scale of 0-100. (optional)
     - parameter playMethod: (query) The play method. (optional)
     - parameter liveStreamId: (query) The live stream id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter repeatMode: (query) The repeat mode. (optional)
     - parameter isPaused: (query) Indicates if the player is paused. (optional, default to false)
     - parameter isMuted: (query) Indicates if the player is muted. (optional, default to false)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func onPlaybackProgress(userId: String, itemId: String, mediaSourceId: String? = nil, positionTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, volumeLevel: Int? = nil, playMethod: PlayMethod? = nil, liveStreamId: String? = nil, playSessionId: String? = nil, repeatMode: RepeatMode? = nil, isPaused: Bool? = nil, isMuted: Bool? = nil) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = onPlaybackProgressWithRequestBuilder(userId: userId, itemId: itemId, mediaSourceId: mediaSourceId, positionTicks: positionTicks, audioStreamIndex: audioStreamIndex, subtitleStreamIndex: subtitleStreamIndex, volumeLevel: volumeLevel, playMethod: playMethod, liveStreamId: liveStreamId, playSessionId: playSessionId, repeatMode: repeatMode, isPaused: isPaused, isMuted: isMuted).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Reports a user's playback progress.
     - POST /Users/{userId}/PlayingItems/{itemId}/Progress
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - parameter mediaSourceId: (query) The id of the MediaSource. (optional)
     - parameter positionTicks: (query) Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter volumeLevel: (query) Scale of 0-100. (optional)
     - parameter playMethod: (query) The play method. (optional)
     - parameter liveStreamId: (query) The live stream id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter repeatMode: (query) The repeat mode. (optional)
     - parameter isPaused: (query) Indicates if the player is paused. (optional, default to false)
     - parameter isMuted: (query) Indicates if the player is muted. (optional, default to false)
     - returns: RequestBuilder<Void> 
     */
    open class func onPlaybackProgressWithRequestBuilder(userId: String, itemId: String, mediaSourceId: String? = nil, positionTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, volumeLevel: Int? = nil, playMethod: PlayMethod? = nil, liveStreamId: String? = nil, playSessionId: String? = nil, repeatMode: RepeatMode? = nil, isPaused: Bool? = nil, isMuted: Bool? = nil) -> RequestBuilder<Void> {
        var localVariablePath = "/Users/{userId}/PlayingItems/{itemId}/Progress"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "mediaSourceId": mediaSourceId?.encodeToJSON(),
            "positionTicks": positionTicks?.encodeToJSON(),
            "audioStreamIndex": audioStreamIndex?.encodeToJSON(),
            "subtitleStreamIndex": subtitleStreamIndex?.encodeToJSON(),
            "volumeLevel": volumeLevel?.encodeToJSON(),
            "playMethod": playMethod?.encodeToJSON(),
            "liveStreamId": liveStreamId?.encodeToJSON(),
            "playSessionId": playSessionId?.encodeToJSON(),
            "repeatMode": repeatMode?.encodeToJSON(),
            "isPaused": isPaused?.encodeToJSON(),
            "isMuted": isMuted?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Reports that a user has begun playing an item.
     
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - parameter mediaSourceId: (query) The id of the MediaSource. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter playMethod: (query) The play method. (optional)
     - parameter liveStreamId: (query) The live stream id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter canSeek: (query) Indicates if the client can seek. (optional, default to false)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func onPlaybackStart(userId: String, itemId: String, mediaSourceId: String? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, playMethod: PlayMethod? = nil, liveStreamId: String? = nil, playSessionId: String? = nil, canSeek: Bool? = nil) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = onPlaybackStartWithRequestBuilder(userId: userId, itemId: itemId, mediaSourceId: mediaSourceId, audioStreamIndex: audioStreamIndex, subtitleStreamIndex: subtitleStreamIndex, playMethod: playMethod, liveStreamId: liveStreamId, playSessionId: playSessionId, canSeek: canSeek).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Reports that a user has begun playing an item.
     - POST /Users/{userId}/PlayingItems/{itemId}
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - parameter mediaSourceId: (query) The id of the MediaSource. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter playMethod: (query) The play method. (optional)
     - parameter liveStreamId: (query) The live stream id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter canSeek: (query) Indicates if the client can seek. (optional, default to false)
     - returns: RequestBuilder<Void> 
     */
    open class func onPlaybackStartWithRequestBuilder(userId: String, itemId: String, mediaSourceId: String? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, playMethod: PlayMethod? = nil, liveStreamId: String? = nil, playSessionId: String? = nil, canSeek: Bool? = nil) -> RequestBuilder<Void> {
        var localVariablePath = "/Users/{userId}/PlayingItems/{itemId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "mediaSourceId": mediaSourceId?.encodeToJSON(),
            "audioStreamIndex": audioStreamIndex?.encodeToJSON(),
            "subtitleStreamIndex": subtitleStreamIndex?.encodeToJSON(),
            "playMethod": playMethod?.encodeToJSON(),
            "liveStreamId": liveStreamId?.encodeToJSON(),
            "playSessionId": playSessionId?.encodeToJSON(),
            "canSeek": canSeek?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Reports that a user has stopped playing an item.
     
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - parameter mediaSourceId: (query) The id of the MediaSource. (optional)
     - parameter nextMediaType: (query) The next media type that will play. (optional)
     - parameter positionTicks: (query) Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms. (optional)
     - parameter liveStreamId: (query) The live stream id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func onPlaybackStopped(userId: String, itemId: String, mediaSourceId: String? = nil, nextMediaType: String? = nil, positionTicks: Int64? = nil, liveStreamId: String? = nil, playSessionId: String? = nil) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = onPlaybackStoppedWithRequestBuilder(userId: userId, itemId: itemId, mediaSourceId: mediaSourceId, nextMediaType: nextMediaType, positionTicks: positionTicks, liveStreamId: liveStreamId, playSessionId: playSessionId).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Reports that a user has stopped playing an item.
     - DELETE /Users/{userId}/PlayingItems/{itemId}
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter userId: (path) User id. 
     - parameter itemId: (path) Item id. 
     - parameter mediaSourceId: (query) The id of the MediaSource. (optional)
     - parameter nextMediaType: (query) The next media type that will play. (optional)
     - parameter positionTicks: (query) Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms. (optional)
     - parameter liveStreamId: (query) The live stream id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func onPlaybackStoppedWithRequestBuilder(userId: String, itemId: String, mediaSourceId: String? = nil, nextMediaType: String? = nil, positionTicks: Int64? = nil, liveStreamId: String? = nil, playSessionId: String? = nil) -> RequestBuilder<Void> {
        var localVariablePath = "/Users/{userId}/PlayingItems/{itemId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "mediaSourceId": mediaSourceId?.encodeToJSON(),
            "nextMediaType": nextMediaType?.encodeToJSON(),
            "positionTicks": positionTicks?.encodeToJSON(),
            "liveStreamId": liveStreamId?.encodeToJSON(),
            "playSessionId": playSessionId?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Pings a playback session.
     
     - parameter playSessionId: (query) Playback session id. 
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func pingPlaybackSession(playSessionId: String) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = pingPlaybackSessionWithRequestBuilder(playSessionId: playSessionId).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Pings a playback session.
     - POST /Sessions/Playing/Ping
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter playSessionId: (query) Playback session id. 
     - returns: RequestBuilder<Void> 
     */
    open class func pingPlaybackSessionWithRequestBuilder(playSessionId: String) -> RequestBuilder<Void> {
        let localVariablePath = "/Sessions/Playing/Ping"
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "playSessionId": playSessionId.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Reports playback progress within a session.
     
     - parameter reportPlaybackProgressRequest: (body) The playback progress info. (optional)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func reportPlaybackProgress(reportPlaybackProgressRequest: ReportPlaybackProgressRequest? = nil) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = reportPlaybackProgressWithRequestBuilder(reportPlaybackProgressRequest: reportPlaybackProgressRequest).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Reports playback progress within a session.
     - POST /Sessions/Playing/Progress
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter reportPlaybackProgressRequest: (body) The playback progress info. (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func reportPlaybackProgressWithRequestBuilder(reportPlaybackProgressRequest: ReportPlaybackProgressRequest? = nil) -> RequestBuilder<Void> {
        let localVariablePath = "/Sessions/Playing/Progress"
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: reportPlaybackProgressRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Reports playback has started within a session.
     
     - parameter reportPlaybackStartRequest: (body) The playback start info. (optional)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func reportPlaybackStart(reportPlaybackStartRequest: ReportPlaybackStartRequest? = nil) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = reportPlaybackStartWithRequestBuilder(reportPlaybackStartRequest: reportPlaybackStartRequest).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Reports playback has started within a session.
     - POST /Sessions/Playing
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter reportPlaybackStartRequest: (body) The playback start info. (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func reportPlaybackStartWithRequestBuilder(reportPlaybackStartRequest: ReportPlaybackStartRequest? = nil) -> RequestBuilder<Void> {
        let localVariablePath = "/Sessions/Playing"
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: reportPlaybackStartRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Reports playback has stopped within a session.
     
     - parameter reportPlaybackStoppedRequest: (body) The playback stop info. (optional)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func reportPlaybackStopped(reportPlaybackStoppedRequest: ReportPlaybackStoppedRequest? = nil) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = reportPlaybackStoppedWithRequestBuilder(reportPlaybackStoppedRequest: reportPlaybackStoppedRequest).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Reports playback has stopped within a session.
     - POST /Sessions/Playing/Stopped
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter reportPlaybackStoppedRequest: (body) The playback stop info. (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func reportPlaybackStoppedWithRequestBuilder(reportPlaybackStoppedRequest: ReportPlaybackStoppedRequest? = nil) -> RequestBuilder<Void> {
        let localVariablePath = "/Sessions/Playing/Stopped"
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: reportPlaybackStoppedRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }
}
