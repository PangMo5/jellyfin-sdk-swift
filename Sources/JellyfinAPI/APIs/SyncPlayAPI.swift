//
// SyncPlayAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
#if canImport(Combine)
import Combine
#endif

open class SyncPlayAPI {
    /**
     Notify SyncPlay group that member is buffering.
     
     - parameter syncPlayBufferingRequest: (body) The player status. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayBuffering(syncPlayBufferingRequest: SyncPlayBufferingRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayBufferingWithRequestBuilder(syncPlayBufferingRequest: syncPlayBufferingRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Notify SyncPlay group that member is buffering.
     - POST /SyncPlay/Buffering
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayBufferingRequest: (body) The player status. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayBufferingWithRequestBuilder(syncPlayBufferingRequest: SyncPlayBufferingRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Buffering"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayBufferingRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Create a new SyncPlay group.
     
     - parameter syncPlayCreateGroupRequest: (body) The settings of the new group. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayCreateGroup(syncPlayCreateGroupRequest: SyncPlayCreateGroupRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayCreateGroupWithRequestBuilder(syncPlayCreateGroupRequest: syncPlayCreateGroupRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Create a new SyncPlay group.
     - POST /SyncPlay/New
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayCreateGroupRequest: (body) The settings of the new group. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayCreateGroupWithRequestBuilder(syncPlayCreateGroupRequest: SyncPlayCreateGroupRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/New"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayCreateGroupRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Gets all SyncPlay groups.
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<[GroupInfoDto], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayGetGroups(apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<[GroupInfoDto], Error> {
        return Future<[GroupInfoDto], Error>.init { promise in
            syncPlayGetGroupsWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Gets all SyncPlay groups.
     - GET /SyncPlay/List
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - returns: RequestBuilder<[GroupInfoDto]> 
     */
    open class func syncPlayGetGroupsWithRequestBuilder() -> RequestBuilder<[GroupInfoDto]> {
        let urlPath = "/SyncPlay/List"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<[GroupInfoDto]>.Type = JellyfinAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Join an existing SyncPlay group.
     
     - parameter syncPlayJoinGroupRequest: (body) The group to join. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayJoinGroup(syncPlayJoinGroupRequest: SyncPlayJoinGroupRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayJoinGroupWithRequestBuilder(syncPlayJoinGroupRequest: syncPlayJoinGroupRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Join an existing SyncPlay group.
     - POST /SyncPlay/Join
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayJoinGroupRequest: (body) The group to join. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayJoinGroupWithRequestBuilder(syncPlayJoinGroupRequest: SyncPlayJoinGroupRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Join"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayJoinGroupRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Leave the joined SyncPlay group.
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayLeaveGroup(apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayLeaveGroupWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Leave the joined SyncPlay group.
     - POST /SyncPlay/Leave
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayLeaveGroupWithRequestBuilder() -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Leave"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request to move an item in the playlist in SyncPlay group.
     
     - parameter syncPlayMovePlaylistItemRequest: (body) The new position for the item. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayMovePlaylistItem(syncPlayMovePlaylistItemRequest: SyncPlayMovePlaylistItemRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayMovePlaylistItemWithRequestBuilder(syncPlayMovePlaylistItemRequest: syncPlayMovePlaylistItemRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request to move an item in the playlist in SyncPlay group.
     - POST /SyncPlay/MovePlaylistItem
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayMovePlaylistItemRequest: (body) The new position for the item. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayMovePlaylistItemWithRequestBuilder(syncPlayMovePlaylistItemRequest: SyncPlayMovePlaylistItemRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/MovePlaylistItem"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayMovePlaylistItemRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request next item in SyncPlay group.
     
     - parameter syncPlayNextItemRequest: (body) The current item information. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayNextItem(syncPlayNextItemRequest: SyncPlayNextItemRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayNextItemWithRequestBuilder(syncPlayNextItemRequest: syncPlayNextItemRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request next item in SyncPlay group.
     - POST /SyncPlay/NextItem
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayNextItemRequest: (body) The current item information. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayNextItemWithRequestBuilder(syncPlayNextItemRequest: SyncPlayNextItemRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/NextItem"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayNextItemRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request pause in SyncPlay group.
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayPause(apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayPauseWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request pause in SyncPlay group.
     - POST /SyncPlay/Pause
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayPauseWithRequestBuilder() -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Pause"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update session ping.
     
     - parameter syncPlayPingRequest: (body) The new ping. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayPing(syncPlayPingRequest: SyncPlayPingRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayPingWithRequestBuilder(syncPlayPingRequest: syncPlayPingRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Update session ping.
     - POST /SyncPlay/Ping
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayPingRequest: (body) The new ping. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayPingWithRequestBuilder(syncPlayPingRequest: SyncPlayPingRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Ping"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayPingRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request previous item in SyncPlay group.
     
     - parameter syncPlayPreviousItemRequest: (body) The current item information. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayPreviousItem(syncPlayPreviousItemRequest: SyncPlayPreviousItemRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayPreviousItemWithRequestBuilder(syncPlayPreviousItemRequest: syncPlayPreviousItemRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request previous item in SyncPlay group.
     - POST /SyncPlay/PreviousItem
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayPreviousItemRequest: (body) The current item information. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayPreviousItemWithRequestBuilder(syncPlayPreviousItemRequest: SyncPlayPreviousItemRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/PreviousItem"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayPreviousItemRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request to queue items to the playlist of a SyncPlay group.
     
     - parameter syncPlayQueueRequest: (body) The items to add. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayQueue(syncPlayQueueRequest: SyncPlayQueueRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayQueueWithRequestBuilder(syncPlayQueueRequest: syncPlayQueueRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request to queue items to the playlist of a SyncPlay group.
     - POST /SyncPlay/Queue
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayQueueRequest: (body) The items to add. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayQueueWithRequestBuilder(syncPlayQueueRequest: SyncPlayQueueRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Queue"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayQueueRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Notify SyncPlay group that member is ready for playback.
     
     - parameter syncPlayReadyRequest: (body) The player status. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayReady(syncPlayReadyRequest: SyncPlayReadyRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayReadyWithRequestBuilder(syncPlayReadyRequest: syncPlayReadyRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Notify SyncPlay group that member is ready for playback.
     - POST /SyncPlay/Ready
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayReadyRequest: (body) The player status. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayReadyWithRequestBuilder(syncPlayReadyRequest: SyncPlayReadyRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Ready"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayReadyRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request to remove items from the playlist in SyncPlay group.
     
     - parameter syncPlayRemoveFromPlaylistRequest: (body) The items to remove. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayRemoveFromPlaylist(syncPlayRemoveFromPlaylistRequest: SyncPlayRemoveFromPlaylistRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayRemoveFromPlaylistWithRequestBuilder(syncPlayRemoveFromPlaylistRequest: syncPlayRemoveFromPlaylistRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request to remove items from the playlist in SyncPlay group.
     - POST /SyncPlay/RemoveFromPlaylist
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlayRemoveFromPlaylistRequest: (body) The items to remove. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayRemoveFromPlaylistWithRequestBuilder(syncPlayRemoveFromPlaylistRequest: SyncPlayRemoveFromPlaylistRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/RemoveFromPlaylist"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlayRemoveFromPlaylistRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request seek in SyncPlay group.
     
     - parameter syncPlaySeekRequest: (body) The new playback position. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlaySeek(syncPlaySeekRequest: SyncPlaySeekRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlaySeekWithRequestBuilder(syncPlaySeekRequest: syncPlaySeekRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request seek in SyncPlay group.
     - POST /SyncPlay/Seek
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlaySeekRequest: (body) The new playback position. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlaySeekWithRequestBuilder(syncPlaySeekRequest: SyncPlaySeekRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Seek"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlaySeekRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request SyncPlay group to ignore member during group-wait.
     
     - parameter syncPlaySetIgnoreWaitRequest: (body) The settings to set. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlaySetIgnoreWait(syncPlaySetIgnoreWaitRequest: SyncPlaySetIgnoreWaitRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlaySetIgnoreWaitWithRequestBuilder(syncPlaySetIgnoreWaitRequest: syncPlaySetIgnoreWaitRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request SyncPlay group to ignore member during group-wait.
     - POST /SyncPlay/SetIgnoreWait
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlaySetIgnoreWaitRequest: (body) The settings to set. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlaySetIgnoreWaitWithRequestBuilder(syncPlaySetIgnoreWaitRequest: SyncPlaySetIgnoreWaitRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/SetIgnoreWait"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlaySetIgnoreWaitRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request to set new playlist in SyncPlay group.
     
     - parameter syncPlaySetNewQueueRequest: (body) The new playlist to play in the group. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlaySetNewQueue(syncPlaySetNewQueueRequest: SyncPlaySetNewQueueRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlaySetNewQueueWithRequestBuilder(syncPlaySetNewQueueRequest: syncPlaySetNewQueueRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request to set new playlist in SyncPlay group.
     - POST /SyncPlay/SetNewQueue
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlaySetNewQueueRequest: (body) The new playlist to play in the group. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlaySetNewQueueWithRequestBuilder(syncPlaySetNewQueueRequest: SyncPlaySetNewQueueRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/SetNewQueue"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlaySetNewQueueRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request to change playlist item in SyncPlay group.
     
     - parameter syncPlaySetPlaylistItemRequest: (body) The new item to play. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlaySetPlaylistItem(syncPlaySetPlaylistItemRequest: SyncPlaySetPlaylistItemRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlaySetPlaylistItemWithRequestBuilder(syncPlaySetPlaylistItemRequest: syncPlaySetPlaylistItemRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request to change playlist item in SyncPlay group.
     - POST /SyncPlay/SetPlaylistItem
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlaySetPlaylistItemRequest: (body) The new item to play. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlaySetPlaylistItemWithRequestBuilder(syncPlaySetPlaylistItemRequest: SyncPlaySetPlaylistItemRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/SetPlaylistItem"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlaySetPlaylistItemRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request to set repeat mode in SyncPlay group.
     
     - parameter syncPlaySetRepeatModeRequest: (body) The new repeat mode. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlaySetRepeatMode(syncPlaySetRepeatModeRequest: SyncPlaySetRepeatModeRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlaySetRepeatModeWithRequestBuilder(syncPlaySetRepeatModeRequest: syncPlaySetRepeatModeRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request to set repeat mode in SyncPlay group.
     - POST /SyncPlay/SetRepeatMode
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlaySetRepeatModeRequest: (body) The new repeat mode. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlaySetRepeatModeWithRequestBuilder(syncPlaySetRepeatModeRequest: SyncPlaySetRepeatModeRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/SetRepeatMode"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlaySetRepeatModeRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request to set shuffle mode in SyncPlay group.
     
     - parameter syncPlaySetShuffleModeRequest: (body) The new shuffle mode. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlaySetShuffleMode(syncPlaySetShuffleModeRequest: SyncPlaySetShuffleModeRequest, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlaySetShuffleModeWithRequestBuilder(syncPlaySetShuffleModeRequest: syncPlaySetShuffleModeRequest).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request to set shuffle mode in SyncPlay group.
     - POST /SyncPlay/SetShuffleMode
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter syncPlaySetShuffleModeRequest: (body) The new shuffle mode. 
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlaySetShuffleModeWithRequestBuilder(syncPlaySetShuffleModeRequest: SyncPlaySetShuffleModeRequest) -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/SetShuffleMode"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncPlaySetShuffleModeRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request stop in SyncPlay group.
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayStop(apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayStopWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request stop in SyncPlay group.
     - POST /SyncPlay/Stop
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayStopWithRequestBuilder() -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Stop"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Request unpause in SyncPlay group.
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func syncPlayUnpause(apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            syncPlayUnpauseWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Request unpause in SyncPlay group.
     - POST /SyncPlay/Unpause
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - returns: RequestBuilder<Void> 
     */
    open class func syncPlayUnpauseWithRequestBuilder() -> RequestBuilder<Void> {
        let urlPath = "/SyncPlay/Unpause"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
