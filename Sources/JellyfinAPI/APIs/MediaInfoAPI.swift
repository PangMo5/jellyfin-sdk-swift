//
// MediaInfoAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(Combine)
import Combine
#endif
#if canImport(AnyCodable)
import AnyCodable
#endif

open class MediaInfoAPI {

    /**
     Closes a media source.
     
     - parameter liveStreamId: (query) The livestream id. 
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func closeLiveStream(liveStreamId: String) -> AnyPublisher<Void, Error> {
        var requestTask: RequestTask?
        return Future<Void, Error> { promise in
            requestTask = closeLiveStreamWithRequestBuilder(liveStreamId: liveStreamId).execute { result in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Closes a media source.
     - POST /LiveStreams/Close
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter liveStreamId: (query) The livestream id. 
     - returns: RequestBuilder<Void> 
     */
    open class func closeLiveStreamWithRequestBuilder(liveStreamId: String) -> RequestBuilder<Void> {
        let localVariablePath = "/LiveStreams/Close"
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "liveStreamId": liveStreamId.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = JellyfinAPIAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Tests the network with a request with the size of the bitrate.
     
     - parameter size: (query) The bitrate. Defaults to 102400. (optional, default to 102400)
     - returns: AnyPublisher<URL, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getBitrateTestBytes(size: Int? = nil) -> AnyPublisher<URL, Error> {
        var requestTask: RequestTask?
        return Future<URL, Error> { promise in
            requestTask = getBitrateTestBytesWithRequestBuilder(size: size).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Tests the network with a request with the size of the bitrate.
     - GET /Playback/BitrateTest
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter size: (query) The bitrate. Defaults to 102400. (optional, default to 102400)
     - returns: RequestBuilder<URL> 
     */
    open class func getBitrateTestBytesWithRequestBuilder(size: Int? = nil) -> RequestBuilder<URL> {
        let localVariablePath = "/Playback/BitrateTest"
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "size": size?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<URL>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Gets live playback media info for an item.
     
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. 
     - returns: AnyPublisher<PlaybackInfoResponse, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlaybackInfo(itemId: String, userId: String) -> AnyPublisher<PlaybackInfoResponse, Error> {
        var requestTask: RequestTask?
        return Future<PlaybackInfoResponse, Error> { promise in
            requestTask = getPlaybackInfoWithRequestBuilder(itemId: itemId, userId: userId).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Gets live playback media info for an item.
     - GET /Items/{itemId}/PlaybackInfo
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. 
     - returns: RequestBuilder<PlaybackInfoResponse> 
     */
    open class func getPlaybackInfoWithRequestBuilder(itemId: String, userId: String) -> RequestBuilder<PlaybackInfoResponse> {
        var localVariablePath = "/Items/{itemId}/PlaybackInfo"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "userId": userId.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PlaybackInfoResponse>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Gets live playback media info for an item.
     
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter liveStreamId: (query) The livestream id. (optional)
     - parameter autoOpenLiveStream: (query) Whether to auto open the livestream. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter enableTranscoding: (query) Whether to enable transcoding. Default: true. (optional)
     - parameter allowVideoStreamCopy: (query) Whether to allow to copy the video stream. Default: true. (optional)
     - parameter allowAudioStreamCopy: (query) Whether to allow to copy the audio stream. Default: true. (optional)
     - parameter getPostedPlaybackInfoRequest: (body) The playback info. (optional)
     - returns: AnyPublisher<PlaybackInfoResponse, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPostedPlaybackInfo(itemId: String, userId: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, mediaSourceId: String? = nil, liveStreamId: String? = nil, autoOpenLiveStream: Bool? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, enableTranscoding: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, getPostedPlaybackInfoRequest: GetPostedPlaybackInfoRequest? = nil) -> AnyPublisher<PlaybackInfoResponse, Error> {
        var requestTask: RequestTask?
        return Future<PlaybackInfoResponse, Error> { promise in
            requestTask = getPostedPlaybackInfoWithRequestBuilder(itemId: itemId, userId: userId, maxStreamingBitrate: maxStreamingBitrate, startTimeTicks: startTimeTicks, audioStreamIndex: audioStreamIndex, subtitleStreamIndex: subtitleStreamIndex, maxAudioChannels: maxAudioChannels, mediaSourceId: mediaSourceId, liveStreamId: liveStreamId, autoOpenLiveStream: autoOpenLiveStream, enableDirectPlay: enableDirectPlay, enableDirectStream: enableDirectStream, enableTranscoding: enableTranscoding, allowVideoStreamCopy: allowVideoStreamCopy, allowAudioStreamCopy: allowAudioStreamCopy, getPostedPlaybackInfoRequest: getPostedPlaybackInfoRequest).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Gets live playback media info for an item.
     - POST /Items/{itemId}/PlaybackInfo
     - For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.  Query parameters are obsolete.
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter liveStreamId: (query) The livestream id. (optional)
     - parameter autoOpenLiveStream: (query) Whether to auto open the livestream. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter enableTranscoding: (query) Whether to enable transcoding. Default: true. (optional)
     - parameter allowVideoStreamCopy: (query) Whether to allow to copy the video stream. Default: true. (optional)
     - parameter allowAudioStreamCopy: (query) Whether to allow to copy the audio stream. Default: true. (optional)
     - parameter getPostedPlaybackInfoRequest: (body) The playback info. (optional)
     - returns: RequestBuilder<PlaybackInfoResponse> 
     */
    open class func getPostedPlaybackInfoWithRequestBuilder(itemId: String, userId: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, mediaSourceId: String? = nil, liveStreamId: String? = nil, autoOpenLiveStream: Bool? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, enableTranscoding: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, getPostedPlaybackInfoRequest: GetPostedPlaybackInfoRequest? = nil) -> RequestBuilder<PlaybackInfoResponse> {
        var localVariablePath = "/Items/{itemId}/PlaybackInfo"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: getPostedPlaybackInfoRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "userId": userId?.encodeToJSON(),
            "maxStreamingBitrate": maxStreamingBitrate?.encodeToJSON(),
            "startTimeTicks": startTimeTicks?.encodeToJSON(),
            "audioStreamIndex": audioStreamIndex?.encodeToJSON(),
            "subtitleStreamIndex": subtitleStreamIndex?.encodeToJSON(),
            "maxAudioChannels": maxAudioChannels?.encodeToJSON(),
            "mediaSourceId": mediaSourceId?.encodeToJSON(),
            "liveStreamId": liveStreamId?.encodeToJSON(),
            "autoOpenLiveStream": autoOpenLiveStream?.encodeToJSON(),
            "enableDirectPlay": enableDirectPlay?.encodeToJSON(),
            "enableDirectStream": enableDirectStream?.encodeToJSON(),
            "enableTranscoding": enableTranscoding?.encodeToJSON(),
            "allowVideoStreamCopy": allowVideoStreamCopy?.encodeToJSON(),
            "allowAudioStreamCopy": allowAudioStreamCopy?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PlaybackInfoResponse>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     Opens a media source.
     
     - parameter openToken: (query) The open token. (optional)
     - parameter userId: (query) The user id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter itemId: (query) The item id. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter openLiveStreamRequest: (body) The open live stream dto. (optional)
     - returns: AnyPublisher<LiveStreamResponse, Error>
     */
    #if canImport(Combine)
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func openLiveStream(openToken: String? = nil, userId: String? = nil, playSessionId: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, itemId: String? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, openLiveStreamRequest: OpenLiveStreamRequest? = nil) -> AnyPublisher<LiveStreamResponse, Error> {
        var requestTask: RequestTask?
        return Future<LiveStreamResponse, Error> { promise in
            requestTask = openLiveStreamWithRequestBuilder(openToken: openToken, userId: userId, playSessionId: playSessionId, maxStreamingBitrate: maxStreamingBitrate, startTimeTicks: startTimeTicks, audioStreamIndex: audioStreamIndex, subtitleStreamIndex: subtitleStreamIndex, maxAudioChannels: maxAudioChannels, itemId: itemId, enableDirectPlay: enableDirectPlay, enableDirectStream: enableDirectStream, openLiveStreamRequest: openLiveStreamRequest).execute { result in
                switch result {
                case let .success(response):
                    promise(.success(response.body))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
        .handleEvents(receiveCancel: {
            requestTask?.cancel()
        })
        .eraseToAnyPublisher()
    }
    #endif

    /**
     Opens a media source.
     - POST /LiveStreams/Open
     - API Key:
       - type: apiKey Authorization 
       - name: CustomAuthentication
     - parameter openToken: (query) The open token. (optional)
     - parameter userId: (query) The user id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter itemId: (query) The item id. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter openLiveStreamRequest: (body) The open live stream dto. (optional)
     - returns: RequestBuilder<LiveStreamResponse> 
     */
    open class func openLiveStreamWithRequestBuilder(openToken: String? = nil, userId: String? = nil, playSessionId: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, itemId: String? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, openLiveStreamRequest: OpenLiveStreamRequest? = nil) -> RequestBuilder<LiveStreamResponse> {
        let localVariablePath = "/LiveStreams/Open"
        let localVariableURLString = JellyfinAPIAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: openLiveStreamRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "openToken": openToken?.encodeToJSON(),
            "userId": userId?.encodeToJSON(),
            "playSessionId": playSessionId?.encodeToJSON(),
            "maxStreamingBitrate": maxStreamingBitrate?.encodeToJSON(),
            "startTimeTicks": startTimeTicks?.encodeToJSON(),
            "audioStreamIndex": audioStreamIndex?.encodeToJSON(),
            "subtitleStreamIndex": subtitleStreamIndex?.encodeToJSON(),
            "maxAudioChannels": maxAudioChannels?.encodeToJSON(),
            "itemId": itemId?.encodeToJSON(),
            "enableDirectPlay": enableDirectPlay?.encodeToJSON(),
            "enableDirectStream": enableDirectStream?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<LiveStreamResponse>.Type = JellyfinAPIAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }
}
