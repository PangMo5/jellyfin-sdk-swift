// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public enum RecommendationType: String, Codable, CaseIterable {
    case similarToRecentlyPlayed = "SimilarToRecentlyPlayed"
    case similarToLikedItem = "SimilarToLikedItem"
    case hasDirectorFromRecentlyPlayed = "HasDirectorFromRecentlyPlayed"
    case hasActorFromRecentlyPlayed = "HasActorFromRecentlyPlayed"
    case hasLikedDirector = "HasLikedDirector"
    case hasLikedActor = "HasLikedActor"
}

public struct GeneralCommand: Codable {
    public var name: GeneralCommandType?
    public var arguments: [String: String]?
    public var controllingUserID: UUID?

    public init(name: GeneralCommandType? = nil, arguments: [String: String]? = nil, controllingUserID: UUID? = nil) {
        self.name = name
        self.arguments = arguments
        self.controllingUserID = controllingUserID
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case arguments = "Arguments"
        case controllingUserID = "ControllingUserId"
    }
}

public struct QuickConnectResult: Codable {
    public var dateAdded: Date?
    public var error: String?
    public var authentication: String?
    public var isAuthenticated: Bool?
    public var secret: String?
    public var code: String?

    public init(dateAdded: Date? = nil, error: String? = nil, authentication: String? = nil, isAuthenticated: Bool? = nil, secret: String? = nil, code: String? = nil) {
        self.dateAdded = dateAdded
        self.error = error
        self.authentication = authentication
        self.isAuthenticated = isAuthenticated
        self.secret = secret
        self.code = code
    }

    private enum CodingKeys: String, CodingKey {
        case dateAdded = "DateAdded"
        case error = "Error"
        case authentication = "Authentication"
        case isAuthenticated = "Authenticated"
        case secret = "Secret"
        case code = "Code"
    }
}

public struct SearchHint: Codable {
    public var indexNumber: Int?
    public var itemID: UUID?
    public var series: String?
    public var productionYear: Int?
    public var type: String?
    public var channelName: String?
    public var matchedTerm: String?
    public var episodeCount: Int?
    public var parentIndexNumber: Int?
    public var thumbImageTag: String?
    public var startDate: Date?
    public var endDate: Date?
    public var name: String?
    public var album: String?
    public var albumArtist: String?
    public var runTimeTicks: Int?
    public var thumbImageItemID: String?
    public var songCount: Int?
    public var status: String?
    public var albumID: UUID?
    public var id: UUID?
    public var primaryImageTag: String?
    public var primaryImageAspectRatio: Double?
    public var channelID: UUID?
    public var isFolder: Bool?
    public var backdropImageItemID: String?
    public var artists: [String]?
    public var mediaType: String?
    public var backdropImageTag: String?

    public init(indexNumber: Int? = nil, itemID: UUID? = nil, series: String? = nil, productionYear: Int? = nil, type: String? = nil, channelName: String? = nil, matchedTerm: String? = nil, episodeCount: Int? = nil, parentIndexNumber: Int? = nil, thumbImageTag: String? = nil, startDate: Date? = nil, endDate: Date? = nil, name: String? = nil, album: String? = nil, albumArtist: String? = nil, runTimeTicks: Int? = nil, thumbImageItemID: String? = nil, songCount: Int? = nil, status: String? = nil, albumID: UUID? = nil, id: UUID? = nil, primaryImageTag: String? = nil, primaryImageAspectRatio: Double? = nil, channelID: UUID? = nil, isFolder: Bool? = nil, backdropImageItemID: String? = nil, artists: [String]? = nil, mediaType: String? = nil, backdropImageTag: String? = nil) {
        self.indexNumber = indexNumber
        self.itemID = itemID
        self.series = series
        self.productionYear = productionYear
        self.type = type
        self.channelName = channelName
        self.matchedTerm = matchedTerm
        self.episodeCount = episodeCount
        self.parentIndexNumber = parentIndexNumber
        self.thumbImageTag = thumbImageTag
        self.startDate = startDate
        self.endDate = endDate
        self.name = name
        self.album = album
        self.albumArtist = albumArtist
        self.runTimeTicks = runTimeTicks
        self.thumbImageItemID = thumbImageItemID
        self.songCount = songCount
        self.status = status
        self.albumID = albumID
        self.id = id
        self.primaryImageTag = primaryImageTag
        self.primaryImageAspectRatio = primaryImageAspectRatio
        self.channelID = channelID
        self.isFolder = isFolder
        self.backdropImageItemID = backdropImageItemID
        self.artists = artists
        self.mediaType = mediaType
        self.backdropImageTag = backdropImageTag
    }

    private enum CodingKeys: String, CodingKey {
        case indexNumber = "IndexNumber"
        case itemID = "ItemId"
        case series = "Series"
        case productionYear = "ProductionYear"
        case type = "Type"
        case channelName = "ChannelName"
        case matchedTerm = "MatchedTerm"
        case episodeCount = "EpisodeCount"
        case parentIndexNumber = "ParentIndexNumber"
        case thumbImageTag = "ThumbImageTag"
        case startDate = "StartDate"
        case endDate = "EndDate"
        case name = "Name"
        case album = "Album"
        case albumArtist = "AlbumArtist"
        case runTimeTicks = "RunTimeTicks"
        case thumbImageItemID = "ThumbImageItemId"
        case songCount = "SongCount"
        case status = "Status"
        case albumID = "AlbumId"
        case id = "Id"
        case primaryImageTag = "PrimaryImageTag"
        case primaryImageAspectRatio = "PrimaryImageAspectRatio"
        case channelID = "ChannelId"
        case isFolder = "IsFolder"
        case backdropImageItemID = "BackdropImageItemId"
        case artists = "Artists"
        case mediaType = "MediaType"
        case backdropImageTag = "BackdropImageTag"
    }
}

public struct ImageInfo: Codable {
    public var imageType: ImageType?
    public var path: String?
    public var imageTag: String?
    public var height: Int?
    public var imageIndex: Int?
    public var blurHash: String?
    public var width: Int?
    public var size: Int?

    public init(imageType: ImageType? = nil, path: String? = nil, imageTag: String? = nil, height: Int? = nil, imageIndex: Int? = nil, blurHash: String? = nil, width: Int? = nil, size: Int? = nil) {
        self.imageType = imageType
        self.path = path
        self.imageTag = imageTag
        self.height = height
        self.imageIndex = imageIndex
        self.blurHash = blurHash
        self.width = width
        self.size = size
    }

    private enum CodingKeys: String, CodingKey {
        case imageType = "ImageType"
        case path = "Path"
        case imageTag = "ImageTag"
        case height = "Height"
        case imageIndex = "ImageIndex"
        case blurHash = "BlurHash"
        case width = "Width"
        case size = "Size"
    }
}

public enum TaskCompletionStatus: String, Codable, CaseIterable {
    case completed = "Completed"
    case failed = "Failed"
    case cancelled = "Cancelled"
    case aborted = "Aborted"
}

public struct ForgotPasswordResult: Codable {
    public var pinFile: String?
    public var action: ForgotPasswordAction?
    public var pinExpirationDate: Date?

    public init(pinFile: String? = nil, action: ForgotPasswordAction? = nil, pinExpirationDate: Date? = nil) {
        self.pinFile = pinFile
        self.action = action
        self.pinExpirationDate = pinExpirationDate
    }

    private enum CodingKeys: String, CodingKey {
        case pinFile = "PinFile"
        case action = "Action"
        case pinExpirationDate = "PinExpirationDate"
    }
}

public struct SendCommand: Codable {
    public var positionTicks: Int?
    public var playlistItemID: UUID?
    public var groupID: UUID?
    public var when: Date?
    public var command: SendCommandType?
    public var emittedAt: Date?

    public init(positionTicks: Int? = nil, playlistItemID: UUID? = nil, groupID: UUID? = nil, when: Date? = nil, command: SendCommandType? = nil, emittedAt: Date? = nil) {
        self.positionTicks = positionTicks
        self.playlistItemID = playlistItemID
        self.groupID = groupID
        self.when = when
        self.command = command
        self.emittedAt = emittedAt
    }

    private enum CodingKeys: String, CodingKey {
        case positionTicks = "PositionTicks"
        case playlistItemID = "PlaylistItemId"
        case groupID = "GroupId"
        case when = "When"
        case command = "Command"
        case emittedAt = "EmittedAt"
    }
}

public struct TimerInfoDto: Codable {
    public var channelName: String?
    public var serviceName: String?
    public var prePaddingSeconds: Int?
    public var serverID: String?
    public var endDate: Date?
    public var priority: Int?
    public var isPostPaddingRequired: Bool?
    public var parentBackdropItemID: String?
    public var channelID: UUID?
    public var externalID: String?
    public var name: String?
    public var isPrePaddingRequired: Bool?
    public var externalSeriesTimerID: String?
    public var seriesTimerID: String?
    public var programInfo: BaseItemDto?
    public var parentBackdropImageTags: [String]?
    public var startDate: Date?
    public var postPaddingSeconds: Int?
    public var runTimeTicks: Int?
    public var overview: String?
    public var externalProgramID: String?
    public var type: String?
    public var channelPrimaryImageTag: String?
    public var programID: String?
    public var id: String?
    public var externalChannelID: String?
    public var keepUntil: KeepUntil?
    public var status: RecordingStatus?

    public init(channelName: String? = nil, serviceName: String? = nil, prePaddingSeconds: Int? = nil, serverID: String? = nil, endDate: Date? = nil, priority: Int? = nil, isPostPaddingRequired: Bool? = nil, parentBackdropItemID: String? = nil, channelID: UUID? = nil, externalID: String? = nil, name: String? = nil, isPrePaddingRequired: Bool? = nil, externalSeriesTimerID: String? = nil, seriesTimerID: String? = nil, programInfo: BaseItemDto? = nil, parentBackdropImageTags: [String]? = nil, startDate: Date? = nil, postPaddingSeconds: Int? = nil, runTimeTicks: Int? = nil, overview: String? = nil, externalProgramID: String? = nil, type: String? = nil, channelPrimaryImageTag: String? = nil, programID: String? = nil, id: String? = nil, externalChannelID: String? = nil, keepUntil: KeepUntil? = nil, status: RecordingStatus? = nil) {
        self.channelName = channelName
        self.serviceName = serviceName
        self.prePaddingSeconds = prePaddingSeconds
        self.serverID = serverID
        self.endDate = endDate
        self.priority = priority
        self.isPostPaddingRequired = isPostPaddingRequired
        self.parentBackdropItemID = parentBackdropItemID
        self.channelID = channelID
        self.externalID = externalID
        self.name = name
        self.isPrePaddingRequired = isPrePaddingRequired
        self.externalSeriesTimerID = externalSeriesTimerID
        self.seriesTimerID = seriesTimerID
        self.programInfo = programInfo
        self.parentBackdropImageTags = parentBackdropImageTags
        self.startDate = startDate
        self.postPaddingSeconds = postPaddingSeconds
        self.runTimeTicks = runTimeTicks
        self.overview = overview
        self.externalProgramID = externalProgramID
        self.type = type
        self.channelPrimaryImageTag = channelPrimaryImageTag
        self.programID = programID
        self.id = id
        self.externalChannelID = externalChannelID
        self.keepUntil = keepUntil
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case channelName = "ChannelName"
        case serviceName = "ServiceName"
        case prePaddingSeconds = "PrePaddingSeconds"
        case serverID = "ServerId"
        case endDate = "EndDate"
        case priority = "Priority"
        case isPostPaddingRequired = "IsPostPaddingRequired"
        case parentBackdropItemID = "ParentBackdropItemId"
        case channelID = "ChannelId"
        case externalID = "ExternalId"
        case name = "Name"
        case isPrePaddingRequired = "IsPrePaddingRequired"
        case externalSeriesTimerID = "ExternalSeriesTimerId"
        case seriesTimerID = "SeriesTimerId"
        case programInfo = "ProgramInfo"
        case parentBackdropImageTags = "ParentBackdropImageTags"
        case startDate = "StartDate"
        case postPaddingSeconds = "PostPaddingSeconds"
        case runTimeTicks = "RunTimeTicks"
        case overview = "Overview"
        case externalProgramID = "ExternalProgramId"
        case type = "Type"
        case channelPrimaryImageTag = "ChannelPrimaryImageTag"
        case programID = "ProgramId"
        case id = "Id"
        case externalChannelID = "ExternalChannelId"
        case keepUntil = "KeepUntil"
        case status = "Status"
    }
}

public enum ForgotPasswordAction: String, Codable, CaseIterable {
    case contactAdmin = "ContactAdmin"
    case pinCode = "PinCode"
    case inNetworkRequired = "InNetworkRequired"
}

public struct SeriesTimerInfoDtoQueryResult: Codable {
    public var items: [SeriesTimerInfoDto]?
    public var startIndex: Int?
    public var totalRecordCount: Int?

    public init(items: [SeriesTimerInfoDto]? = nil, startIndex: Int? = nil, totalRecordCount: Int? = nil) {
        self.items = items
        self.startIndex = startIndex
        self.totalRecordCount = totalRecordCount
    }

    private enum CodingKeys: String, CodingKey {
        case items = "Items"
        case startIndex = "StartIndex"
        case totalRecordCount = "TotalRecordCount"
    }
}

public struct ServerConfiguration: Codable {
    public var uDPSendDelay: Int?
    public var preferredMetadataLanguage: String?
    public var uninstalledPlugins: [String]?
    public var metadataNetworkPath: String?
    public var pathSubstitutions: [PathSubstitution]?
    public var enableDashboardResponseCaching: Bool?
    public var enableExternalContentInSuggestions: Bool?
    public var sortRemoveCharacters: [String]?
    public var uDPPortRange: String?
    public var serverName: String?
    public var sortReplaceCharacters: [String]?
    public var httpsPortNumber: Int?
    public var enableRemoteAccess: Bool?
    public var isUPnPCreateHTTPPortMap: Bool?
    public var enableNormalizedItemByNameIDs: Bool?
    public var imageSavingConvention: ImageSavingConvention?
    public var enableIPV6: Bool?
    public var enableCaseSensitiveItemIDs: Bool?
    public var isRemoveOldPlugins: Bool?
    public var contentTypes: [NameValuePair]?
    public var enableMetrics: Bool?
    public var isSaveMetadataHidden: Bool?
    public var minResumeDurationSeconds: Int?
    public var enableSlowResponseWarning: Bool?
    public var hDHomerunPortRange: String?
    public var activityLogRetentionDays: Int?
    public var isPortAuthorized: Bool?
    public var uDPSendCount: Int?
    public var maxAudiobookResume: Int?
    public var publishedServerUriBySubnet: [String]?
    public var libraryMetadataRefreshConcurrency: Int?
    public var libraryScanFanoutConcurrency: Int?
    public var certificatePath: String?
    public var publicPort: Int?
    public var uICulture: String?
    public var maxResumePct: Int?
    public var minAudiobookResume: Int?
    public var httpserverPortNumber: Int?
    public var enableHTTPS: Bool?
    public var libraryMonitorDelay: Int?
    public var remoteClientBitrateLimit: Int?
    public var isSkipDeserializationForBasicTypes: Bool?
    public var minResumePct: Int?
    public var metadataPath: String?
    public var isIgnoreVirtualInterfaces: Bool?
    public var localNetworkAddresses: [String]?
    public var previousVersion: Version?
    public var isDisplaySpecialsWithinSeasons: Bool?
    public var pluginRepositories: [RepositoryInfo]?
    public var sortRemoveWords: [String]?
    public var localNetworkSubnets: [String]?
    public var requireHTTPS: Bool?
    public var enableSSDPTracing: Bool?
    public var isTrustAllIP6Interfaces: Bool?
    public var enableFolderView: Bool?
    public var enableUPnP: Bool?
    public var remoteIPFilter: [String]?
    public var isAutoDiscoveryTracing: Bool?
    public var sSDPTracingFilter: String?
    public var slowResponseThresholdMs: Int?
    public var enableGroupingIntoCollections: Bool?
    public var knownProxies: [String]?
    public var metadataCountryCode: String?
    public var isRemoteIPFilterBlacklist: Bool?
    public var publicHTTPSPort: Int?
    public var enableIPV4: Bool?
    public var codecsUsed: [String]?
    public var logFileRetentionDays: Int?
    public var enableMultiSocketBinding: Bool?
    public var isQuickConnectAvailable: Bool?
    public var isDisableLiveTvChannelUserDataName: Bool?
    public var imageExtractionTimeoutMs: Int?
    public var enableNewOmdbSupport: Bool?
    public var gatewayMonitorPeriod: Int?
    public var virtualInterfaceNames: String?
    public var isAutoDiscovery: Bool?
    public var cachePath: String?
    public var previousVersionStr: String?
    public var metadataOptions: [MetadataOptions]?
    public var baseURL: String?
    public var corsHosts: [String]?
    public var certificatePassword: String?
    public var isStartupWizardCompleted: Bool?

    public init(uDPSendDelay: Int? = nil, preferredMetadataLanguage: String? = nil, uninstalledPlugins: [String]? = nil, metadataNetworkPath: String? = nil, pathSubstitutions: [PathSubstitution]? = nil, enableDashboardResponseCaching: Bool? = nil, enableExternalContentInSuggestions: Bool? = nil, sortRemoveCharacters: [String]? = nil, uDPPortRange: String? = nil, serverName: String? = nil, sortReplaceCharacters: [String]? = nil, httpsPortNumber: Int? = nil, enableRemoteAccess: Bool? = nil, isUPnPCreateHTTPPortMap: Bool? = nil, enableNormalizedItemByNameIDs: Bool? = nil, imageSavingConvention: ImageSavingConvention? = nil, enableIPV6: Bool? = nil, enableCaseSensitiveItemIDs: Bool? = nil, isRemoveOldPlugins: Bool? = nil, contentTypes: [NameValuePair]? = nil, enableMetrics: Bool? = nil, isSaveMetadataHidden: Bool? = nil, minResumeDurationSeconds: Int? = nil, enableSlowResponseWarning: Bool? = nil, hDHomerunPortRange: String? = nil, activityLogRetentionDays: Int? = nil, isPortAuthorized: Bool? = nil, uDPSendCount: Int? = nil, maxAudiobookResume: Int? = nil, publishedServerUriBySubnet: [String]? = nil, libraryMetadataRefreshConcurrency: Int? = nil, libraryScanFanoutConcurrency: Int? = nil, certificatePath: String? = nil, publicPort: Int? = nil, uICulture: String? = nil, maxResumePct: Int? = nil, minAudiobookResume: Int? = nil, httpserverPortNumber: Int? = nil, enableHTTPS: Bool? = nil, libraryMonitorDelay: Int? = nil, remoteClientBitrateLimit: Int? = nil, isSkipDeserializationForBasicTypes: Bool? = nil, minResumePct: Int? = nil, metadataPath: String? = nil, isIgnoreVirtualInterfaces: Bool? = nil, localNetworkAddresses: [String]? = nil, previousVersion: Version? = nil, isDisplaySpecialsWithinSeasons: Bool? = nil, pluginRepositories: [RepositoryInfo]? = nil, sortRemoveWords: [String]? = nil, localNetworkSubnets: [String]? = nil, requireHTTPS: Bool? = nil, enableSSDPTracing: Bool? = nil, isTrustAllIP6Interfaces: Bool? = nil, enableFolderView: Bool? = nil, enableUPnP: Bool? = nil, remoteIPFilter: [String]? = nil, isAutoDiscoveryTracing: Bool? = nil, sSDPTracingFilter: String? = nil, slowResponseThresholdMs: Int? = nil, enableGroupingIntoCollections: Bool? = nil, knownProxies: [String]? = nil, metadataCountryCode: String? = nil, isRemoteIPFilterBlacklist: Bool? = nil, publicHTTPSPort: Int? = nil, enableIPV4: Bool? = nil, codecsUsed: [String]? = nil, logFileRetentionDays: Int? = nil, enableMultiSocketBinding: Bool? = nil, isQuickConnectAvailable: Bool? = nil, isDisableLiveTvChannelUserDataName: Bool? = nil, imageExtractionTimeoutMs: Int? = nil, enableNewOmdbSupport: Bool? = nil, gatewayMonitorPeriod: Int? = nil, virtualInterfaceNames: String? = nil, isAutoDiscovery: Bool? = nil, cachePath: String? = nil, previousVersionStr: String? = nil, metadataOptions: [MetadataOptions]? = nil, baseURL: String? = nil, corsHosts: [String]? = nil, certificatePassword: String? = nil, isStartupWizardCompleted: Bool? = nil) {
        self.uDPSendDelay = uDPSendDelay
        self.preferredMetadataLanguage = preferredMetadataLanguage
        self.uninstalledPlugins = uninstalledPlugins
        self.metadataNetworkPath = metadataNetworkPath
        self.pathSubstitutions = pathSubstitutions
        self.enableDashboardResponseCaching = enableDashboardResponseCaching
        self.enableExternalContentInSuggestions = enableExternalContentInSuggestions
        self.sortRemoveCharacters = sortRemoveCharacters
        self.uDPPortRange = uDPPortRange
        self.serverName = serverName
        self.sortReplaceCharacters = sortReplaceCharacters
        self.httpsPortNumber = httpsPortNumber
        self.enableRemoteAccess = enableRemoteAccess
        self.isUPnPCreateHTTPPortMap = isUPnPCreateHTTPPortMap
        self.enableNormalizedItemByNameIDs = enableNormalizedItemByNameIDs
        self.imageSavingConvention = imageSavingConvention
        self.enableIPV6 = enableIPV6
        self.enableCaseSensitiveItemIDs = enableCaseSensitiveItemIDs
        self.isRemoveOldPlugins = isRemoveOldPlugins
        self.contentTypes = contentTypes
        self.enableMetrics = enableMetrics
        self.isSaveMetadataHidden = isSaveMetadataHidden
        self.minResumeDurationSeconds = minResumeDurationSeconds
        self.enableSlowResponseWarning = enableSlowResponseWarning
        self.hDHomerunPortRange = hDHomerunPortRange
        self.activityLogRetentionDays = activityLogRetentionDays
        self.isPortAuthorized = isPortAuthorized
        self.uDPSendCount = uDPSendCount
        self.maxAudiobookResume = maxAudiobookResume
        self.publishedServerUriBySubnet = publishedServerUriBySubnet
        self.libraryMetadataRefreshConcurrency = libraryMetadataRefreshConcurrency
        self.libraryScanFanoutConcurrency = libraryScanFanoutConcurrency
        self.certificatePath = certificatePath
        self.publicPort = publicPort
        self.uICulture = uICulture
        self.maxResumePct = maxResumePct
        self.minAudiobookResume = minAudiobookResume
        self.httpserverPortNumber = httpserverPortNumber
        self.enableHTTPS = enableHTTPS
        self.libraryMonitorDelay = libraryMonitorDelay
        self.remoteClientBitrateLimit = remoteClientBitrateLimit
        self.isSkipDeserializationForBasicTypes = isSkipDeserializationForBasicTypes
        self.minResumePct = minResumePct
        self.metadataPath = metadataPath
        self.isIgnoreVirtualInterfaces = isIgnoreVirtualInterfaces
        self.localNetworkAddresses = localNetworkAddresses
        self.previousVersion = previousVersion
        self.isDisplaySpecialsWithinSeasons = isDisplaySpecialsWithinSeasons
        self.pluginRepositories = pluginRepositories
        self.sortRemoveWords = sortRemoveWords
        self.localNetworkSubnets = localNetworkSubnets
        self.requireHTTPS = requireHTTPS
        self.enableSSDPTracing = enableSSDPTracing
        self.isTrustAllIP6Interfaces = isTrustAllIP6Interfaces
        self.enableFolderView = enableFolderView
        self.enableUPnP = enableUPnP
        self.remoteIPFilter = remoteIPFilter
        self.isAutoDiscoveryTracing = isAutoDiscoveryTracing
        self.sSDPTracingFilter = sSDPTracingFilter
        self.slowResponseThresholdMs = slowResponseThresholdMs
        self.enableGroupingIntoCollections = enableGroupingIntoCollections
        self.knownProxies = knownProxies
        self.metadataCountryCode = metadataCountryCode
        self.isRemoteIPFilterBlacklist = isRemoteIPFilterBlacklist
        self.publicHTTPSPort = publicHTTPSPort
        self.enableIPV4 = enableIPV4
        self.codecsUsed = codecsUsed
        self.logFileRetentionDays = logFileRetentionDays
        self.enableMultiSocketBinding = enableMultiSocketBinding
        self.isQuickConnectAvailable = isQuickConnectAvailable
        self.isDisableLiveTvChannelUserDataName = isDisableLiveTvChannelUserDataName
        self.imageExtractionTimeoutMs = imageExtractionTimeoutMs
        self.enableNewOmdbSupport = enableNewOmdbSupport
        self.gatewayMonitorPeriod = gatewayMonitorPeriod
        self.virtualInterfaceNames = virtualInterfaceNames
        self.isAutoDiscovery = isAutoDiscovery
        self.cachePath = cachePath
        self.previousVersionStr = previousVersionStr
        self.metadataOptions = metadataOptions
        self.baseURL = baseURL
        self.corsHosts = corsHosts
        self.certificatePassword = certificatePassword
        self.isStartupWizardCompleted = isStartupWizardCompleted
    }

    private enum CodingKeys: String, CodingKey {
        case uDPSendDelay = "UDPSendDelay"
        case preferredMetadataLanguage = "PreferredMetadataLanguage"
        case uninstalledPlugins = "UninstalledPlugins"
        case metadataNetworkPath = "MetadataNetworkPath"
        case pathSubstitutions = "PathSubstitutions"
        case enableDashboardResponseCaching = "EnableDashboardResponseCaching"
        case enableExternalContentInSuggestions = "EnableExternalContentInSuggestions"
        case sortRemoveCharacters = "SortRemoveCharacters"
        case uDPPortRange = "UDPPortRange"
        case serverName = "ServerName"
        case sortReplaceCharacters = "SortReplaceCharacters"
        case httpsPortNumber = "HttpsPortNumber"
        case enableRemoteAccess = "EnableRemoteAccess"
        case isUPnPCreateHTTPPortMap = "UPnPCreateHttpPortMap"
        case enableNormalizedItemByNameIDs = "EnableNormalizedItemByNameIds"
        case imageSavingConvention = "ImageSavingConvention"
        case enableIPV6 = "EnableIPV6"
        case enableCaseSensitiveItemIDs = "EnableCaseSensitiveItemIds"
        case isRemoveOldPlugins = "RemoveOldPlugins"
        case contentTypes = "ContentTypes"
        case enableMetrics = "EnableMetrics"
        case isSaveMetadataHidden = "SaveMetadataHidden"
        case minResumeDurationSeconds = "MinResumeDurationSeconds"
        case enableSlowResponseWarning = "EnableSlowResponseWarning"
        case hDHomerunPortRange = "HDHomerunPortRange"
        case activityLogRetentionDays = "ActivityLogRetentionDays"
        case isPortAuthorized = "IsPortAuthorized"
        case uDPSendCount = "UDPSendCount"
        case maxAudiobookResume = "MaxAudiobookResume"
        case publishedServerUriBySubnet = "PublishedServerUriBySubnet"
        case libraryMetadataRefreshConcurrency = "LibraryMetadataRefreshConcurrency"
        case libraryScanFanoutConcurrency = "LibraryScanFanoutConcurrency"
        case certificatePath = "CertificatePath"
        case publicPort = "PublicPort"
        case uICulture = "UICulture"
        case maxResumePct = "MaxResumePct"
        case minAudiobookResume = "MinAudiobookResume"
        case httpserverPortNumber = "HttpServerPortNumber"
        case enableHTTPS = "EnableHttps"
        case libraryMonitorDelay = "LibraryMonitorDelay"
        case remoteClientBitrateLimit = "RemoteClientBitrateLimit"
        case isSkipDeserializationForBasicTypes = "SkipDeserializationForBasicTypes"
        case minResumePct = "MinResumePct"
        case metadataPath = "MetadataPath"
        case isIgnoreVirtualInterfaces = "IgnoreVirtualInterfaces"
        case localNetworkAddresses = "LocalNetworkAddresses"
        case previousVersion = "PreviousVersion"
        case isDisplaySpecialsWithinSeasons = "DisplaySpecialsWithinSeasons"
        case pluginRepositories = "PluginRepositories"
        case sortRemoveWords = "SortRemoveWords"
        case localNetworkSubnets = "LocalNetworkSubnets"
        case requireHTTPS = "RequireHttps"
        case enableSSDPTracing = "EnableSSDPTracing"
        case isTrustAllIP6Interfaces = "TrustAllIP6Interfaces"
        case enableFolderView = "EnableFolderView"
        case enableUPnP = "EnableUPnP"
        case remoteIPFilter = "RemoteIPFilter"
        case isAutoDiscoveryTracing = "AutoDiscoveryTracing"
        case sSDPTracingFilter = "SSDPTracingFilter"
        case slowResponseThresholdMs = "SlowResponseThresholdMs"
        case enableGroupingIntoCollections = "EnableGroupingIntoCollections"
        case knownProxies = "KnownProxies"
        case metadataCountryCode = "MetadataCountryCode"
        case isRemoteIPFilterBlacklist = "IsRemoteIPFilterBlacklist"
        case publicHTTPSPort = "PublicHttpsPort"
        case enableIPV4 = "EnableIPV4"
        case codecsUsed = "CodecsUsed"
        case logFileRetentionDays = "LogFileRetentionDays"
        case enableMultiSocketBinding = "EnableMultiSocketBinding"
        case isQuickConnectAvailable = "QuickConnectAvailable"
        case isDisableLiveTvChannelUserDataName = "DisableLiveTvChannelUserDataName"
        case imageExtractionTimeoutMs = "ImageExtractionTimeoutMs"
        case enableNewOmdbSupport = "EnableNewOmdbSupport"
        case gatewayMonitorPeriod = "GatewayMonitorPeriod"
        case virtualInterfaceNames = "VirtualInterfaceNames"
        case isAutoDiscovery = "AutoDiscovery"
        case cachePath = "CachePath"
        case previousVersionStr = "PreviousVersionStr"
        case metadataOptions = "MetadataOptions"
        case baseURL = "BaseUrl"
        case corsHosts = "CorsHosts"
        case certificatePassword = "CertificatePassword"
        case isStartupWizardCompleted = "IsStartupWizardCompleted"
    }
}

public struct LogFile: Codable {
    public var size: Int?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var name: String?

    public init(size: Int? = nil, dateCreated: Date? = nil, dateModified: Date? = nil, name: String? = nil) {
        self.size = size
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case size = "Size"
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case name = "Name"
    }
}

public struct PackageInfo: Codable {
    public var overview: String?
    public var category: String?
    public var imageURL: String?
    public var versions: [VersionInfo]?
    public var owner: String?
    public var name: String?
    public var guid: String?
    public var description: String?

    public init(overview: String? = nil, category: String? = nil, imageURL: String? = nil, versions: [VersionInfo]? = nil, owner: String? = nil, name: String? = nil, guid: String? = nil, description: String? = nil) {
        self.overview = overview
        self.category = category
        self.imageURL = imageURL
        self.versions = versions
        self.owner = owner
        self.name = name
        self.guid = guid
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case overview
        case category
        case imageURL = "imageUrl"
        case versions
        case owner
        case name
        case guid
        case description
    }
}

public struct ChapterInfo: Codable {
    public var imagePath: String?
    public var imageTag: String?
    public var imageDateModified: Date?
    public var name: String?
    public var startPositionTicks: Int?

    public init(imagePath: String? = nil, imageTag: String? = nil, imageDateModified: Date? = nil, name: String? = nil, startPositionTicks: Int? = nil) {
        self.imagePath = imagePath
        self.imageTag = imageTag
        self.imageDateModified = imageDateModified
        self.name = name
        self.startPositionTicks = startPositionTicks
    }

    private enum CodingKeys: String, CodingKey {
        case imagePath = "ImagePath"
        case imageTag = "ImageTag"
        case imageDateModified = "ImageDateModified"
        case name = "Name"
        case startPositionTicks = "StartPositionTicks"
    }
}

public struct MediaAttachment: Codable {
    public var comment: String?
    public var codecTag: String?
    public var deliveryURL: String?
    public var fileName: String?
    public var index: Int?
    public var codec: String?
    public var mimeType: String?

    public init(comment: String? = nil, codecTag: String? = nil, deliveryURL: String? = nil, fileName: String? = nil, index: Int? = nil, codec: String? = nil, mimeType: String? = nil) {
        self.comment = comment
        self.codecTag = codecTag
        self.deliveryURL = deliveryURL
        self.fileName = fileName
        self.index = index
        self.codec = codec
        self.mimeType = mimeType
    }

    private enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case codecTag = "CodecTag"
        case deliveryURL = "DeliveryUrl"
        case fileName = "FileName"
        case index = "Index"
        case codec = "Codec"
        case mimeType = "MimeType"
    }
}

public struct CollectionCreationResult: Codable {
    public var id: UUID?

    public init(id: UUID? = nil) {
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
    }
}

public enum GroupUpdateType: String, Codable, CaseIterable {
    case userJoined = "UserJoined"
    case userLeft = "UserLeft"
    case groupJoined = "GroupJoined"
    case groupLeft = "GroupLeft"
    case stateUpdate = "StateUpdate"
    case playQueue = "PlayQueue"
    case notInGroup = "NotInGroup"
    case groupDoesNotExist = "GroupDoesNotExist"
    case createGroupDenied = "CreateGroupDenied"
    case joinGroupDenied = "JoinGroupDenied"
    case libraryAccessDenied = "LibraryAccessDenied"
}

public struct DeviceInfoQueryResult: Codable {
    public var items: [DeviceInfo]?
    public var startIndex: Int?
    public var totalRecordCount: Int?

    public init(items: [DeviceInfo]? = nil, startIndex: Int? = nil, totalRecordCount: Int? = nil) {
        self.items = items
        self.startIndex = startIndex
        self.totalRecordCount = totalRecordCount
    }

    private enum CodingKeys: String, CodingKey {
        case items = "Items"
        case startIndex = "StartIndex"
        case totalRecordCount = "TotalRecordCount"
    }
}

public struct MediaSourceInfo: Codable {
    public var formats: [String]?
    public var video3DFormat: Video3DFormat?
    public var bufferMs: Int?
    public var requiresClosing: Bool?
    public var mediaAttachments: [MediaAttachment]?
    public var liveStreamID: String?
    public var requiredHTTPHeaders: [String: String]?
    public var transcodingContainer: String?
    public var openToken: String?
    public var videoType: VideoType?
    public var isGenPtsInput: Bool?
    public var defaultAudioStreamIndex: Int?
    public var `protocol`: MediaProtocol?
    public var type: MediaSourceType?
    public var bitrate: Int?
    public var encoderProtocol: MediaProtocol?
    public var isSupportsProbing: Bool?
    public var isoType: IsoType?
    public var name: String?
    public var defaultSubtitleStreamIndex: Int?
    public var container: String?
    public var mediaStreams: [MediaStream]?
    public var transcodingURL: String?
    public var isSupportsTranscoding: Bool?
    public var isReadAtNativeFramerate: Bool?
    public var id: String?
    public var eTag: String?
    public var transcodingSubProtocol: String?
    public var size: Int?
    public var isSupportsDirectPlay: Bool?
    public var analyzeDurationMs: Int?
    public var isIgnoreDts: Bool?
    public var isRemote: Bool?
    public var requiresLooping: Bool?
    public var runTimeTicks: Int?
    public var encoderPath: String?
    public var isInfiniteStream: Bool?
    public var isIgnoreIndex: Bool?
    public var timestamp: TransportStreamTimestamp?
    public var requiresOpening: Bool?
    public var path: String?
    public var isSupportsDirectStream: Bool?

    public init(formats: [String]? = nil, video3DFormat: Video3DFormat? = nil, bufferMs: Int? = nil, requiresClosing: Bool? = nil, mediaAttachments: [MediaAttachment]? = nil, liveStreamID: String? = nil, requiredHTTPHeaders: [String: String]? = nil, transcodingContainer: String? = nil, openToken: String? = nil, videoType: VideoType? = nil, isGenPtsInput: Bool? = nil, defaultAudioStreamIndex: Int? = nil, `protocol`: MediaProtocol? = nil, type: MediaSourceType? = nil, bitrate: Int? = nil, encoderProtocol: MediaProtocol? = nil, isSupportsProbing: Bool? = nil, isoType: IsoType? = nil, name: String? = nil, defaultSubtitleStreamIndex: Int? = nil, container: String? = nil, mediaStreams: [MediaStream]? = nil, transcodingURL: String? = nil, isSupportsTranscoding: Bool? = nil, isReadAtNativeFramerate: Bool? = nil, id: String? = nil, eTag: String? = nil, transcodingSubProtocol: String? = nil, size: Int? = nil, isSupportsDirectPlay: Bool? = nil, analyzeDurationMs: Int? = nil, isIgnoreDts: Bool? = nil, isRemote: Bool? = nil, requiresLooping: Bool? = nil, runTimeTicks: Int? = nil, encoderPath: String? = nil, isInfiniteStream: Bool? = nil, isIgnoreIndex: Bool? = nil, timestamp: TransportStreamTimestamp? = nil, requiresOpening: Bool? = nil, path: String? = nil, isSupportsDirectStream: Bool? = nil) {
        self.formats = formats
        self.video3DFormat = video3DFormat
        self.bufferMs = bufferMs
        self.requiresClosing = requiresClosing
        self.mediaAttachments = mediaAttachments
        self.liveStreamID = liveStreamID
        self.requiredHTTPHeaders = requiredHTTPHeaders
        self.transcodingContainer = transcodingContainer
        self.openToken = openToken
        self.videoType = videoType
        self.isGenPtsInput = isGenPtsInput
        self.defaultAudioStreamIndex = defaultAudioStreamIndex
        self.protocol = `protocol`
        self.type = type
        self.bitrate = bitrate
        self.encoderProtocol = encoderProtocol
        self.isSupportsProbing = isSupportsProbing
        self.isoType = isoType
        self.name = name
        self.defaultSubtitleStreamIndex = defaultSubtitleStreamIndex
        self.container = container
        self.mediaStreams = mediaStreams
        self.transcodingURL = transcodingURL
        self.isSupportsTranscoding = isSupportsTranscoding
        self.isReadAtNativeFramerate = isReadAtNativeFramerate
        self.id = id
        self.eTag = eTag
        self.transcodingSubProtocol = transcodingSubProtocol
        self.size = size
        self.isSupportsDirectPlay = isSupportsDirectPlay
        self.analyzeDurationMs = analyzeDurationMs
        self.isIgnoreDts = isIgnoreDts
        self.isRemote = isRemote
        self.requiresLooping = requiresLooping
        self.runTimeTicks = runTimeTicks
        self.encoderPath = encoderPath
        self.isInfiniteStream = isInfiniteStream
        self.isIgnoreIndex = isIgnoreIndex
        self.timestamp = timestamp
        self.requiresOpening = requiresOpening
        self.path = path
        self.isSupportsDirectStream = isSupportsDirectStream
    }

    private enum CodingKeys: String, CodingKey {
        case formats = "Formats"
        case video3DFormat = "Video3DFormat"
        case bufferMs = "BufferMs"
        case requiresClosing = "RequiresClosing"
        case mediaAttachments = "MediaAttachments"
        case liveStreamID = "LiveStreamId"
        case requiredHTTPHeaders = "RequiredHttpHeaders"
        case transcodingContainer = "TranscodingContainer"
        case openToken = "OpenToken"
        case videoType = "VideoType"
        case isGenPtsInput = "GenPtsInput"
        case defaultAudioStreamIndex = "DefaultAudioStreamIndex"
        case `protocol` = "Protocol"
        case type = "Type"
        case bitrate = "Bitrate"
        case encoderProtocol = "EncoderProtocol"
        case isSupportsProbing = "SupportsProbing"
        case isoType = "IsoType"
        case name = "Name"
        case defaultSubtitleStreamIndex = "DefaultSubtitleStreamIndex"
        case container = "Container"
        case mediaStreams = "MediaStreams"
        case transcodingURL = "TranscodingUrl"
        case isSupportsTranscoding = "SupportsTranscoding"
        case isReadAtNativeFramerate = "ReadAtNativeFramerate"
        case id = "Id"
        case eTag = "ETag"
        case transcodingSubProtocol = "TranscodingSubProtocol"
        case size = "Size"
        case isSupportsDirectPlay = "SupportsDirectPlay"
        case analyzeDurationMs = "AnalyzeDurationMs"
        case isIgnoreDts = "IgnoreDts"
        case isRemote = "IsRemote"
        case requiresLooping = "RequiresLooping"
        case runTimeTicks = "RunTimeTicks"
        case encoderPath = "EncoderPath"
        case isInfiniteStream = "IsInfiniteStream"
        case isIgnoreIndex = "IgnoreIndex"
        case timestamp = "Timestamp"
        case requiresOpening = "RequiresOpening"
        case path = "Path"
        case isSupportsDirectStream = "SupportsDirectStream"
    }
}

public enum ItemFilter: String, Codable, CaseIterable {
    case isFolder = "IsFolder"
    case isNotFolder = "IsNotFolder"
    case isUnplayed = "IsUnplayed"
    case isPlayed = "IsPlayed"
    case isFavorite = "IsFavorite"
    case isResumable = "IsResumable"
    case likes = "Likes"
    case dislikes = "Dislikes"
    case isFavoriteOrLikes = "IsFavoriteOrLikes"
}

public struct DeviceProfileInfo: Codable {
    public var name: String?
    public var type: DeviceProfileType?
    public var id: String?

    public init(name: String? = nil, type: DeviceProfileType? = nil, id: String? = nil) {
        self.name = name
        self.type = type
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case type = "Type"
        case id = "Id"
    }
}

public struct DisplayPreferencesDto: Codable {
    public var client: String?
    public var primaryImageHeight: Int?
    public var sortOrder: SortOrder?
    public var viewType: String?
    public var primaryImageWidth: Int?
    public var indexBy: String?
    public var isRememberSorting: Bool?
    public var scrollDirection: ScrollDirection?
    public var isShowBackdrop: Bool?
    public var sortBy: String?
    public var customPrefs: [String: String]?
    public var id: String?
    public var isShowSidebar: Bool?
    public var isRememberIndexing: Bool?

    public init(client: String? = nil, primaryImageHeight: Int? = nil, sortOrder: SortOrder? = nil, viewType: String? = nil, primaryImageWidth: Int? = nil, indexBy: String? = nil, isRememberSorting: Bool? = nil, scrollDirection: ScrollDirection? = nil, isShowBackdrop: Bool? = nil, sortBy: String? = nil, customPrefs: [String: String]? = nil, id: String? = nil, isShowSidebar: Bool? = nil, isRememberIndexing: Bool? = nil) {
        self.client = client
        self.primaryImageHeight = primaryImageHeight
        self.sortOrder = sortOrder
        self.viewType = viewType
        self.primaryImageWidth = primaryImageWidth
        self.indexBy = indexBy
        self.isRememberSorting = isRememberSorting
        self.scrollDirection = scrollDirection
        self.isShowBackdrop = isShowBackdrop
        self.sortBy = sortBy
        self.customPrefs = customPrefs
        self.id = id
        self.isShowSidebar = isShowSidebar
        self.isRememberIndexing = isRememberIndexing
    }

    private enum CodingKeys: String, CodingKey {
        case client = "Client"
        case primaryImageHeight = "PrimaryImageHeight"
        case sortOrder = "SortOrder"
        case viewType = "ViewType"
        case primaryImageWidth = "PrimaryImageWidth"
        case indexBy = "IndexBy"
        case isRememberSorting = "RememberSorting"
        case scrollDirection = "ScrollDirection"
        case isShowBackdrop = "ShowBackdrop"
        case sortBy = "SortBy"
        case customPrefs = "CustomPrefs"
        case id = "Id"
        case isShowSidebar = "ShowSidebar"
        case isRememberIndexing = "RememberIndexing"
    }
}

public struct UploadSubtitleDto: Codable {
    public var isForced: Bool
    public var language: String
    public var format: String
    public var data: String

    public init(isForced: Bool, language: String, format: String, data: String) {
        self.isForced = isForced
        self.language = language
        self.format = format
        self.data = data
    }

    private enum CodingKeys: String, CodingKey {
        case isForced = "IsForced"
        case language = "Language"
        case format = "Format"
        case data = "Data"
    }
}

public struct PlaybackStopInfo: Codable {
    public var itemID: UUID?
    public var mediaSourceID: String?
    public var nowPlayingQueue: [QueueItem]?
    public var playSessionID: String?
    public var sessionID: String?
    public var positionTicks: Int?
    public var isFailed: Bool?
    public var playlistItemID: String?
    public var nextMediaType: String?
    public var item: BaseItemDto?
    public var liveStreamID: String?

    public init(itemID: UUID? = nil, mediaSourceID: String? = nil, nowPlayingQueue: [QueueItem]? = nil, playSessionID: String? = nil, sessionID: String? = nil, positionTicks: Int? = nil, isFailed: Bool? = nil, playlistItemID: String? = nil, nextMediaType: String? = nil, item: BaseItemDto? = nil, liveStreamID: String? = nil) {
        self.itemID = itemID
        self.mediaSourceID = mediaSourceID
        self.nowPlayingQueue = nowPlayingQueue
        self.playSessionID = playSessionID
        self.sessionID = sessionID
        self.positionTicks = positionTicks
        self.isFailed = isFailed
        self.playlistItemID = playlistItemID
        self.nextMediaType = nextMediaType
        self.item = item
        self.liveStreamID = liveStreamID
    }

    private enum CodingKeys: String, CodingKey {
        case itemID = "ItemId"
        case mediaSourceID = "MediaSourceId"
        case nowPlayingQueue = "NowPlayingQueue"
        case playSessionID = "PlaySessionId"
        case sessionID = "SessionId"
        case positionTicks = "PositionTicks"
        case isFailed = "Failed"
        case playlistItemID = "PlaylistItemId"
        case nextMediaType = "NextMediaType"
        case item = "Item"
        case liveStreamID = "LiveStreamId"
    }
}

public struct LiveTvInfo: Codable {
    public var enabledUsers: [String]?
    public var services: [LiveTvServiceInfo]?
    public var isEnabled: Bool?

    public init(enabledUsers: [String]? = nil, services: [LiveTvServiceInfo]? = nil, isEnabled: Bool? = nil) {
        self.enabledUsers = enabledUsers
        self.services = services
        self.isEnabled = isEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case enabledUsers = "EnabledUsers"
        case services = "Services"
        case isEnabled = "IsEnabled"
    }
}

public struct AlbumInfo: Codable {
    public var metadataCountryCode: String?
    public var path: String?
    public var providerIDs: [String: String]?
    public var parentIndexNumber: Int?
    public var songInfos: [SongInfo]?
    public var artistProviderIDs: [String: String]?
    public var albumArtists: [String]?
    public var isAutomated: Bool?
    public var premiereDate: Date?
    public var indexNumber: Int?
    public var metadataLanguage: String?
    public var name: String?
    public var year: Int?

    public init(metadataCountryCode: String? = nil, path: String? = nil, providerIDs: [String: String]? = nil, parentIndexNumber: Int? = nil, songInfos: [SongInfo]? = nil, artistProviderIDs: [String: String]? = nil, albumArtists: [String]? = nil, isAutomated: Bool? = nil, premiereDate: Date? = nil, indexNumber: Int? = nil, metadataLanguage: String? = nil, name: String? = nil, year: Int? = nil) {
        self.metadataCountryCode = metadataCountryCode
        self.path = path
        self.providerIDs = providerIDs
        self.parentIndexNumber = parentIndexNumber
        self.songInfos = songInfos
        self.artistProviderIDs = artistProviderIDs
        self.albumArtists = albumArtists
        self.isAutomated = isAutomated
        self.premiereDate = premiereDate
        self.indexNumber = indexNumber
        self.metadataLanguage = metadataLanguage
        self.name = name
        self.year = year
    }

    private enum CodingKeys: String, CodingKey {
        case metadataCountryCode = "MetadataCountryCode"
        case path = "Path"
        case providerIDs = "ProviderIds"
        case parentIndexNumber = "ParentIndexNumber"
        case songInfos = "SongInfos"
        case artistProviderIDs = "ArtistProviderIds"
        case albumArtists = "AlbumArtists"
        case isAutomated = "IsAutomated"
        case premiereDate = "PremiereDate"
        case indexNumber = "IndexNumber"
        case metadataLanguage = "MetadataLanguage"
        case name = "Name"
        case year = "Year"
    }
}

public struct JoinGroupRequestDto: Codable {
    public var groupID: UUID?

    public init(groupID: UUID? = nil) {
        self.groupID = groupID
    }

    private enum CodingKeys: String, CodingKey {
        case groupID = "GroupId"
    }
}

public struct AdminNotificationDto: Codable {
    public var description: String?
    public var url: String?
    public var notificationLevel: NotificationLevel?
    public var name: String?

    public init(description: String? = nil, url: String? = nil, notificationLevel: NotificationLevel? = nil, name: String? = nil) {
        self.description = description
        self.url = url
        self.notificationLevel = notificationLevel
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case description = "Description"
        case url = "Url"
        case notificationLevel = "NotificationLevel"
        case name = "Name"
    }
}

public enum VideoType: String, Codable, CaseIterable {
    case videoFile = "VideoFile"
    case iso = "Iso"
    case dvd = "Dvd"
    case bluRay = "BluRay"
}

public struct MetadataEditorInfo: Codable {
    public var cultures: [CultureDto]?
    public var countries: [CountryInfo]?
    public var contentType: String?
    public var parentalRatingOptions: [ParentalRating]?
    public var externalIDInfos: [ExternalIDInfo]?
    public var contentTypeOptions: [NameValuePair]?

    public init(cultures: [CultureDto]? = nil, countries: [CountryInfo]? = nil, contentType: String? = nil, parentalRatingOptions: [ParentalRating]? = nil, externalIDInfos: [ExternalIDInfo]? = nil, contentTypeOptions: [NameValuePair]? = nil) {
        self.cultures = cultures
        self.countries = countries
        self.contentType = contentType
        self.parentalRatingOptions = parentalRatingOptions
        self.externalIDInfos = externalIDInfos
        self.contentTypeOptions = contentTypeOptions
    }

    private enum CodingKeys: String, CodingKey {
        case cultures = "Cultures"
        case countries = "Countries"
        case contentType = "ContentType"
        case parentalRatingOptions = "ParentalRatingOptions"
        case externalIDInfos = "ExternalIdInfos"
        case contentTypeOptions = "ContentTypeOptions"
    }
}

public struct PlaybackProgressInfo: Codable {
    public var audioStreamIndex: Int?
    public var repeatMode: RepeatMode?
    public var playlistItemID: String?
    public var nowPlayingQueue: [QueueItem]?
    public var playbackStartTimeTicks: Int?
    public var playSessionID: String?
    public var subtitleStreamIndex: Int?
    public var isPaused: Bool?
    public var itemID: UUID?
    public var volumeLevel: Int?
    public var canSeek: Bool?
    public var liveStreamID: String?
    public var isMuted: Bool?
    public var playMethod: PlayMethod?
    public var brightness: Int?
    public var mediaSourceID: String?
    public var item: BaseItemDto?
    public var sessionID: String?
    public var positionTicks: Int?
    public var aspectRatio: String?

    public init(audioStreamIndex: Int? = nil, repeatMode: RepeatMode? = nil, playlistItemID: String? = nil, nowPlayingQueue: [QueueItem]? = nil, playbackStartTimeTicks: Int? = nil, playSessionID: String? = nil, subtitleStreamIndex: Int? = nil, isPaused: Bool? = nil, itemID: UUID? = nil, volumeLevel: Int? = nil, canSeek: Bool? = nil, liveStreamID: String? = nil, isMuted: Bool? = nil, playMethod: PlayMethod? = nil, brightness: Int? = nil, mediaSourceID: String? = nil, item: BaseItemDto? = nil, sessionID: String? = nil, positionTicks: Int? = nil, aspectRatio: String? = nil) {
        self.audioStreamIndex = audioStreamIndex
        self.repeatMode = repeatMode
        self.playlistItemID = playlistItemID
        self.nowPlayingQueue = nowPlayingQueue
        self.playbackStartTimeTicks = playbackStartTimeTicks
        self.playSessionID = playSessionID
        self.subtitleStreamIndex = subtitleStreamIndex
        self.isPaused = isPaused
        self.itemID = itemID
        self.volumeLevel = volumeLevel
        self.canSeek = canSeek
        self.liveStreamID = liveStreamID
        self.isMuted = isMuted
        self.playMethod = playMethod
        self.brightness = brightness
        self.mediaSourceID = mediaSourceID
        self.item = item
        self.sessionID = sessionID
        self.positionTicks = positionTicks
        self.aspectRatio = aspectRatio
    }

    private enum CodingKeys: String, CodingKey {
        case audioStreamIndex = "AudioStreamIndex"
        case repeatMode = "RepeatMode"
        case playlistItemID = "PlaylistItemId"
        case nowPlayingQueue = "NowPlayingQueue"
        case playbackStartTimeTicks = "PlaybackStartTimeTicks"
        case playSessionID = "PlaySessionId"
        case subtitleStreamIndex = "SubtitleStreamIndex"
        case isPaused = "IsPaused"
        case itemID = "ItemId"
        case volumeLevel = "VolumeLevel"
        case canSeek = "CanSeek"
        case liveStreamID = "LiveStreamId"
        case isMuted = "IsMuted"
        case playMethod = "PlayMethod"
        case brightness = "Brightness"
        case mediaSourceID = "MediaSourceId"
        case item = "Item"
        case sessionID = "SessionId"
        case positionTicks = "PositionTicks"
        case aspectRatio = "AspectRatio"
    }
}

public struct CodecProfile: Codable {
    public var applyConditions: [ProfileCondition]?
    public var container: String?
    public var type: CodecType?
    public var codec: String?
    public var conditions: [ProfileCondition]?

    public init(applyConditions: [ProfileCondition]? = nil, container: String? = nil, type: CodecType? = nil, codec: String? = nil, conditions: [ProfileCondition]? = nil) {
        self.applyConditions = applyConditions
        self.container = container
        self.type = type
        self.codec = codec
        self.conditions = conditions
    }

    private enum CodingKeys: String, CodingKey {
        case applyConditions = "ApplyConditions"
        case container = "Container"
        case type = "Type"
        case codec = "Codec"
        case conditions = "Conditions"
    }
}

public struct ExternalURL: Codable {
    public var url: String?
    public var name: String?

    public init(url: String? = nil, name: String? = nil) {
        self.url = url
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case url = "Url"
        case name = "Name"
    }
}

public struct LiveTvServiceInfo: Codable {
    public var status: LiveTvServiceStatus?
    public var tuners: [String]?
    public var isVisible: Bool?
    public var homePageURL: String?
    public var version: String?
    public var name: String?
    public var statusMessage: String?
    public var hasUpdateAvailable: Bool?

    public init(status: LiveTvServiceStatus? = nil, tuners: [String]? = nil, isVisible: Bool? = nil, homePageURL: String? = nil, version: String? = nil, name: String? = nil, statusMessage: String? = nil, hasUpdateAvailable: Bool? = nil) {
        self.status = status
        self.tuners = tuners
        self.isVisible = isVisible
        self.homePageURL = homePageURL
        self.version = version
        self.name = name
        self.statusMessage = statusMessage
        self.hasUpdateAvailable = hasUpdateAvailable
    }

    private enum CodingKeys: String, CodingKey {
        case status = "Status"
        case tuners = "Tuners"
        case isVisible = "IsVisible"
        case homePageURL = "HomePageUrl"
        case version = "Version"
        case name = "Name"
        case statusMessage = "StatusMessage"
        case hasUpdateAvailable = "HasUpdateAvailable"
    }
}

public enum LogLevel: String, Codable, CaseIterable {
    case trace = "Trace"
    case debug = "Debug"
    case information = "Information"
    case warning = "Warning"
    case error = "Error"
    case critical = "Critical"
    case `none` = "None"
}

public enum ConfigurationPageType: String, Codable, CaseIterable {
    case pluginConfiguration = "PluginConfiguration"
    case `none` = "None"
}

public enum RecordingStatus: String, Codable, CaseIterable {
    case new = "New"
    case inProgress = "InProgress"
    case completed = "Completed"
    case cancelled = "Cancelled"
    case conflictedOk = "ConflictedOk"
    case conflictedNotOk = "ConflictedNotOk"
    case error = "Error"
}

public struct TypeOptions: Codable {
    public var imageFetchers: [String]?
    public var imageOptions: [ImageOption]?
    public var metadataFetchers: [String]?
    public var metadataFetcherOrder: [String]?
    public var imageFetcherOrder: [String]?
    public var type: String?

    public init(imageFetchers: [String]? = nil, imageOptions: [ImageOption]? = nil, metadataFetchers: [String]? = nil, metadataFetcherOrder: [String]? = nil, imageFetcherOrder: [String]? = nil, type: String? = nil) {
        self.imageFetchers = imageFetchers
        self.imageOptions = imageOptions
        self.metadataFetchers = metadataFetchers
        self.metadataFetcherOrder = metadataFetcherOrder
        self.imageFetcherOrder = imageFetcherOrder
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case imageFetchers = "ImageFetchers"
        case imageOptions = "ImageOptions"
        case metadataFetchers = "MetadataFetchers"
        case metadataFetcherOrder = "MetadataFetcherOrder"
        case imageFetcherOrder = "ImageFetcherOrder"
        case type = "Type"
    }
}

public struct ItemCounts: Codable {
    public var albumCount: Int?
    public var musicVideoCount: Int?
    public var programCount: Int?
    public var boxSetCount: Int?
    public var seriesCount: Int?
    public var artistCount: Int?
    public var bookCount: Int?
    public var itemCount: Int?
    public var songCount: Int?
    public var movieCount: Int?
    public var episodeCount: Int?
    public var trailerCount: Int?

    public init(albumCount: Int? = nil, musicVideoCount: Int? = nil, programCount: Int? = nil, boxSetCount: Int? = nil, seriesCount: Int? = nil, artistCount: Int? = nil, bookCount: Int? = nil, itemCount: Int? = nil, songCount: Int? = nil, movieCount: Int? = nil, episodeCount: Int? = nil, trailerCount: Int? = nil) {
        self.albumCount = albumCount
        self.musicVideoCount = musicVideoCount
        self.programCount = programCount
        self.boxSetCount = boxSetCount
        self.seriesCount = seriesCount
        self.artistCount = artistCount
        self.bookCount = bookCount
        self.itemCount = itemCount
        self.songCount = songCount
        self.movieCount = movieCount
        self.episodeCount = episodeCount
        self.trailerCount = trailerCount
    }

    private enum CodingKeys: String, CodingKey {
        case albumCount = "AlbumCount"
        case musicVideoCount = "MusicVideoCount"
        case programCount = "ProgramCount"
        case boxSetCount = "BoxSetCount"
        case seriesCount = "SeriesCount"
        case artistCount = "ArtistCount"
        case bookCount = "BookCount"
        case itemCount = "ItemCount"
        case songCount = "SongCount"
        case movieCount = "MovieCount"
        case episodeCount = "EpisodeCount"
        case trailerCount = "TrailerCount"
    }
}

public struct BaseItemPerson: Codable {
    public var role: String?
    public var imageBlurHashes: ImageBlurHashes?
    public var name: String?
    public var type: String?
    public var primaryImageTag: String?
    public var id: String?

    public struct ImageBlurHashes: Codable {
        public var profile: [String: String]?
        public var art: [String: String]?
        public var backdrop: [String: String]?
        public var banner: [String: String]?
        public var logo: [String: String]?
        public var menu: [String: String]?
        public var screenshot: [String: String]?
        public var box: [String: String]?
        public var thumb: [String: String]?
        public var primary: [String: String]?
        public var chapter: [String: String]?
        public var disc: [String: String]?
        public var boxRear: [String: String]?

        public init(profile: [String: String]? = nil, art: [String: String]? = nil, backdrop: [String: String]? = nil, banner: [String: String]? = nil, logo: [String: String]? = nil, menu: [String: String]? = nil, screenshot: [String: String]? = nil, box: [String: String]? = nil, thumb: [String: String]? = nil, primary: [String: String]? = nil, chapter: [String: String]? = nil, disc: [String: String]? = nil, boxRear: [String: String]? = nil) {
            self.profile = profile
            self.art = art
            self.backdrop = backdrop
            self.banner = banner
            self.logo = logo
            self.menu = menu
            self.screenshot = screenshot
            self.box = box
            self.thumb = thumb
            self.primary = primary
            self.chapter = chapter
            self.disc = disc
            self.boxRear = boxRear
        }

        private enum CodingKeys: String, CodingKey {
            case profile = "Profile"
            case art = "Art"
            case backdrop = "Backdrop"
            case banner = "Banner"
            case logo = "Logo"
            case menu = "Menu"
            case screenshot = "Screenshot"
            case box = "Box"
            case thumb = "Thumb"
            case primary = "Primary"
            case chapter = "Chapter"
            case disc = "Disc"
            case boxRear = "BoxRear"
        }
    }

    public init(role: String? = nil, imageBlurHashes: ImageBlurHashes? = nil, name: String? = nil, type: String? = nil, primaryImageTag: String? = nil, id: String? = nil) {
        self.role = role
        self.imageBlurHashes = imageBlurHashes
        self.name = name
        self.type = type
        self.primaryImageTag = primaryImageTag
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case role = "Role"
        case imageBlurHashes = "ImageBlurHashes"
        case name = "Name"
        case type = "Type"
        case primaryImageTag = "PrimaryImageTag"
        case id = "Id"
    }
}

public struct PluginInfo: Codable {
    public var status: PluginStatus?
    public var description: String?
    public var name: String?
    public var canUninstall: Bool?
    public var hasImage: Bool?
    public var configurationFileName: String?
    public var version: Version?
    public var id: UUID?

    public init(status: PluginStatus? = nil, description: String? = nil, name: String? = nil, canUninstall: Bool? = nil, hasImage: Bool? = nil, configurationFileName: String? = nil, version: Version? = nil, id: UUID? = nil) {
        self.status = status
        self.description = description
        self.name = name
        self.canUninstall = canUninstall
        self.hasImage = hasImage
        self.configurationFileName = configurationFileName
        self.version = version
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case status = "Status"
        case description = "Description"
        case name = "Name"
        case canUninstall = "CanUninstall"
        case hasImage = "HasImage"
        case configurationFileName = "ConfigurationFileName"
        case version = "Version"
        case id = "Id"
    }
}

public struct SystemInfo: Codable {
    public var webSocketPortNumber: Int?
    public var cachePath: String?
    public var internalMetadataPath: String?
    public var operatingSystemDisplayName: String?
    public var operatingSystem: String?
    public var encoderLocation: FFmpegLocation?
    public var systemArchitecture: Architecture?
    public var isStartupWizardCompleted: Bool?
    public var isShuttingDown: Bool?
    public var id: String?
    public var transcodingTempPath: String?
    public var hasUpdateAvailable: Bool?
    public var itemsByNamePath: String?
    public var logPath: String?
    public var isSupportsLibraryMonitor: Bool?
    public var hasPendingRestart: Bool?
    public var canSelfRestart: Bool?
    public var completedInstallations: [InstallationInfo]?
    public var packageName: String?
    public var localAddress: String?
    public var serverName: String?
    public var webPath: String?
    public var programDataPath: String?
    public var productName: String?
    public var version: String?
    public var canLaunchWebBrowser: Bool?

    public init(webSocketPortNumber: Int? = nil, cachePath: String? = nil, internalMetadataPath: String? = nil, operatingSystemDisplayName: String? = nil, operatingSystem: String? = nil, encoderLocation: FFmpegLocation? = nil, systemArchitecture: Architecture? = nil, isStartupWizardCompleted: Bool? = nil, isShuttingDown: Bool? = nil, id: String? = nil, transcodingTempPath: String? = nil, hasUpdateAvailable: Bool? = nil, itemsByNamePath: String? = nil, logPath: String? = nil, isSupportsLibraryMonitor: Bool? = nil, hasPendingRestart: Bool? = nil, canSelfRestart: Bool? = nil, completedInstallations: [InstallationInfo]? = nil, packageName: String? = nil, localAddress: String? = nil, serverName: String? = nil, webPath: String? = nil, programDataPath: String? = nil, productName: String? = nil, version: String? = nil, canLaunchWebBrowser: Bool? = nil) {
        self.webSocketPortNumber = webSocketPortNumber
        self.cachePath = cachePath
        self.internalMetadataPath = internalMetadataPath
        self.operatingSystemDisplayName = operatingSystemDisplayName
        self.operatingSystem = operatingSystem
        self.encoderLocation = encoderLocation
        self.systemArchitecture = systemArchitecture
        self.isStartupWizardCompleted = isStartupWizardCompleted
        self.isShuttingDown = isShuttingDown
        self.id = id
        self.transcodingTempPath = transcodingTempPath
        self.hasUpdateAvailable = hasUpdateAvailable
        self.itemsByNamePath = itemsByNamePath
        self.logPath = logPath
        self.isSupportsLibraryMonitor = isSupportsLibraryMonitor
        self.hasPendingRestart = hasPendingRestart
        self.canSelfRestart = canSelfRestart
        self.completedInstallations = completedInstallations
        self.packageName = packageName
        self.localAddress = localAddress
        self.serverName = serverName
        self.webPath = webPath
        self.programDataPath = programDataPath
        self.productName = productName
        self.version = version
        self.canLaunchWebBrowser = canLaunchWebBrowser
    }

    private enum CodingKeys: String, CodingKey {
        case webSocketPortNumber = "WebSocketPortNumber"
        case cachePath = "CachePath"
        case internalMetadataPath = "InternalMetadataPath"
        case operatingSystemDisplayName = "OperatingSystemDisplayName"
        case operatingSystem = "OperatingSystem"
        case encoderLocation = "EncoderLocation"
        case systemArchitecture = "SystemArchitecture"
        case isStartupWizardCompleted = "StartupWizardCompleted"
        case isShuttingDown = "IsShuttingDown"
        case id = "Id"
        case transcodingTempPath = "TranscodingTempPath"
        case hasUpdateAvailable = "HasUpdateAvailable"
        case itemsByNamePath = "ItemsByNamePath"
        case logPath = "LogPath"
        case isSupportsLibraryMonitor = "SupportsLibraryMonitor"
        case hasPendingRestart = "HasPendingRestart"
        case canSelfRestart = "CanSelfRestart"
        case completedInstallations = "CompletedInstallations"
        case packageName = "PackageName"
        case localAddress = "LocalAddress"
        case serverName = "ServerName"
        case webPath = "WebPath"
        case programDataPath = "ProgramDataPath"
        case productName = "ProductName"
        case version = "Version"
        case canLaunchWebBrowser = "CanLaunchWebBrowser"
    }
}

public struct PlaybackInfoResponse: Codable {
    public var playSessionID: String?
    public var errorCode: PlaybackErrorCode?
    public var mediaSources: [MediaSourceInfo]?

    public init(playSessionID: String? = nil, errorCode: PlaybackErrorCode? = nil, mediaSources: [MediaSourceInfo]? = nil) {
        self.playSessionID = playSessionID
        self.errorCode = errorCode
        self.mediaSources = mediaSources
    }

    private enum CodingKeys: String, CodingKey {
        case playSessionID = "PlaySessionId"
        case errorCode = "ErrorCode"
        case mediaSources = "MediaSources"
    }
}

public struct StartupConfigurationDto: Codable {
    public var metadataCountryCode: String?
    public var uICulture: String?
    public var preferredMetadataLanguage: String?

    public init(metadataCountryCode: String? = nil, uICulture: String? = nil, preferredMetadataLanguage: String? = nil) {
        self.metadataCountryCode = metadataCountryCode
        self.uICulture = uICulture
        self.preferredMetadataLanguage = preferredMetadataLanguage
    }

    private enum CodingKeys: String, CodingKey {
        case metadataCountryCode = "MetadataCountryCode"
        case uICulture = "UICulture"
        case preferredMetadataLanguage = "PreferredMetadataLanguage"
    }
}

public struct BrandingOptions: Codable {
    public var loginDisclaimer: String?
    public var customCss: String?

    public init(loginDisclaimer: String? = nil, customCss: String? = nil) {
        self.loginDisclaimer = loginDisclaimer
        self.customCss = customCss
    }

    private enum CodingKeys: String, CodingKey {
        case loginDisclaimer = "LoginDisclaimer"
        case customCss = "CustomCss"
    }
}

public enum PlayCommand: String, Codable, CaseIterable {
    case playNow = "PlayNow"
    case playNext = "PlayNext"
    case playLast = "PlayLast"
    case playInstantMix = "PlayInstantMix"
    case playShuffle = "PlayShuffle"
}

public enum ChannelItemSortField: String, Codable, CaseIterable {
    case name = "Name"
    case communityRating = "CommunityRating"
    case premiereDate = "PremiereDate"
    case dateCreated = "DateCreated"
    case runtime = "Runtime"
    case playCount = "PlayCount"
    case communityPlayCount = "CommunityPlayCount"
}

public struct RemoteImageInfo: Codable {
    public var thumbnailURL: String?
    public var voteCount: Int?
    public var language: String?
    public var communityRating: Double?
    public var height: Int?
    public var type: ImageType?
    public var width: Int?
    public var providerName: String?
    public var url: String?
    public var ratingType: RatingType?

    public init(thumbnailURL: String? = nil, voteCount: Int? = nil, language: String? = nil, communityRating: Double? = nil, height: Int? = nil, type: ImageType? = nil, width: Int? = nil, providerName: String? = nil, url: String? = nil, ratingType: RatingType? = nil) {
        self.thumbnailURL = thumbnailURL
        self.voteCount = voteCount
        self.language = language
        self.communityRating = communityRating
        self.height = height
        self.type = type
        self.width = width
        self.providerName = providerName
        self.url = url
        self.ratingType = ratingType
    }

    private enum CodingKeys: String, CodingKey {
        case thumbnailURL = "ThumbnailUrl"
        case voteCount = "VoteCount"
        case language = "Language"
        case communityRating = "CommunityRating"
        case height = "Height"
        case type = "Type"
        case width = "Width"
        case providerName = "ProviderName"
        case url = "Url"
        case ratingType = "RatingType"
    }
}

public final class RemoteSearchResult: Codable {
    public let albumArtist: RemoteSearchResult?
    public let artists: [RemoteSearchResult]?
    public let overview: String?
    public let searchProviderName: String?
    public let parentIndexNumber: Int?
    public let name: String?
    public let indexNumber: Int?
    public let providerIDs: [String: String]?
    public let premiereDate: Date?
    public let productionYear: Int?
    public let indexNumberEnd: Int?
    public let imageURL: String?

    public init(albumArtist: RemoteSearchResult? = nil, artists: [RemoteSearchResult]? = nil, overview: String? = nil, searchProviderName: String? = nil, parentIndexNumber: Int? = nil, name: String? = nil, indexNumber: Int? = nil, providerIDs: [String: String]? = nil, premiereDate: Date? = nil, productionYear: Int? = nil, indexNumberEnd: Int? = nil, imageURL: String? = nil) {
        self.albumArtist = albumArtist
        self.artists = artists
        self.overview = overview
        self.searchProviderName = searchProviderName
        self.parentIndexNumber = parentIndexNumber
        self.name = name
        self.indexNumber = indexNumber
        self.providerIDs = providerIDs
        self.premiereDate = premiereDate
        self.productionYear = productionYear
        self.indexNumberEnd = indexNumberEnd
        self.imageURL = imageURL
    }

    private enum CodingKeys: String, CodingKey {
        case albumArtist = "AlbumArtist"
        case artists = "Artists"
        case overview = "Overview"
        case searchProviderName = "SearchProviderName"
        case parentIndexNumber = "ParentIndexNumber"
        case name = "Name"
        case indexNumber = "IndexNumber"
        case providerIDs = "ProviderIds"
        case premiereDate = "PremiereDate"
        case productionYear = "ProductionYear"
        case indexNumberEnd = "IndexNumberEnd"
        case imageURL = "ImageUrl"
    }
}

public struct TrailerInfo: Codable {
    public var parentIndexNumber: Int?
    public var indexNumber: Int?
    public var path: String?
    public var year: Int?
    public var providerIDs: [String: String]?
    public var premiereDate: Date?
    public var isAutomated: Bool?
    public var metadataCountryCode: String?
    public var metadataLanguage: String?
    public var name: String?

    public init(parentIndexNumber: Int? = nil, indexNumber: Int? = nil, path: String? = nil, year: Int? = nil, providerIDs: [String: String]? = nil, premiereDate: Date? = nil, isAutomated: Bool? = nil, metadataCountryCode: String? = nil, metadataLanguage: String? = nil, name: String? = nil) {
        self.parentIndexNumber = parentIndexNumber
        self.indexNumber = indexNumber
        self.path = path
        self.year = year
        self.providerIDs = providerIDs
        self.premiereDate = premiereDate
        self.isAutomated = isAutomated
        self.metadataCountryCode = metadataCountryCode
        self.metadataLanguage = metadataLanguage
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case parentIndexNumber = "ParentIndexNumber"
        case indexNumber = "IndexNumber"
        case path = "Path"
        case year = "Year"
        case providerIDs = "ProviderIds"
        case premiereDate = "PremiereDate"
        case isAutomated = "IsAutomated"
        case metadataCountryCode = "MetadataCountryCode"
        case metadataLanguage = "MetadataLanguage"
        case name = "Name"
    }
}

public struct PlayRequestDto: Codable {
    public var playingQueue: [UUID]?
    public var startPositionTicks: Int?
    public var playingItemPosition: Int?

    public init(playingQueue: [UUID]? = nil, startPositionTicks: Int? = nil, playingItemPosition: Int? = nil) {
        self.playingQueue = playingQueue
        self.startPositionTicks = startPositionTicks
        self.playingItemPosition = playingItemPosition
    }

    private enum CodingKeys: String, CodingKey {
        case playingQueue = "PlayingQueue"
        case startPositionTicks = "StartPositionTicks"
        case playingItemPosition = "PlayingItemPosition"
    }
}

public struct CultureDto: Codable {
    public var threeLetterISOLanguageNames: [String]?
    public var name: String?
    public var threeLetterISOLanguageName: String?
    public var displayName: String?
    public var twoLetterISOLanguageName: String?

    public init(threeLetterISOLanguageNames: [String]? = nil, name: String? = nil, threeLetterISOLanguageName: String? = nil, displayName: String? = nil, twoLetterISOLanguageName: String? = nil) {
        self.threeLetterISOLanguageNames = threeLetterISOLanguageNames
        self.name = name
        self.threeLetterISOLanguageName = threeLetterISOLanguageName
        self.displayName = displayName
        self.twoLetterISOLanguageName = twoLetterISOLanguageName
    }

    private enum CodingKeys: String, CodingKey {
        case threeLetterISOLanguageNames = "ThreeLetterISOLanguageNames"
        case name = "Name"
        case threeLetterISOLanguageName = "ThreeLetterISOLanguageName"
        case displayName = "DisplayName"
        case twoLetterISOLanguageName = "TwoLetterISOLanguageName"
    }
}

public struct TaskInfo: Codable {
    public var triggers: [TaskTriggerInfo]?
    public var state: TaskState?
    public var currentProgressPercentage: Double?
    public var key: String?
    public var id: String?
    public var isHidden: Bool?
    public var description: String?
    public var name: String?
    public var category: String?
    public var lastExecutionResult: TaskResult?

    public init(triggers: [TaskTriggerInfo]? = nil, state: TaskState? = nil, currentProgressPercentage: Double? = nil, key: String? = nil, id: String? = nil, isHidden: Bool? = nil, description: String? = nil, name: String? = nil, category: String? = nil, lastExecutionResult: TaskResult? = nil) {
        self.triggers = triggers
        self.state = state
        self.currentProgressPercentage = currentProgressPercentage
        self.key = key
        self.id = id
        self.isHidden = isHidden
        self.description = description
        self.name = name
        self.category = category
        self.lastExecutionResult = lastExecutionResult
    }

    private enum CodingKeys: String, CodingKey {
        case triggers = "Triggers"
        case state = "State"
        case currentProgressPercentage = "CurrentProgressPercentage"
        case key = "Key"
        case id = "Id"
        case isHidden = "IsHidden"
        case description = "Description"
        case name = "Name"
        case category = "Category"
        case lastExecutionResult = "LastExecutionResult"
    }
}

public struct TaskResult: Codable {
    public var longErrorMessage: String?
    public var startTimeUtc: Date?
    public var errorMessage: String?
    public var id: String?
    public var key: String?
    public var endTimeUtc: Date?
    public var name: String?
    public var status: TaskCompletionStatus?

    public init(longErrorMessage: String? = nil, startTimeUtc: Date? = nil, errorMessage: String? = nil, id: String? = nil, key: String? = nil, endTimeUtc: Date? = nil, name: String? = nil, status: TaskCompletionStatus? = nil) {
        self.longErrorMessage = longErrorMessage
        self.startTimeUtc = startTimeUtc
        self.errorMessage = errorMessage
        self.id = id
        self.key = key
        self.endTimeUtc = endTimeUtc
        self.name = name
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case longErrorMessage = "LongErrorMessage"
        case startTimeUtc = "StartTimeUtc"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case key = "Key"
        case endTimeUtc = "EndTimeUtc"
        case name = "Name"
        case status = "Status"
    }
}

public struct AlbumInfoRemoteSearchQuery: Codable {
    public var itemID: UUID?
    public var searchProviderName: String?
    public var isIncludeDisabledProviders: Bool?
    public var searchInfo: AlbumInfo?

    public init(itemID: UUID? = nil, searchProviderName: String? = nil, isIncludeDisabledProviders: Bool? = nil, searchInfo: AlbumInfo? = nil) {
        self.itemID = itemID
        self.searchProviderName = searchProviderName
        self.isIncludeDisabledProviders = isIncludeDisabledProviders
        self.searchInfo = searchInfo
    }

    private enum CodingKeys: String, CodingKey {
        case itemID = "ItemId"
        case searchProviderName = "SearchProviderName"
        case isIncludeDisabledProviders = "IncludeDisabledProviders"
        case searchInfo = "SearchInfo"
    }
}

public struct ResponseProfile: Codable {
    public var audioCodec: String?
    public var container: String?
    public var mimeType: String?
    public var type: DlnaProfileType?
    public var videoCodec: String?
    public var orgPn: String?
    public var conditions: [ProfileCondition]?

    public init(audioCodec: String? = nil, container: String? = nil, mimeType: String? = nil, type: DlnaProfileType? = nil, videoCodec: String? = nil, orgPn: String? = nil, conditions: [ProfileCondition]? = nil) {
        self.audioCodec = audioCodec
        self.container = container
        self.mimeType = mimeType
        self.type = type
        self.videoCodec = videoCodec
        self.orgPn = orgPn
        self.conditions = conditions
    }

    private enum CodingKeys: String, CodingKey {
        case audioCodec = "AudioCodec"
        case container = "Container"
        case mimeType = "MimeType"
        case type = "Type"
        case videoCodec = "VideoCodec"
        case orgPn = "OrgPn"
        case conditions = "Conditions"
    }
}

public struct TunerHostInfo: Codable {
    public var userAgent: String?
    public var isImportFavoritesOnly: Bool?
    public var tunerCount: Int?
    public var id: String?
    public var enableStreamLooping: Bool?
    public var allowHWTranscoding: Bool?
    public var deviceID: String?
    public var source: String?
    public var type: String?
    public var friendlyName: String?
    public var url: String?

    public init(userAgent: String? = nil, isImportFavoritesOnly: Bool? = nil, tunerCount: Int? = nil, id: String? = nil, enableStreamLooping: Bool? = nil, allowHWTranscoding: Bool? = nil, deviceID: String? = nil, source: String? = nil, type: String? = nil, friendlyName: String? = nil, url: String? = nil) {
        self.userAgent = userAgent
        self.isImportFavoritesOnly = isImportFavoritesOnly
        self.tunerCount = tunerCount
        self.id = id
        self.enableStreamLooping = enableStreamLooping
        self.allowHWTranscoding = allowHWTranscoding
        self.deviceID = deviceID
        self.source = source
        self.type = type
        self.friendlyName = friendlyName
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case userAgent = "UserAgent"
        case isImportFavoritesOnly = "ImportFavoritesOnly"
        case tunerCount = "TunerCount"
        case id = "Id"
        case enableStreamLooping = "EnableStreamLooping"
        case allowHWTranscoding = "AllowHWTranscoding"
        case deviceID = "DeviceId"
        case source = "Source"
        case type = "Type"
        case friendlyName = "FriendlyName"
        case url = "Url"
    }
}

public struct QueryFilters: Codable {
    public var tags: [String]?
    public var genres: [NameGuidPair]?

    public init(tags: [String]? = nil, genres: [NameGuidPair]? = nil) {
        self.tags = tags
        self.genres = genres
    }

    private enum CodingKeys: String, CodingKey {
        case tags = "Tags"
        case genres = "Genres"
    }
}

public struct PersonLookupInfo: Codable {
    public var metadataCountryCode: String?
    public var premiereDate: Date?
    public var isAutomated: Bool?
    public var name: String?
    public var year: Int?
    public var providerIDs: [String: String]?
    public var parentIndexNumber: Int?
    public var indexNumber: Int?
    public var path: String?
    public var metadataLanguage: String?

    public init(metadataCountryCode: String? = nil, premiereDate: Date? = nil, isAutomated: Bool? = nil, name: String? = nil, year: Int? = nil, providerIDs: [String: String]? = nil, parentIndexNumber: Int? = nil, indexNumber: Int? = nil, path: String? = nil, metadataLanguage: String? = nil) {
        self.metadataCountryCode = metadataCountryCode
        self.premiereDate = premiereDate
        self.isAutomated = isAutomated
        self.name = name
        self.year = year
        self.providerIDs = providerIDs
        self.parentIndexNumber = parentIndexNumber
        self.indexNumber = indexNumber
        self.path = path
        self.metadataLanguage = metadataLanguage
    }

    private enum CodingKeys: String, CodingKey {
        case metadataCountryCode = "MetadataCountryCode"
        case premiereDate = "PremiereDate"
        case isAutomated = "IsAutomated"
        case name = "Name"
        case year = "Year"
        case providerIDs = "ProviderIds"
        case parentIndexNumber = "ParentIndexNumber"
        case indexNumber = "IndexNumber"
        case path = "Path"
        case metadataLanguage = "MetadataLanguage"
    }
}

public struct PinRedeemResult: Codable {
    public var isSuccess: Bool?
    public var usersReset: [String]?

    public init(isSuccess: Bool? = nil, usersReset: [String]? = nil) {
        self.isSuccess = isSuccess
        self.usersReset = usersReset
    }

    private enum CodingKeys: String, CodingKey {
        case isSuccess = "Success"
        case usersReset = "UsersReset"
    }
}

public enum FFmpegLocation: String, Codable, CaseIterable {
    case notFound = "NotFound"
    case setByArgument = "SetByArgument"
    case custom = "Custom"
    case system = "System"
}

public struct NotificationsSummaryDto: Codable {
    public var unreadCount: Int?
    public var maxUnreadNotificationLevel: NotificationLevel?

    public init(unreadCount: Int? = nil, maxUnreadNotificationLevel: NotificationLevel? = nil) {
        self.unreadCount = unreadCount
        self.maxUnreadNotificationLevel = maxUnreadNotificationLevel
    }

    private enum CodingKeys: String, CodingKey {
        case unreadCount = "UnreadCount"
        case maxUnreadNotificationLevel = "MaxUnreadNotificationLevel"
    }
}

public enum TranscodeSeekInfo: String, Codable, CaseIterable {
    case auto = "Auto"
    case bytes = "Bytes"
}

public struct CountryInfo: Codable {
    public var twoLetterISORegionName: String?
    public var displayName: String?
    public var name: String?
    public var threeLetterISORegionName: String?

    public init(twoLetterISORegionName: String? = nil, displayName: String? = nil, name: String? = nil, threeLetterISORegionName: String? = nil) {
        self.twoLetterISORegionName = twoLetterISORegionName
        self.displayName = displayName
        self.name = name
        self.threeLetterISORegionName = threeLetterISORegionName
    }

    private enum CodingKeys: String, CodingKey {
        case twoLetterISORegionName = "TwoLetterISORegionName"
        case displayName = "DisplayName"
        case name = "Name"
        case threeLetterISORegionName = "ThreeLetterISORegionName"
    }
}

public struct UserPolicy: Codable {
    public var isForceRemoteSourceTranscoding: Bool?
    public var enablePublicSharing: Bool?
    public var enablePlaybackRemuxing: Bool?
    public var invalidLoginAttemptCount: Int?
    public var syncPlayAccess: SyncPlayUserAccessType?
    public var enableAllFolders: Bool?
    public var isDisabled: Bool?
    public var maxActiveSessions: Int?
    public var enableContentDownloading: Bool?
    public var loginAttemptsBeforeLockout: Int?
    public var enableAudioPlaybackTranscoding: Bool?
    public var passwordResetProviderID: String?
    public var enableRemoteControlOfOtherUsers: Bool?
    public var authenticationProviderID: String?
    public var enableRemoteAccess: Bool?
    public var enableContentDeletion: Bool?
    public var enableMediaConversion: Bool?
    public var blockedMediaFolders: [UUID]?
    public var isHidden: Bool?
    public var blockedChannels: [UUID]?
    public var isAdministrator: Bool?
    public var enableSharedDeviceControl: Bool?
    public var maxParentalRating: Int?
    public var enableVideoPlaybackTranscoding: Bool?
    public var remoteClientBitrateLimit: Int?
    public var enableUserPreferenceAccess: Bool?
    public var enableAllDevices: Bool?
    public var enabledChannels: [UUID]?
    public var blockUnratedItems: [UnratedItem]?
    public var enableSyncTranscoding: Bool?
    public var enabledFolders: [UUID]?
    public var enableAllChannels: Bool?
    public var enableContentDeletionFromFolders: [String]?
    public var enabledDevices: [String]?
    public var enableLiveTvAccess: Bool?
    public var enableLiveTvManagement: Bool?
    public var accessSchedules: [AccessSchedule]?
    public var enableMediaPlayback: Bool?
    public var blockedTags: [String]?

    public init(isForceRemoteSourceTranscoding: Bool? = nil, enablePublicSharing: Bool? = nil, enablePlaybackRemuxing: Bool? = nil, invalidLoginAttemptCount: Int? = nil, syncPlayAccess: SyncPlayUserAccessType? = nil, enableAllFolders: Bool? = nil, isDisabled: Bool? = nil, maxActiveSessions: Int? = nil, enableContentDownloading: Bool? = nil, loginAttemptsBeforeLockout: Int? = nil, enableAudioPlaybackTranscoding: Bool? = nil, passwordResetProviderID: String? = nil, enableRemoteControlOfOtherUsers: Bool? = nil, authenticationProviderID: String? = nil, enableRemoteAccess: Bool? = nil, enableContentDeletion: Bool? = nil, enableMediaConversion: Bool? = nil, blockedMediaFolders: [UUID]? = nil, isHidden: Bool? = nil, blockedChannels: [UUID]? = nil, isAdministrator: Bool? = nil, enableSharedDeviceControl: Bool? = nil, maxParentalRating: Int? = nil, enableVideoPlaybackTranscoding: Bool? = nil, remoteClientBitrateLimit: Int? = nil, enableUserPreferenceAccess: Bool? = nil, enableAllDevices: Bool? = nil, enabledChannels: [UUID]? = nil, blockUnratedItems: [UnratedItem]? = nil, enableSyncTranscoding: Bool? = nil, enabledFolders: [UUID]? = nil, enableAllChannels: Bool? = nil, enableContentDeletionFromFolders: [String]? = nil, enabledDevices: [String]? = nil, enableLiveTvAccess: Bool? = nil, enableLiveTvManagement: Bool? = nil, accessSchedules: [AccessSchedule]? = nil, enableMediaPlayback: Bool? = nil, blockedTags: [String]? = nil) {
        self.isForceRemoteSourceTranscoding = isForceRemoteSourceTranscoding
        self.enablePublicSharing = enablePublicSharing
        self.enablePlaybackRemuxing = enablePlaybackRemuxing
        self.invalidLoginAttemptCount = invalidLoginAttemptCount
        self.syncPlayAccess = syncPlayAccess
        self.enableAllFolders = enableAllFolders
        self.isDisabled = isDisabled
        self.maxActiveSessions = maxActiveSessions
        self.enableContentDownloading = enableContentDownloading
        self.loginAttemptsBeforeLockout = loginAttemptsBeforeLockout
        self.enableAudioPlaybackTranscoding = enableAudioPlaybackTranscoding
        self.passwordResetProviderID = passwordResetProviderID
        self.enableRemoteControlOfOtherUsers = enableRemoteControlOfOtherUsers
        self.authenticationProviderID = authenticationProviderID
        self.enableRemoteAccess = enableRemoteAccess
        self.enableContentDeletion = enableContentDeletion
        self.enableMediaConversion = enableMediaConversion
        self.blockedMediaFolders = blockedMediaFolders
        self.isHidden = isHidden
        self.blockedChannels = blockedChannels
        self.isAdministrator = isAdministrator
        self.enableSharedDeviceControl = enableSharedDeviceControl
        self.maxParentalRating = maxParentalRating
        self.enableVideoPlaybackTranscoding = enableVideoPlaybackTranscoding
        self.remoteClientBitrateLimit = remoteClientBitrateLimit
        self.enableUserPreferenceAccess = enableUserPreferenceAccess
        self.enableAllDevices = enableAllDevices
        self.enabledChannels = enabledChannels
        self.blockUnratedItems = blockUnratedItems
        self.enableSyncTranscoding = enableSyncTranscoding
        self.enabledFolders = enabledFolders
        self.enableAllChannels = enableAllChannels
        self.enableContentDeletionFromFolders = enableContentDeletionFromFolders
        self.enabledDevices = enabledDevices
        self.enableLiveTvAccess = enableLiveTvAccess
        self.enableLiveTvManagement = enableLiveTvManagement
        self.accessSchedules = accessSchedules
        self.enableMediaPlayback = enableMediaPlayback
        self.blockedTags = blockedTags
    }

    private enum CodingKeys: String, CodingKey {
        case isForceRemoteSourceTranscoding = "ForceRemoteSourceTranscoding"
        case enablePublicSharing = "EnablePublicSharing"
        case enablePlaybackRemuxing = "EnablePlaybackRemuxing"
        case invalidLoginAttemptCount = "InvalidLoginAttemptCount"
        case syncPlayAccess = "SyncPlayAccess"
        case enableAllFolders = "EnableAllFolders"
        case isDisabled = "IsDisabled"
        case maxActiveSessions = "MaxActiveSessions"
        case enableContentDownloading = "EnableContentDownloading"
        case loginAttemptsBeforeLockout = "LoginAttemptsBeforeLockout"
        case enableAudioPlaybackTranscoding = "EnableAudioPlaybackTranscoding"
        case passwordResetProviderID = "PasswordResetProviderId"
        case enableRemoteControlOfOtherUsers = "EnableRemoteControlOfOtherUsers"
        case authenticationProviderID = "AuthenticationProviderId"
        case enableRemoteAccess = "EnableRemoteAccess"
        case enableContentDeletion = "EnableContentDeletion"
        case enableMediaConversion = "EnableMediaConversion"
        case blockedMediaFolders = "BlockedMediaFolders"
        case isHidden = "IsHidden"
        case blockedChannels = "BlockedChannels"
        case isAdministrator = "IsAdministrator"
        case enableSharedDeviceControl = "EnableSharedDeviceControl"
        case maxParentalRating = "MaxParentalRating"
        case enableVideoPlaybackTranscoding = "EnableVideoPlaybackTranscoding"
        case remoteClientBitrateLimit = "RemoteClientBitrateLimit"
        case enableUserPreferenceAccess = "EnableUserPreferenceAccess"
        case enableAllDevices = "EnableAllDevices"
        case enabledChannels = "EnabledChannels"
        case blockUnratedItems = "BlockUnratedItems"
        case enableSyncTranscoding = "EnableSyncTranscoding"
        case enabledFolders = "EnabledFolders"
        case enableAllChannels = "EnableAllChannels"
        case enableContentDeletionFromFolders = "EnableContentDeletionFromFolders"
        case enabledDevices = "EnabledDevices"
        case enableLiveTvAccess = "EnableLiveTvAccess"
        case enableLiveTvManagement = "EnableLiveTvManagement"
        case accessSchedules = "AccessSchedules"
        case enableMediaPlayback = "EnableMediaPlayback"
        case blockedTags = "BlockedTags"
    }
}

public struct SearchHintResult: Codable {
    public var searchHints: [SearchHint]?
    public var totalRecordCount: Int?

    public init(searchHints: [SearchHint]? = nil, totalRecordCount: Int? = nil) {
        self.searchHints = searchHints
        self.totalRecordCount = totalRecordCount
    }

    private enum CodingKeys: String, CodingKey {
        case searchHints = "SearchHints"
        case totalRecordCount = "TotalRecordCount"
    }
}

public struct UpdateUserEasyPassword: Codable {
    public var newPassword: String?
    public var isResetPassword: Bool?
    public var newPw: String?

    public init(newPassword: String? = nil, isResetPassword: Bool? = nil, newPw: String? = nil) {
        self.newPassword = newPassword
        self.isResetPassword = isResetPassword
        self.newPw = newPw
    }

    private enum CodingKeys: String, CodingKey {
        case newPassword = "NewPassword"
        case isResetPassword = "ResetPassword"
        case newPw = "NewPw"
    }
}

public struct BoxSetInfoRemoteSearchQuery: Codable {
    public var itemID: UUID?
    public var searchProviderName: String?
    public var isIncludeDisabledProviders: Bool?
    public var searchInfo: BoxSetInfo?

    public init(itemID: UUID? = nil, searchProviderName: String? = nil, isIncludeDisabledProviders: Bool? = nil, searchInfo: BoxSetInfo? = nil) {
        self.itemID = itemID
        self.searchProviderName = searchProviderName
        self.isIncludeDisabledProviders = isIncludeDisabledProviders
        self.searchInfo = searchInfo
    }

    private enum CodingKeys: String, CodingKey {
        case itemID = "ItemId"
        case searchProviderName = "SearchProviderName"
        case isIncludeDisabledProviders = "IncludeDisabledProviders"
        case searchInfo = "SearchInfo"
    }
}

public enum ImageType: String, Codable, CaseIterable {
    case primary = "Primary"
    case art = "Art"
    case backdrop = "Backdrop"
    case banner = "Banner"
    case logo = "Logo"
    case thumb = "Thumb"
    case disc = "Disc"
    case box = "Box"
    case screenshot = "Screenshot"
    case menu = "Menu"
    case chapter = "Chapter"
    case boxRear = "BoxRear"
    case profile = "Profile"
}

public struct QueryFiltersLegacy: Codable {
    public var officialRatings: [String]?
    public var genres: [String]?
    public var years: [Int]?
    public var tags: [String]?

    public init(officialRatings: [String]? = nil, genres: [String]? = nil, years: [Int]? = nil, tags: [String]? = nil) {
        self.officialRatings = officialRatings
        self.genres = genres
        self.years = years
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case officialRatings = "OfficialRatings"
        case genres = "Genres"
        case years = "Years"
        case tags = "Tags"
    }
}

public struct AllThemeMediaResult: Codable {
    public var themeVideosResult: ThemeMediaResult?
    public var soundtrackSongsResult: ThemeMediaResult?
    public var themeSongsResult: ThemeMediaResult?

    public init(themeVideosResult: ThemeMediaResult? = nil, soundtrackSongsResult: ThemeMediaResult? = nil, themeSongsResult: ThemeMediaResult? = nil) {
        self.themeVideosResult = themeVideosResult
        self.soundtrackSongsResult = soundtrackSongsResult
        self.themeSongsResult = themeSongsResult
    }

    private enum CodingKeys: String, CodingKey {
        case themeVideosResult = "ThemeVideosResult"
        case soundtrackSongsResult = "SoundtrackSongsResult"
        case themeSongsResult = "ThemeSongsResult"
    }
}

public struct DeviceOptions: Codable {
    public var customName: String?

    public init(customName: String? = nil) {
        self.customName = customName
    }

    private enum CodingKeys: String, CodingKey {
        case customName = "CustomName"
    }
}

public struct ClientCapabilities: Codable {
    public var messageCallbackURL: String?
    public var deviceProfile: DeviceProfile?
    public var isSupportsContentUploading: Bool?
    public var isSupportsPersistentIdentifier: Bool?
    public var isSupportsSync: Bool?
    public var appStoreURL: String?
    public var playableMediaTypes: [String]?
    public var isSupportsMediaControl: Bool?
    public var supportedCommands: [GeneralCommandType]?
    public var iconURL: String?

    public init(messageCallbackURL: String? = nil, deviceProfile: DeviceProfile? = nil, isSupportsContentUploading: Bool? = nil, isSupportsPersistentIdentifier: Bool? = nil, isSupportsSync: Bool? = nil, appStoreURL: String? = nil, playableMediaTypes: [String]? = nil, isSupportsMediaControl: Bool? = nil, supportedCommands: [GeneralCommandType]? = nil, iconURL: String? = nil) {
        self.messageCallbackURL = messageCallbackURL
        self.deviceProfile = deviceProfile
        self.isSupportsContentUploading = isSupportsContentUploading
        self.isSupportsPersistentIdentifier = isSupportsPersistentIdentifier
        self.isSupportsSync = isSupportsSync
        self.appStoreURL = appStoreURL
        self.playableMediaTypes = playableMediaTypes
        self.isSupportsMediaControl = isSupportsMediaControl
        self.supportedCommands = supportedCommands
        self.iconURL = iconURL
    }

    private enum CodingKeys: String, CodingKey {
        case messageCallbackURL = "MessageCallbackUrl"
        case deviceProfile = "DeviceProfile"
        case isSupportsContentUploading = "SupportsContentUploading"
        case isSupportsPersistentIdentifier = "SupportsPersistentIdentifier"
        case isSupportsSync = "SupportsSync"
        case appStoreURL = "AppStoreUrl"
        case playableMediaTypes = "PlayableMediaTypes"
        case isSupportsMediaControl = "SupportsMediaControl"
        case supportedCommands = "SupportedCommands"
        case iconURL = "IconUrl"
    }
}

public struct UpdateUserPassword: Codable {
    public var isResetPassword: Bool?
    public var newPw: String?
    public var currentPassword: String?
    public var currentPw: String?

    public init(isResetPassword: Bool? = nil, newPw: String? = nil, currentPassword: String? = nil, currentPw: String? = nil) {
        self.isResetPassword = isResetPassword
        self.newPw = newPw
        self.currentPassword = currentPassword
        self.currentPw = currentPw
    }

    private enum CodingKeys: String, CodingKey {
        case isResetPassword = "ResetPassword"
        case newPw = "NewPw"
        case currentPassword = "CurrentPassword"
        case currentPw = "CurrentPw"
    }
}

public enum ChannelMediaContentType: String, Codable, CaseIterable {
    case clip = "Clip"
    case podcast = "Podcast"
    case trailer = "Trailer"
    case movie = "Movie"
    case episode = "Episode"
    case song = "Song"
    case movieExtra = "MovieExtra"
    case tvExtra = "TvExtra"
}

public enum SubtitlePlaybackMode: String, Codable, CaseIterable {
    case `default` = "Default"
    case always = "Always"
    case onlyForced = "OnlyForced"
    case `none` = "None"
    case smart = "Smart"
}

public struct PathSubstitution: Codable {
    public var to: String?
    public var from: String?

    public init(to: String? = nil, from: String? = nil) {
        self.to = to
        self.from = from
    }

    private enum CodingKeys: String, CodingKey {
        case to = "To"
        case from = "From"
    }
}

public struct ProfileCondition: Codable {
    public var property: ProfileConditionValue?
    public var isRequired: Bool?
    public var condition: ProfileConditionType?
    public var value: String?

    public init(property: ProfileConditionValue? = nil, isRequired: Bool? = nil, condition: ProfileConditionType? = nil, value: String? = nil) {
        self.property = property
        self.isRequired = isRequired
        self.condition = condition
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case property = "Property"
        case isRequired = "IsRequired"
        case condition = "Condition"
        case value = "Value"
    }
}

public struct TimerInfoDtoQueryResult: Codable {
    public var startIndex: Int?
    public var totalRecordCount: Int?
    public var items: [TimerInfoDto]?

    public init(startIndex: Int? = nil, totalRecordCount: Int? = nil, items: [TimerInfoDto]? = nil) {
        self.startIndex = startIndex
        self.totalRecordCount = totalRecordCount
        self.items = items
    }

    private enum CodingKeys: String, CodingKey {
        case startIndex = "StartIndex"
        case totalRecordCount = "TotalRecordCount"
        case items = "Items"
    }
}

public struct MediaURL: Codable {
    public var name: String?
    public var url: String?

    public init(name: String? = nil, url: String? = nil) {
        self.name = name
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case url = "Url"
    }
}

public enum LocationType: String, Codable, CaseIterable {
    case fileSystem = "FileSystem"
    case remote = "Remote"
    case virtual = "Virtual"
    case offline = "Offline"
}

public enum ExternalIDMediaType: String, Codable, CaseIterable {
    case album = "Album"
    case albumArtist = "AlbumArtist"
    case artist = "Artist"
    case boxSet = "BoxSet"
    case episode = "Episode"
    case movie = "Movie"
    case otherArtist = "OtherArtist"
    case person = "Person"
    case releaseGroup = "ReleaseGroup"
    case season = "Season"
    case series = "Series"
    case track = "Track"
}

public struct RemoteSubtitleInfo: Codable {
    public var threeLetterISOLanguageName: String?
    public var comment: String?
    public var isHashMatch: Bool?
    public var name: String?
    public var providerName: String?
    public var format: String?
    public var author: String?
    public var id: String?
    public var dateCreated: Date?
    public var downloadCount: Int?
    public var communityRating: Double?

    public init(threeLetterISOLanguageName: String? = nil, comment: String? = nil, isHashMatch: Bool? = nil, name: String? = nil, providerName: String? = nil, format: String? = nil, author: String? = nil, id: String? = nil, dateCreated: Date? = nil, downloadCount: Int? = nil, communityRating: Double? = nil) {
        self.threeLetterISOLanguageName = threeLetterISOLanguageName
        self.comment = comment
        self.isHashMatch = isHashMatch
        self.name = name
        self.providerName = providerName
        self.format = format
        self.author = author
        self.id = id
        self.dateCreated = dateCreated
        self.downloadCount = downloadCount
        self.communityRating = communityRating
    }

    private enum CodingKeys: String, CodingKey {
        case threeLetterISOLanguageName = "ThreeLetterISOLanguageName"
        case comment = "Comment"
        case isHashMatch = "IsHashMatch"
        case name = "Name"
        case providerName = "ProviderName"
        case format = "Format"
        case author = "Author"
        case id = "Id"
        case dateCreated = "DateCreated"
        case downloadCount = "DownloadCount"
        case communityRating = "CommunityRating"
    }
}

public struct ChannelFeatures: Codable {
    public var name: String?
    public var defaultSortFields: [ChannelItemSortField]?
    public var autoRefreshLevels: Int?
    public var id: String?
    public var canSearch: Bool?
    public var canFilter: Bool?
    public var maxPageSize: Int?
    public var contentTypes: [ChannelMediaContentType]?
    public var mediaTypes: [ChannelMediaType]?
    public var isSupportsSortOrderToggle: Bool?
    public var isSupportsContentDownloading: Bool?
    public var isSupportsLatestMedia: Bool?

    public init(name: String? = nil, defaultSortFields: [ChannelItemSortField]? = nil, autoRefreshLevels: Int? = nil, id: String? = nil, canSearch: Bool? = nil, canFilter: Bool? = nil, maxPageSize: Int? = nil, contentTypes: [ChannelMediaContentType]? = nil, mediaTypes: [ChannelMediaType]? = nil, isSupportsSortOrderToggle: Bool? = nil, isSupportsContentDownloading: Bool? = nil, isSupportsLatestMedia: Bool? = nil) {
        self.name = name
        self.defaultSortFields = defaultSortFields
        self.autoRefreshLevels = autoRefreshLevels
        self.id = id
        self.canSearch = canSearch
        self.canFilter = canFilter
        self.maxPageSize = maxPageSize
        self.contentTypes = contentTypes
        self.mediaTypes = mediaTypes
        self.isSupportsSortOrderToggle = isSupportsSortOrderToggle
        self.isSupportsContentDownloading = isSupportsContentDownloading
        self.isSupportsLatestMedia = isSupportsLatestMedia
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case defaultSortFields = "DefaultSortFields"
        case autoRefreshLevels = "AutoRefreshLevels"
        case id = "Id"
        case canSearch = "CanSearch"
        case canFilter = "CanFilter"
        case maxPageSize = "MaxPageSize"
        case contentTypes = "ContentTypes"
        case mediaTypes = "MediaTypes"
        case isSupportsSortOrderToggle = "SupportsSortOrderToggle"
        case isSupportsContentDownloading = "SupportsContentDownloading"
        case isSupportsLatestMedia = "SupportsLatestMedia"
    }
}

public enum MediaSourceType: String, Codable, CaseIterable {
    case `default` = "Default"
    case grouping = "Grouping"
    case placeholder = "Placeholder"
}

public struct MetadataOptions: Codable {
    public var localMetadataReaderOrder: [String]?
    public var metadataFetcherOrder: [String]?
    public var disabledImageFetchers: [String]?
    public var imageFetcherOrder: [String]?
    public var disabledMetadataSavers: [String]?
    public var disabledMetadataFetchers: [String]?
    public var itemType: String?

    public init(localMetadataReaderOrder: [String]? = nil, metadataFetcherOrder: [String]? = nil, disabledImageFetchers: [String]? = nil, imageFetcherOrder: [String]? = nil, disabledMetadataSavers: [String]? = nil, disabledMetadataFetchers: [String]? = nil, itemType: String? = nil) {
        self.localMetadataReaderOrder = localMetadataReaderOrder
        self.metadataFetcherOrder = metadataFetcherOrder
        self.disabledImageFetchers = disabledImageFetchers
        self.imageFetcherOrder = imageFetcherOrder
        self.disabledMetadataSavers = disabledMetadataSavers
        self.disabledMetadataFetchers = disabledMetadataFetchers
        self.itemType = itemType
    }

    private enum CodingKeys: String, CodingKey {
        case localMetadataReaderOrder = "LocalMetadataReaderOrder"
        case metadataFetcherOrder = "MetadataFetcherOrder"
        case disabledImageFetchers = "DisabledImageFetchers"
        case imageFetcherOrder = "ImageFetcherOrder"
        case disabledMetadataSavers = "DisabledMetadataSavers"
        case disabledMetadataFetchers = "DisabledMetadataFetchers"
        case itemType = "ItemType"
    }
}

public struct ThemeMediaResult: Codable {
    public var startIndex: Int?
    public var items: [BaseItemDto]?
    public var ownerID: UUID?
    public var totalRecordCount: Int?

    public init(startIndex: Int? = nil, items: [BaseItemDto]? = nil, ownerID: UUID? = nil, totalRecordCount: Int? = nil) {
        self.startIndex = startIndex
        self.items = items
        self.ownerID = ownerID
        self.totalRecordCount = totalRecordCount
    }

    private enum CodingKeys: String, CodingKey {
        case startIndex = "StartIndex"
        case items = "Items"
        case ownerID = "OwnerId"
        case totalRecordCount = "TotalRecordCount"
    }
}

public enum ChannelMediaType: String, Codable, CaseIterable {
    case audio = "Audio"
    case video = "Video"
    case photo = "Photo"
}

public struct UserDto: Codable {
    public var hasConfiguredEasyPassword: Bool?
    public var primaryImageTag: String?
    public var configuration: UserConfiguration?
    public var hasPassword: Bool?
    public var name: String?
    public var hasConfiguredPassword: Bool?
    public var lastActivityDate: Date?
    public var primaryImageAspectRatio: Double?
    public var serverName: String?
    public var lastLoginDate: Date?
    public var serverID: String?
    public var policy: UserPolicy?
    public var id: UUID?
    public var enableAutoLogin: Bool?

    public init(hasConfiguredEasyPassword: Bool? = nil, primaryImageTag: String? = nil, configuration: UserConfiguration? = nil, hasPassword: Bool? = nil, name: String? = nil, hasConfiguredPassword: Bool? = nil, lastActivityDate: Date? = nil, primaryImageAspectRatio: Double? = nil, serverName: String? = nil, lastLoginDate: Date? = nil, serverID: String? = nil, policy: UserPolicy? = nil, id: UUID? = nil, enableAutoLogin: Bool? = nil) {
        self.hasConfiguredEasyPassword = hasConfiguredEasyPassword
        self.primaryImageTag = primaryImageTag
        self.configuration = configuration
        self.hasPassword = hasPassword
        self.name = name
        self.hasConfiguredPassword = hasConfiguredPassword
        self.lastActivityDate = lastActivityDate
        self.primaryImageAspectRatio = primaryImageAspectRatio
        self.serverName = serverName
        self.lastLoginDate = lastLoginDate
        self.serverID = serverID
        self.policy = policy
        self.id = id
        self.enableAutoLogin = enableAutoLogin
    }

    private enum CodingKeys: String, CodingKey {
        case hasConfiguredEasyPassword = "HasConfiguredEasyPassword"
        case primaryImageTag = "PrimaryImageTag"
        case configuration = "Configuration"
        case hasPassword = "HasPassword"
        case name = "Name"
        case hasConfiguredPassword = "HasConfiguredPassword"
        case lastActivityDate = "LastActivityDate"
        case primaryImageAspectRatio = "PrimaryImageAspectRatio"
        case serverName = "ServerName"
        case lastLoginDate = "LastLoginDate"
        case serverID = "ServerId"
        case policy = "Policy"
        case id = "Id"
        case enableAutoLogin = "EnableAutoLogin"
    }
}

public enum TranscodeReason: String, Codable, CaseIterable {
    case containerNotSupported = "ContainerNotSupported"
    case videoCodecNotSupported = "VideoCodecNotSupported"
    case audioCodecNotSupported = "AudioCodecNotSupported"
    case containerBitrateExceedsLimit = "ContainerBitrateExceedsLimit"
    case audioBitrateNotSupported = "AudioBitrateNotSupported"
    case audioChannelsNotSupported = "AudioChannelsNotSupported"
    case videoResolutionNotSupported = "VideoResolutionNotSupported"
    case unknownVideoStreamInfo = "UnknownVideoStreamInfo"
    case unknownAudioStreamInfo = "UnknownAudioStreamInfo"
    case audioProfileNotSupported = "AudioProfileNotSupported"
    case audioSampleRateNotSupported = "AudioSampleRateNotSupported"
    case anamorphicVideoNotSupported = "AnamorphicVideoNotSupported"
    case interlacedVideoNotSupported = "InterlacedVideoNotSupported"
    case secondaryAudioNotSupported = "SecondaryAudioNotSupported"
    case refFramesNotSupported = "RefFramesNotSupported"
    case videoBitDepthNotSupported = "VideoBitDepthNotSupported"
    case videoBitrateNotSupported = "VideoBitrateNotSupported"
    case videoFramerateNotSupported = "VideoFramerateNotSupported"
    case videoLevelNotSupported = "VideoLevelNotSupported"
    case videoProfileNotSupported = "VideoProfileNotSupported"
    case audioBitDepthNotSupported = "AudioBitDepthNotSupported"
    case subtitleCodecNotSupported = "SubtitleCodecNotSupported"
    case directPlayError = "DirectPlayError"
}

public struct CreateUserByName: Codable {
    public var password: String?
    public var name: String?

    public init(password: String? = nil, name: String? = nil) {
        self.password = password
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case password = "Password"
        case name = "Name"
    }
}

public struct RemoveFromPlaylistRequestDto: Codable {
    public var playlistItemIDs: [UUID]?

    public init(playlistItemIDs: [UUID]? = nil) {
        self.playlistItemIDs = playlistItemIDs
    }

    private enum CodingKeys: String, CodingKey {
        case playlistItemIDs = "PlaylistItemIds"
    }
}

public enum FileSystemEntryType: String, Codable, CaseIterable {
    case file = "File"
    case directory = "Directory"
    case networkComputer = "NetworkComputer"
    case networkShare = "NetworkShare"
}

public struct NotificationTypeInfo: Codable {
    public var type: String?
    public var isBasedOnUserEvent: Bool?
    public var isEnabled: Bool?
    public var name: String?
    public var category: String?

    public init(type: String? = nil, isBasedOnUserEvent: Bool? = nil, isEnabled: Bool? = nil, name: String? = nil, category: String? = nil) {
        self.type = type
        self.isBasedOnUserEvent = isBasedOnUserEvent
        self.isEnabled = isEnabled
        self.name = name
        self.category = category
    }

    private enum CodingKeys: String, CodingKey {
        case type = "Type"
        case isBasedOnUserEvent = "IsBasedOnUserEvent"
        case isEnabled = "Enabled"
        case name = "Name"
        case category = "Category"
    }
}

public enum PlaystateCommand: String, Codable, CaseIterable {
    case stop = "Stop"
    case pause = "Pause"
    case unpause = "Unpause"
    case nextTrack = "NextTrack"
    case previousTrack = "PreviousTrack"
    case seek = "Seek"
    case rewind = "Rewind"
    case fastForward = "FastForward"
    case playPause = "PlayPause"
}

public struct UtcTimeResponse: Codable {
    public var responseTransmissionTime: Date?
    public var requestReceptionTime: Date?

    public init(responseTransmissionTime: Date? = nil, requestReceptionTime: Date? = nil) {
        self.responseTransmissionTime = responseTransmissionTime
        self.requestReceptionTime = requestReceptionTime
    }

    private enum CodingKeys: String, CodingKey {
        case responseTransmissionTime = "ResponseTransmissionTime"
        case requestReceptionTime = "RequestReceptionTime"
    }
}

public struct MusicVideoInfoRemoteSearchQuery: Codable {
    public var itemID: UUID?
    public var searchProviderName: String?
    public var searchInfo: MusicVideoInfo?
    public var isIncludeDisabledProviders: Bool?

    public init(itemID: UUID? = nil, searchProviderName: String? = nil, searchInfo: MusicVideoInfo? = nil, isIncludeDisabledProviders: Bool? = nil) {
        self.itemID = itemID
        self.searchProviderName = searchProviderName
        self.searchInfo = searchInfo
        self.isIncludeDisabledProviders = isIncludeDisabledProviders
    }

    private enum CodingKeys: String, CodingKey {
        case itemID = "ItemId"
        case searchProviderName = "SearchProviderName"
        case searchInfo = "SearchInfo"
        case isIncludeDisabledProviders = "IncludeDisabledProviders"
    }
}

public struct ChannelMappingOptionsDto: Codable {
    public var providerChannels: [NameIDPair]?
    public var providerName: String?
    public var mappings: [NameValuePair]?
    public var tunerChannels: [TunerChannelMapping]?

    public init(providerChannels: [NameIDPair]? = nil, providerName: String? = nil, mappings: [NameValuePair]? = nil, tunerChannels: [TunerChannelMapping]? = nil) {
        self.providerChannels = providerChannels
        self.providerName = providerName
        self.mappings = mappings
        self.tunerChannels = tunerChannels
    }

    private enum CodingKeys: String, CodingKey {
        case providerChannels = "ProviderChannels"
        case providerName = "ProviderName"
        case mappings = "Mappings"
        case tunerChannels = "TunerChannels"
    }
}

public enum Architecture: String, Codable, CaseIterable {
    case x86 = "X86"
    case x64 = "X64"
    case arm = "Arm"
    case arm64 = "Arm64"
    case wasm = "Wasm"
}

public enum SortOrder: String, Codable, CaseIterable {
    case ascending = "Ascending"
    case descending = "Descending"
}

public struct ImageOption: Codable {
    public var limit: Int?
    public var type: ImageType?
    public var minWidth: Int?

    public init(limit: Int? = nil, type: ImageType? = nil, minWidth: Int? = nil) {
        self.limit = limit
        self.type = type
        self.minWidth = minWidth
    }

    private enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case type = "Type"
        case minWidth = "MinWidth"
    }
}

public struct PersonLookupInfoRemoteSearchQuery: Codable {
    public var isIncludeDisabledProviders: Bool?
    public var searchInfo: PersonLookupInfo?
    public var searchProviderName: String?
    public var itemID: UUID?

    public init(isIncludeDisabledProviders: Bool? = nil, searchInfo: PersonLookupInfo? = nil, searchProviderName: String? = nil, itemID: UUID? = nil) {
        self.isIncludeDisabledProviders = isIncludeDisabledProviders
        self.searchInfo = searchInfo
        self.searchProviderName = searchProviderName
        self.itemID = itemID
    }

    private enum CodingKeys: String, CodingKey {
        case isIncludeDisabledProviders = "IncludeDisabledProviders"
        case searchInfo = "SearchInfo"
        case searchProviderName = "SearchProviderName"
        case itemID = "ItemId"
    }
}

public struct ImageProviderInfo: Codable {
    public var supportedImages: [ImageType]?
    public var name: String?

    public init(supportedImages: [ImageType]? = nil, name: String? = nil) {
        self.supportedImages = supportedImages
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case supportedImages = "SupportedImages"
        case name = "Name"
    }
}

public struct MediaStream: Codable {
    public var title: String?
    public var localizedForced: String?
    public var type: MediaStreamType?
    public var codecTag: String?
    public var score: Int?
    public var isDefault: Bool?
    public var language: String?
    public var level: Double?
    public var displayTitle: String?
    public var isInterlaced: Bool?
    public var isForced: Bool?
    public var width: Int?
    public var averageFrameRate: Double?
    public var timeBase: String?
    public var height: Int?
    public var sampleRate: Int?
    public var bitRate: Int?
    public var index: Int?
    public var pixelFormat: String?
    public var realFrameRate: Double?
    public var channels: Int?
    public var path: String?
    public var codecTimeBase: String?
    public var deliveryURL: String?
    public var deliveryMethod: SubtitleDeliveryMethod?
    public var comment: String?
    public var nalLengthSize: String?
    public var refFrames: Int?
    public var aspectRatio: String?
    public var isAnamorphic: Bool?
    public var colorRange: String?
    public var profile: String?
    public var isSupportsExternalStream: Bool?
    public var localizedUndefined: String?
    public var codec: String?
    public var isAVC: Bool?
    public var channelLayout: String?
    public var bitDepth: Int?
    public var isExternal: Bool?
    public var colorPrimaries: String?
    public var videoRange: String?
    public var colorSpace: String?
    public var localizedDefault: String?
    public var isExternalURL: Bool?
    public var isTextSubtitleStream: Bool?
    public var colorTransfer: String?
    public var packetLength: Int?

    public init(title: String? = nil, localizedForced: String? = nil, type: MediaStreamType? = nil, codecTag: String? = nil, score: Int? = nil, isDefault: Bool? = nil, language: String? = nil, level: Double? = nil, displayTitle: String? = nil, isInterlaced: Bool? = nil, isForced: Bool? = nil, width: Int? = nil, averageFrameRate: Double? = nil, timeBase: String? = nil, height: Int? = nil, sampleRate: Int? = nil, bitRate: Int? = nil, index: Int? = nil, pixelFormat: String? = nil, realFrameRate: Double? = nil, channels: Int? = nil, path: String? = nil, codecTimeBase: String? = nil, deliveryURL: String? = nil, deliveryMethod: SubtitleDeliveryMethod? = nil, comment: String? = nil, nalLengthSize: String? = nil, refFrames: Int? = nil, aspectRatio: String? = nil, isAnamorphic: Bool? = nil, colorRange: String? = nil, profile: String? = nil, isSupportsExternalStream: Bool? = nil, localizedUndefined: String? = nil, codec: String? = nil, isAVC: Bool? = nil, channelLayout: String? = nil, bitDepth: Int? = nil, isExternal: Bool? = nil, colorPrimaries: String? = nil, videoRange: String? = nil, colorSpace: String? = nil, localizedDefault: String? = nil, isExternalURL: Bool? = nil, isTextSubtitleStream: Bool? = nil, colorTransfer: String? = nil, packetLength: Int? = nil) {
        self.title = title
        self.localizedForced = localizedForced
        self.type = type
        self.codecTag = codecTag
        self.score = score
        self.isDefault = isDefault
        self.language = language
        self.level = level
        self.displayTitle = displayTitle
        self.isInterlaced = isInterlaced
        self.isForced = isForced
        self.width = width
        self.averageFrameRate = averageFrameRate
        self.timeBase = timeBase
        self.height = height
        self.sampleRate = sampleRate
        self.bitRate = bitRate
        self.index = index
        self.pixelFormat = pixelFormat
        self.realFrameRate = realFrameRate
        self.channels = channels
        self.path = path
        self.codecTimeBase = codecTimeBase
        self.deliveryURL = deliveryURL
        self.deliveryMethod = deliveryMethod
        self.comment = comment
        self.nalLengthSize = nalLengthSize
        self.refFrames = refFrames
        self.aspectRatio = aspectRatio
        self.isAnamorphic = isAnamorphic
        self.colorRange = colorRange
        self.profile = profile
        self.isSupportsExternalStream = isSupportsExternalStream
        self.localizedUndefined = localizedUndefined
        self.codec = codec
        self.isAVC = isAVC
        self.channelLayout = channelLayout
        self.bitDepth = bitDepth
        self.isExternal = isExternal
        self.colorPrimaries = colorPrimaries
        self.videoRange = videoRange
        self.colorSpace = colorSpace
        self.localizedDefault = localizedDefault
        self.isExternalURL = isExternalURL
        self.isTextSubtitleStream = isTextSubtitleStream
        self.colorTransfer = colorTransfer
        self.packetLength = packetLength
    }

    private enum CodingKeys: String, CodingKey {
        case title = "Title"
        case localizedForced
        case type = "Type"
        case codecTag = "CodecTag"
        case score = "Score"
        case isDefault = "IsDefault"
        case language = "Language"
        case level = "Level"
        case displayTitle = "DisplayTitle"
        case isInterlaced = "IsInterlaced"
        case isForced = "IsForced"
        case width = "Width"
        case averageFrameRate = "AverageFrameRate"
        case timeBase = "TimeBase"
        case height = "Height"
        case sampleRate = "SampleRate"
        case bitRate = "BitRate"
        case index = "Index"
        case pixelFormat = "PixelFormat"
        case realFrameRate = "RealFrameRate"
        case channels = "Channels"
        case path = "Path"
        case codecTimeBase = "CodecTimeBase"
        case deliveryURL = "DeliveryUrl"
        case deliveryMethod = "DeliveryMethod"
        case comment = "Comment"
        case nalLengthSize = "NalLengthSize"
        case refFrames = "RefFrames"
        case aspectRatio = "AspectRatio"
        case isAnamorphic = "IsAnamorphic"
        case colorRange = "ColorRange"
        case profile = "Profile"
        case isSupportsExternalStream = "SupportsExternalStream"
        case localizedUndefined
        case codec = "Codec"
        case isAVC = "IsAVC"
        case channelLayout = "ChannelLayout"
        case bitDepth = "BitDepth"
        case isExternal = "IsExternal"
        case colorPrimaries = "ColorPrimaries"
        case videoRange = "VideoRange"
        case colorSpace = "ColorSpace"
        case localizedDefault
        case isExternalURL = "IsExternalUrl"
        case isTextSubtitleStream = "IsTextSubtitleStream"
        case colorTransfer = "ColorTransfer"
        case packetLength = "PacketLength"
    }
}

public enum GroupShuffleMode: String, Codable, CaseIterable {
    case sorted = "Sorted"
    case shuffle = "Shuffle"
}

public struct ActivityLogEntry: Codable {
    public var severity: LogLevel?
    public var shortOverview: String?
    public var overview: String?
    public var userID: UUID?
    public var itemID: String?
    public var date: Date?
    public var name: String?
    public var type: String?
    public var userPrimaryImageTag: String?
    public var id: Int?

    public init(severity: LogLevel? = nil, shortOverview: String? = nil, overview: String? = nil, userID: UUID? = nil, itemID: String? = nil, date: Date? = nil, name: String? = nil, type: String? = nil, userPrimaryImageTag: String? = nil, id: Int? = nil) {
        self.severity = severity
        self.shortOverview = shortOverview
        self.overview = overview
        self.userID = userID
        self.itemID = itemID
        self.date = date
        self.name = name
        self.type = type
        self.userPrimaryImageTag = userPrimaryImageTag
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case severity = "Severity"
        case shortOverview = "ShortOverview"
        case overview = "Overview"
        case userID = "UserId"
        case itemID = "ItemId"
        case date = "Date"
        case name = "Name"
        case type = "Type"
        case userPrimaryImageTag = "UserPrimaryImageTag"
        case id = "Id"
    }
}

public struct PublicSystemInfo: Codable {
    public var serverName: String?
    public var productName: String?
    public var version: String?
    public var isStartupWizardCompleted: Bool?
    public var localAddress: String?
    public var operatingSystem: String?
    public var id: String?

    public init(serverName: String? = nil, productName: String? = nil, version: String? = nil, isStartupWizardCompleted: Bool? = nil, localAddress: String? = nil, operatingSystem: String? = nil, id: String? = nil) {
        self.serverName = serverName
        self.productName = productName
        self.version = version
        self.isStartupWizardCompleted = isStartupWizardCompleted
        self.localAddress = localAddress
        self.operatingSystem = operatingSystem
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case serverName = "ServerName"
        case productName = "ProductName"
        case version = "Version"
        case isStartupWizardCompleted = "StartupWizardCompleted"
        case localAddress = "LocalAddress"
        case operatingSystem = "OperatingSystem"
        case id = "Id"
    }
}

public struct NewGroupRequestDto: Codable {
    public var groupName: String?

    public init(groupName: String? = nil) {
        self.groupName = groupName
    }

    private enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
    }
}

public struct ParentalRating: Codable {
    public var name: String?
    public var value: Int?

    public init(name: String? = nil, value: Int? = nil) {
        self.name = name
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }
}

public enum ItemFields: String, Codable, CaseIterable {
    case airTime = "AirTime"
    case canDelete = "CanDelete"
    case canDownload = "CanDownload"
    case channelInfo = "ChannelInfo"
    case chapters = "Chapters"
    case childCount = "ChildCount"
    case cumulativeRunTimeTicks = "CumulativeRunTimeTicks"
    case customRating = "CustomRating"
    case dateCreated = "DateCreated"
    case dateLastMediaAdded = "DateLastMediaAdded"
    case displayPreferencesID = "DisplayPreferencesId"
    case etag = "Etag"
    case externalURLs = "ExternalUrls"
    case genres = "Genres"
    case homePageURL = "HomePageUrl"
    case itemCounts = "ItemCounts"
    case mediaSourceCount = "MediaSourceCount"
    case mediaSources = "MediaSources"
    case originalTitle = "OriginalTitle"
    case overview = "Overview"
    case parentID = "ParentId"
    case path = "Path"
    case people = "People"
    case playAccess = "PlayAccess"
    case productionLocations = "ProductionLocations"
    case providerIDs = "ProviderIds"
    case primaryImageAspectRatio = "PrimaryImageAspectRatio"
    case recursiveItemCount = "RecursiveItemCount"
    case settings = "Settings"
    case screenshotImageTags = "ScreenshotImageTags"
    case seriesPrimaryImage = "SeriesPrimaryImage"
    case seriesStudio = "SeriesStudio"
    case sortName = "SortName"
    case specialEpisodeNumbers = "SpecialEpisodeNumbers"
    case studios = "Studios"
    case basicSyncInfo = "BasicSyncInfo"
    case syncInfo = "SyncInfo"
    case taglines = "Taglines"
    case tags = "Tags"
    case remoteTrailers = "RemoteTrailers"
    case mediaStreams = "MediaStreams"
    case seasonUserData = "SeasonUserData"
    case serviceName = "ServiceName"
    case themeSongIDs = "ThemeSongIds"
    case themeVideoIDs = "ThemeVideoIds"
    case externalEtag = "ExternalEtag"
    case presentationUniqueKey = "PresentationUniqueKey"
    case inheritedParentalRatingValue = "InheritedParentalRatingValue"
    case externalSeriesID = "ExternalSeriesId"
    case seriesPresentationUniqueKey = "SeriesPresentationUniqueKey"
    case dateLastRefreshed = "DateLastRefreshed"
    case dateLastSaved = "DateLastSaved"
    case refreshState = "RefreshState"
    case channelImage = "ChannelImage"
    case enableMediaSourceDisplay = "EnableMediaSourceDisplay"
    case width = "Width"
    case height = "Height"
    case extraIDs = "ExtraIds"
    case localTrailerCount = "LocalTrailerCount"
    case isHD = "IsHD"
    case specialFeatureCount = "SpecialFeatureCount"
}

public enum UnratedItem: String, Codable, CaseIterable {
    case movie = "Movie"
    case trailer = "Trailer"
    case series = "Series"
    case music = "Music"
    case book = "Book"
    case liveTvChannel = "LiveTvChannel"
    case liveTvProgram = "LiveTvProgram"
    case channelContent = "ChannelContent"
    case other = "Other"
}

public enum TransportStreamTimestamp: String, Codable, CaseIterable {
    case `none` = "None"
    case zero = "Zero"
    case valid = "Valid"
}

public struct MusicVideoInfo: Codable {
    public var parentIndexNumber: Int?
    public var indexNumber: Int?
    public var name: String?
    public var metadataLanguage: String?
    public var metadataCountryCode: String?
    public var artists: [String]?
    public var providerIDs: [String: String]?
    public var isAutomated: Bool?
    public var premiereDate: Date?
    public var year: Int?
    public var path: String?

    public init(parentIndexNumber: Int? = nil, indexNumber: Int? = nil, name: String? = nil, metadataLanguage: String? = nil, metadataCountryCode: String? = nil, artists: [String]? = nil, providerIDs: [String: String]? = nil, isAutomated: Bool? = nil, premiereDate: Date? = nil, year: Int? = nil, path: String? = nil) {
        self.parentIndexNumber = parentIndexNumber
        self.indexNumber = indexNumber
        self.name = name
        self.metadataLanguage = metadataLanguage
        self.metadataCountryCode = metadataCountryCode
        self.artists = artists
        self.providerIDs = providerIDs
        self.isAutomated = isAutomated
        self.premiereDate = premiereDate
        self.year = year
        self.path = path
    }

    private enum CodingKeys: String, CodingKey {
        case parentIndexNumber = "ParentIndexNumber"
        case indexNumber = "IndexNumber"
        case name = "Name"
        case metadataLanguage = "MetadataLanguage"
        case metadataCountryCode = "MetadataCountryCode"
        case artists = "Artists"
        case providerIDs = "ProviderIds"
        case isAutomated = "IsAutomated"
        case premiereDate = "PremiereDate"
        case year = "Year"
        case path = "Path"
    }
}

public enum ScrollDirection: String, Codable, CaseIterable {
    case horizontal = "Horizontal"
    case vertical = "Vertical"
}

public struct LibraryOptions: Codable {
    public var disabledSubtitleFetchers: [String]?
    public var metadataSavers: [String]?
    public var seasonZeroDisplayName: String?
    public var subtitleDownloadLanguages: [String]?
    public var enableEmbeddedTitles: Bool?
    public var metadataCountryCode: String?
    public var isSkipSubtitlesIfEmbeddedSubtitlesPresent: Bool?
    public var enableAutomaticSeriesGrouping: Bool?
    public var isSaveLocalMetadata: Bool?
    public var enablePhotos: Bool?
    public var typeOptions: [TypeOptions]?
    public var isExtractChapterImagesDuringLibraryScan: Bool?
    public var subtitleFetcherOrder: [String]?
    public var enableRealtimeMonitor: Bool?
    public var requirePerfectSubtitleMatch: Bool?
    public var isSaveSubtitlesWithMedia: Bool?
    public var pathInfos: [MediaPathInfo]?
    public var enableInternetProviders: Bool?
    public var enableEmbeddedEpisodeInfos: Bool?
    public var isSkipSubtitlesIfAudioTrackMatches: Bool?
    public var localMetadataReaderOrder: [String]?
    public var disabledLocalMetadataReaders: [String]?
    public var enableChapterImageExtraction: Bool?
    public var automaticRefreshIntervalDays: Int?
    public var preferredMetadataLanguage: String?

    public init(disabledSubtitleFetchers: [String]? = nil, metadataSavers: [String]? = nil, seasonZeroDisplayName: String? = nil, subtitleDownloadLanguages: [String]? = nil, enableEmbeddedTitles: Bool? = nil, metadataCountryCode: String? = nil, isSkipSubtitlesIfEmbeddedSubtitlesPresent: Bool? = nil, enableAutomaticSeriesGrouping: Bool? = nil, isSaveLocalMetadata: Bool? = nil, enablePhotos: Bool? = nil, typeOptions: [TypeOptions]? = nil, isExtractChapterImagesDuringLibraryScan: Bool? = nil, subtitleFetcherOrder: [String]? = nil, enableRealtimeMonitor: Bool? = nil, requirePerfectSubtitleMatch: Bool? = nil, isSaveSubtitlesWithMedia: Bool? = nil, pathInfos: [MediaPathInfo]? = nil, enableInternetProviders: Bool? = nil, enableEmbeddedEpisodeInfos: Bool? = nil, isSkipSubtitlesIfAudioTrackMatches: Bool? = nil, localMetadataReaderOrder: [String]? = nil, disabledLocalMetadataReaders: [String]? = nil, enableChapterImageExtraction: Bool? = nil, automaticRefreshIntervalDays: Int? = nil, preferredMetadataLanguage: String? = nil) {
        self.disabledSubtitleFetchers = disabledSubtitleFetchers
        self.metadataSavers = metadataSavers
        self.seasonZeroDisplayName = seasonZeroDisplayName
        self.subtitleDownloadLanguages = subtitleDownloadLanguages
        self.enableEmbeddedTitles = enableEmbeddedTitles
        self.metadataCountryCode = metadataCountryCode
        self.isSkipSubtitlesIfEmbeddedSubtitlesPresent = isSkipSubtitlesIfEmbeddedSubtitlesPresent
        self.enableAutomaticSeriesGrouping = enableAutomaticSeriesGrouping
        self.isSaveLocalMetadata = isSaveLocalMetadata
        self.enablePhotos = enablePhotos
        self.typeOptions = typeOptions
        self.isExtractChapterImagesDuringLibraryScan = isExtractChapterImagesDuringLibraryScan
        self.subtitleFetcherOrder = subtitleFetcherOrder
        self.enableRealtimeMonitor = enableRealtimeMonitor
        self.requirePerfectSubtitleMatch = requirePerfectSubtitleMatch
        self.isSaveSubtitlesWithMedia = isSaveSubtitlesWithMedia
        self.pathInfos = pathInfos
        self.enableInternetProviders = enableInternetProviders
        self.enableEmbeddedEpisodeInfos = enableEmbeddedEpisodeInfos
        self.isSkipSubtitlesIfAudioTrackMatches = isSkipSubtitlesIfAudioTrackMatches
        self.localMetadataReaderOrder = localMetadataReaderOrder
        self.disabledLocalMetadataReaders = disabledLocalMetadataReaders
        self.enableChapterImageExtraction = enableChapterImageExtraction
        self.automaticRefreshIntervalDays = automaticRefreshIntervalDays
        self.preferredMetadataLanguage = preferredMetadataLanguage
    }

    private enum CodingKeys: String, CodingKey {
        case disabledSubtitleFetchers = "DisabledSubtitleFetchers"
        case metadataSavers = "MetadataSavers"
        case seasonZeroDisplayName = "SeasonZeroDisplayName"
        case subtitleDownloadLanguages = "SubtitleDownloadLanguages"
        case enableEmbeddedTitles = "EnableEmbeddedTitles"
        case metadataCountryCode = "MetadataCountryCode"
        case isSkipSubtitlesIfEmbeddedSubtitlesPresent = "SkipSubtitlesIfEmbeddedSubtitlesPresent"
        case enableAutomaticSeriesGrouping = "EnableAutomaticSeriesGrouping"
        case isSaveLocalMetadata = "SaveLocalMetadata"
        case enablePhotos = "EnablePhotos"
        case typeOptions = "TypeOptions"
        case isExtractChapterImagesDuringLibraryScan = "ExtractChapterImagesDuringLibraryScan"
        case subtitleFetcherOrder = "SubtitleFetcherOrder"
        case enableRealtimeMonitor = "EnableRealtimeMonitor"
        case requirePerfectSubtitleMatch = "RequirePerfectSubtitleMatch"
        case isSaveSubtitlesWithMedia = "SaveSubtitlesWithMedia"
        case pathInfos = "PathInfos"
        case enableInternetProviders = "EnableInternetProviders"
        case enableEmbeddedEpisodeInfos = "EnableEmbeddedEpisodeInfos"
        case isSkipSubtitlesIfAudioTrackMatches = "SkipSubtitlesIfAudioTrackMatches"
        case localMetadataReaderOrder = "LocalMetadataReaderOrder"
        case disabledLocalMetadataReaders = "DisabledLocalMetadataReaders"
        case enableChapterImageExtraction = "EnableChapterImageExtraction"
        case automaticRefreshIntervalDays = "AutomaticRefreshIntervalDays"
        case preferredMetadataLanguage = "PreferredMetadataLanguage"
    }
}

public struct BaseItem: Codable {
    public var shortcutPath: String?
    public var height: Int?
    public var remoteTrailers: [MediaURL]?
    public var width: Int?
    public var extraIDs: [UUID]?
    public var size: Int?
    public var dateLastSaved: Date?
    public var container: String?
    public var isShortcut: Bool?
    public var isHD: Bool?
    public var isSupportsExternalTransfer: Bool?

    public init(shortcutPath: String? = nil, height: Int? = nil, remoteTrailers: [MediaURL]? = nil, width: Int? = nil, extraIDs: [UUID]? = nil, size: Int? = nil, dateLastSaved: Date? = nil, container: String? = nil, isShortcut: Bool? = nil, isHD: Bool? = nil, isSupportsExternalTransfer: Bool? = nil) {
        self.shortcutPath = shortcutPath
        self.height = height
        self.remoteTrailers = remoteTrailers
        self.width = width
        self.extraIDs = extraIDs
        self.size = size
        self.dateLastSaved = dateLastSaved
        self.container = container
        self.isShortcut = isShortcut
        self.isHD = isHD
        self.isSupportsExternalTransfer = isSupportsExternalTransfer
    }

    private enum CodingKeys: String, CodingKey {
        case shortcutPath = "ShortcutPath"
        case height = "Height"
        case remoteTrailers = "RemoteTrailers"
        case width = "Width"
        case extraIDs = "ExtraIds"
        case size = "Size"
        case dateLastSaved = "DateLastSaved"
        case container = "Container"
        case isShortcut = "IsShortcut"
        case isHD = "IsHD"
        case isSupportsExternalTransfer = "SupportsExternalTransfer"
    }
}

public struct AuthenticationResult: Codable {
    public var sessionInfo: SessionInfo?
    public var user: UserDto?
    public var serverID: String?
    public var accessToken: String?

    public init(sessionInfo: SessionInfo? = nil, user: UserDto? = nil, serverID: String? = nil, accessToken: String? = nil) {
        self.sessionInfo = sessionInfo
        self.user = user
        self.serverID = serverID
        self.accessToken = accessToken
    }

    private enum CodingKeys: String, CodingKey {
        case sessionInfo = "SessionInfo"
        case user = "User"
        case serverID = "ServerId"
        case accessToken = "AccessToken"
    }
}

public enum ImageOrientation: String, Codable, CaseIterable {
    case topLeft = "TopLeft"
    case topRight = "TopRight"
    case bottomRight = "BottomRight"
    case bottomLeft = "BottomLeft"
    case leftTop = "LeftTop"
    case rightTop = "RightTop"
    case rightBottom = "RightBottom"
    case leftBottom = "LeftBottom"
}

public enum SessionMessageType: String, Codable, CaseIterable {
    case forceKeepAlive = "ForceKeepAlive"
    case generalCommand = "GeneralCommand"
    case userDataChanged = "UserDataChanged"
    case sessions = "Sessions"
    case play = "Play"
    case syncPlayCommand = "SyncPlayCommand"
    case syncPlayGroupUpdate = "SyncPlayGroupUpdate"
    case playstate = "Playstate"
    case restartRequired = "RestartRequired"
    case serverShuttingDown = "ServerShuttingDown"
    case serverRestarting = "ServerRestarting"
    case libraryChanged = "LibraryChanged"
    case userDeleted = "UserDeleted"
    case userUpdated = "UserUpdated"
    case seriesTimerCreated = "SeriesTimerCreated"
    case timerCreated = "TimerCreated"
    case seriesTimerCancelled = "SeriesTimerCancelled"
    case timerCancelled = "TimerCancelled"
    case refreshProgress = "RefreshProgress"
    case scheduledTaskEnded = "ScheduledTaskEnded"
    case packageInstallationCancelled = "PackageInstallationCancelled"
    case packageInstallationFailed = "PackageInstallationFailed"
    case packageInstallationCompleted = "PackageInstallationCompleted"
    case packageInstalling = "PackageInstalling"
    case packageUninstalled = "PackageUninstalled"
    case activityLogEntry = "ActivityLogEntry"
    case scheduledTasksInfo = "ScheduledTasksInfo"
    case activityLogEntryStart = "ActivityLogEntryStart"
    case activityLogEntryStop = "ActivityLogEntryStop"
    case sessionsStart = "SessionsStart"
    case sessionsStop = "SessionsStop"
    case scheduledTasksInfoStart = "ScheduledTasksInfoStart"
    case scheduledTasksInfoStop = "ScheduledTasksInfoStop"
    case keepAlive = "KeepAlive"
}

public struct AddVirtualFolderDto: Codable {
    public var libraryOptions: LibraryOptions?

    public init(libraryOptions: LibraryOptions? = nil) {
        self.libraryOptions = libraryOptions
    }

    private enum CodingKeys: String, CodingKey {
        case libraryOptions = "LibraryOptions"
    }
}

public struct HTTPHeaderInfo: Codable {
    public var match: HeaderMatchType?
    public var value: String?
    public var name: String?

    public init(match: HeaderMatchType? = nil, value: String? = nil, name: String? = nil) {
        self.match = match
        self.value = value
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case match = "Match"
        case value = "Value"
        case name = "Name"
    }
}

public struct DeviceInfo: Codable {
    public var lastUserName: String?
    public var lastUserID: UUID?
    public var dateLastActivity: Date?
    public var capabilities: ClientCapabilities?
    public var id: String?
    public var name: String?
    public var appVersion: String?
    public var appName: String?
    public var iconURL: String?

    public init(lastUserName: String? = nil, lastUserID: UUID? = nil, dateLastActivity: Date? = nil, capabilities: ClientCapabilities? = nil, id: String? = nil, name: String? = nil, appVersion: String? = nil, appName: String? = nil, iconURL: String? = nil) {
        self.lastUserName = lastUserName
        self.lastUserID = lastUserID
        self.dateLastActivity = dateLastActivity
        self.capabilities = capabilities
        self.id = id
        self.name = name
        self.appVersion = appVersion
        self.appName = appName
        self.iconURL = iconURL
    }

    private enum CodingKeys: String, CodingKey {
        case lastUserName = "LastUserName"
        case lastUserID = "LastUserId"
        case dateLastActivity = "DateLastActivity"
        case capabilities = "Capabilities"
        case id = "Id"
        case name = "Name"
        case appVersion = "AppVersion"
        case appName = "AppName"
        case iconURL = "IconUrl"
    }
}

public enum ProfileConditionValue: String, Codable, CaseIterable {
    case audioChannels = "AudioChannels"
    case audioBitrate = "AudioBitrate"
    case audioProfile = "AudioProfile"
    case width = "Width"
    case height = "Height"
    case has64BitOffsets = "Has64BitOffsets"
    case packetLength = "PacketLength"
    case videoBitDepth = "VideoBitDepth"
    case videoBitrate = "VideoBitrate"
    case videoFramerate = "VideoFramerate"
    case videoLevel = "VideoLevel"
    case videoProfile = "VideoProfile"
    case videoTimestamp = "VideoTimestamp"
    case isAnamorphic = "IsAnamorphic"
    case refFrames = "RefFrames"
    case numAudioStreams = "NumAudioStreams"
    case numVideoStreams = "NumVideoStreams"
    case isSecondaryAudio = "IsSecondaryAudio"
    case videoCodecTag = "VideoCodecTag"
    case isAvc = "IsAvc"
    case isInterlaced = "IsInterlaced"
    case audioSampleRate = "AudioSampleRate"
    case audioBitDepth = "AudioBitDepth"
}

public struct DeviceIdentification: Codable {
    public var modelDescription: String?
    public var modelNumber: String?
    public var modelName: String?
    public var modelURL: String?
    public var serialNumber: String?
    public var manufacturer: String?
    public var headers: [HTTPHeaderInfo]?
    public var friendlyName: String?
    public var manufacturerURL: String?

    public init(modelDescription: String? = nil, modelNumber: String? = nil, modelName: String? = nil, modelURL: String? = nil, serialNumber: String? = nil, manufacturer: String? = nil, headers: [HTTPHeaderInfo]? = nil, friendlyName: String? = nil, manufacturerURL: String? = nil) {
        self.modelDescription = modelDescription
        self.modelNumber = modelNumber
        self.modelName = modelName
        self.modelURL = modelURL
        self.serialNumber = serialNumber
        self.manufacturer = manufacturer
        self.headers = headers
        self.friendlyName = friendlyName
        self.manufacturerURL = manufacturerURL
    }

    private enum CodingKeys: String, CodingKey {
        case modelDescription = "ModelDescription"
        case modelNumber = "ModelNumber"
        case modelName = "ModelName"
        case modelURL = "ModelUrl"
        case serialNumber = "SerialNumber"
        case manufacturer = "Manufacturer"
        case headers = "Headers"
        case friendlyName = "FriendlyName"
        case manufacturerURL = "ManufacturerUrl"
    }
}

public struct ForgotPasswordPinDto: Codable {
    public var pin: String

    public init(pin: String) {
        self.pin = pin
    }

    private enum CodingKeys: String, CodingKey {
        case pin = "Pin"
    }
}

public struct BookInfo: Codable {
    public var indexNumber: Int?
    public var parentIndexNumber: Int?
    public var seriesName: String?
    public var providerIDs: [String: String]?
    public var year: Int?
    public var metadataLanguage: String?
    public var path: String?
    public var isAutomated: Bool?
    public var metadataCountryCode: String?
    public var name: String?
    public var premiereDate: Date?

    public init(indexNumber: Int? = nil, parentIndexNumber: Int? = nil, seriesName: String? = nil, providerIDs: [String: String]? = nil, year: Int? = nil, metadataLanguage: String? = nil, path: String? = nil, isAutomated: Bool? = nil, metadataCountryCode: String? = nil, name: String? = nil, premiereDate: Date? = nil) {
        self.indexNumber = indexNumber
        self.parentIndexNumber = parentIndexNumber
        self.seriesName = seriesName
        self.providerIDs = providerIDs
        self.year = year
        self.metadataLanguage = metadataLanguage
        self.path = path
        self.isAutomated = isAutomated
        self.metadataCountryCode = metadataCountryCode
        self.name = name
        self.premiereDate = premiereDate
    }

    private enum CodingKeys: String, CodingKey {
        case indexNumber = "IndexNumber"
        case parentIndexNumber = "ParentIndexNumber"
        case seriesName = "SeriesName"
        case providerIDs = "ProviderIds"
        case year = "Year"
        case metadataLanguage = "MetadataLanguage"
        case path = "Path"
        case isAutomated = "IsAutomated"
        case metadataCountryCode = "MetadataCountryCode"
        case name = "Name"
        case premiereDate = "PremiereDate"
    }
}

public enum ChannelType: String, Codable, CaseIterable {
    case tv = "TV"
    case radio = "Radio"
}

public enum GroupQueueMode: String, Codable, CaseIterable {
    case queue = "Queue"
    case queueNext = "QueueNext"
}

public struct DeviceProfile: Codable {
    public var isIgnoreTranscodeByteRangeRequests: Bool?
    public var requiresPlainFolders: Bool?
    public var containerProfiles: [ContainerProfile]?
    public var enableSingleAlbumArtLimit: Bool?
    public var id: String?
    public var supportedMediaTypes: String?
    public var modelNumber: String?
    public var manufacturer: String?
    public var albumArtPn: String?
    public var responseProfiles: [ResponseProfile]?
    public var enableSingleSubtitleLimit: Bool?
    public var musicStreamingTranscodingBitrate: Int?
    public var modelURL: String?
    public var maxAlbumArtHeight: Int?
    public var timelineOffsetSeconds: Int?
    public var protocolInfo: String?
    public var subtitleProfiles: [SubtitleProfile]?
    public var sonyAggregationFlags: String?
    public var requiresPlainVideoItems: Bool?
    public var modelDescription: String?
    public var enableMSMediaReceiverRegistrar: Bool?
    public var friendlyName: String?
    public var manufacturerURL: String?
    public var directPlayProfiles: [DirectPlayProfile]?
    public var transcodingProfiles: [TranscodingProfile]?
    public var maxStreamingBitrate: Int?
    public var maxIconWidth: Int?
    public var xmlRootAttributes: [XmlAttribute]?
    public var identification: DeviceIdentification?
    public var maxIconHeight: Int?
    public var name: String?
    public var serialNumber: String?
    public var enableAlbumArtInDidl: Bool?
    public var maxStaticBitrate: Int?
    public var modelName: String?
    public var maxStaticMusicBitrate: Int?
    public var userID: String?
    public var maxAlbumArtWidth: Int?
    public var codecProfiles: [CodecProfile]?

    public init(isIgnoreTranscodeByteRangeRequests: Bool? = nil, requiresPlainFolders: Bool? = nil, containerProfiles: [ContainerProfile]? = nil, enableSingleAlbumArtLimit: Bool? = nil, id: String? = nil, supportedMediaTypes: String? = nil, modelNumber: String? = nil, manufacturer: String? = nil, albumArtPn: String? = nil, responseProfiles: [ResponseProfile]? = nil, enableSingleSubtitleLimit: Bool? = nil, musicStreamingTranscodingBitrate: Int? = nil, modelURL: String? = nil, maxAlbumArtHeight: Int? = nil, timelineOffsetSeconds: Int? = nil, protocolInfo: String? = nil, subtitleProfiles: [SubtitleProfile]? = nil, sonyAggregationFlags: String? = nil, requiresPlainVideoItems: Bool? = nil, modelDescription: String? = nil, enableMSMediaReceiverRegistrar: Bool? = nil, friendlyName: String? = nil, manufacturerURL: String? = nil, directPlayProfiles: [DirectPlayProfile]? = nil, transcodingProfiles: [TranscodingProfile]? = nil, maxStreamingBitrate: Int? = nil, maxIconWidth: Int? = nil, xmlRootAttributes: [XmlAttribute]? = nil, identification: DeviceIdentification? = nil, maxIconHeight: Int? = nil, name: String? = nil, serialNumber: String? = nil, enableAlbumArtInDidl: Bool? = nil, maxStaticBitrate: Int? = nil, modelName: String? = nil, maxStaticMusicBitrate: Int? = nil, userID: String? = nil, maxAlbumArtWidth: Int? = nil, codecProfiles: [CodecProfile]? = nil) {
        self.isIgnoreTranscodeByteRangeRequests = isIgnoreTranscodeByteRangeRequests
        self.requiresPlainFolders = requiresPlainFolders
        self.containerProfiles = containerProfiles
        self.enableSingleAlbumArtLimit = enableSingleAlbumArtLimit
        self.id = id
        self.supportedMediaTypes = supportedMediaTypes
        self.modelNumber = modelNumber
        self.manufacturer = manufacturer
        self.albumArtPn = albumArtPn
        self.responseProfiles = responseProfiles
        self.enableSingleSubtitleLimit = enableSingleSubtitleLimit
        self.musicStreamingTranscodingBitrate = musicStreamingTranscodingBitrate
        self.modelURL = modelURL
        self.maxAlbumArtHeight = maxAlbumArtHeight
        self.timelineOffsetSeconds = timelineOffsetSeconds
        self.protocolInfo = protocolInfo
        self.subtitleProfiles = subtitleProfiles
        self.sonyAggregationFlags = sonyAggregationFlags
        self.requiresPlainVideoItems = requiresPlainVideoItems
        self.modelDescription = modelDescription
        self.enableMSMediaReceiverRegistrar = enableMSMediaReceiverRegistrar
        self.friendlyName = friendlyName
        self.manufacturerURL = manufacturerURL
        self.directPlayProfiles = directPlayProfiles
        self.transcodingProfiles = transcodingProfiles
        self.maxStreamingBitrate = maxStreamingBitrate
        self.maxIconWidth = maxIconWidth
        self.xmlRootAttributes = xmlRootAttributes
        self.identification = identification
        self.maxIconHeight = maxIconHeight
        self.name = name
        self.serialNumber = serialNumber
        self.enableAlbumArtInDidl = enableAlbumArtInDidl
        self.maxStaticBitrate = maxStaticBitrate
        self.modelName = modelName
        self.maxStaticMusicBitrate = maxStaticMusicBitrate
        self.userID = userID
        self.maxAlbumArtWidth = maxAlbumArtWidth
        self.codecProfiles = codecProfiles
    }

    private enum CodingKeys: String, CodingKey {
        case isIgnoreTranscodeByteRangeRequests = "IgnoreTranscodeByteRangeRequests"
        case requiresPlainFolders = "RequiresPlainFolders"
        case containerProfiles = "ContainerProfiles"
        case enableSingleAlbumArtLimit = "EnableSingleAlbumArtLimit"
        case id = "Id"
        case supportedMediaTypes = "SupportedMediaTypes"
        case modelNumber = "ModelNumber"
        case manufacturer = "Manufacturer"
        case albumArtPn = "AlbumArtPn"
        case responseProfiles = "ResponseProfiles"
        case enableSingleSubtitleLimit = "EnableSingleSubtitleLimit"
        case musicStreamingTranscodingBitrate = "MusicStreamingTranscodingBitrate"
        case modelURL = "ModelUrl"
        case maxAlbumArtHeight = "MaxAlbumArtHeight"
        case timelineOffsetSeconds = "TimelineOffsetSeconds"
        case protocolInfo = "ProtocolInfo"
        case subtitleProfiles = "SubtitleProfiles"
        case sonyAggregationFlags = "SonyAggregationFlags"
        case requiresPlainVideoItems = "RequiresPlainVideoItems"
        case modelDescription = "ModelDescription"
        case enableMSMediaReceiverRegistrar = "EnableMSMediaReceiverRegistrar"
        case friendlyName = "FriendlyName"
        case manufacturerURL = "ManufacturerUrl"
        case directPlayProfiles = "DirectPlayProfiles"
        case transcodingProfiles = "TranscodingProfiles"
        case maxStreamingBitrate = "MaxStreamingBitrate"
        case maxIconWidth = "MaxIconWidth"
        case xmlRootAttributes = "XmlRootAttributes"
        case identification = "Identification"
        case maxIconHeight = "MaxIconHeight"
        case name = "Name"
        case serialNumber = "SerialNumber"
        case enableAlbumArtInDidl = "EnableAlbumArtInDidl"
        case maxStaticBitrate = "MaxStaticBitrate"
        case modelName = "ModelName"
        case maxStaticMusicBitrate = "MaxStaticMusicBitrate"
        case userID = "UserId"
        case maxAlbumArtWidth = "MaxAlbumArtWidth"
        case codecProfiles = "CodecProfiles"
    }
}

public final class BaseItemDto: Codable {
    public let parentBackdropImageTags: [String]?
    public let path: String?
    public let shutterSpeed: Double?
    public let isLive: Bool?
    public let isPremiere: Bool?
    public let runTimeTicks: Int?
    public let timerID: String?
    public let aspectRatio: String?
    public let dateLastMediaAdded: Date?
    public let lockData: Bool?
    public let displayPreferencesID: String?
    public let channelPrimaryImageTag: String?
    public let isSports: Bool?
    public let channelNumber: String?
    public let musicVideoCount: Int?
    public let preferredMetadataCountryCode: String?
    public let seasonID: UUID?
    public let people: [BaseItemPerson]?
    public let airTime: String?
    public let canDelete: Bool?
    public let channelType: ChannelType?
    public let video3DFormat: Video3DFormat?
    public let indexNumber: Int?
    public let trailerCount: Int?
    public let mediaType: String?
    public let channelID: UUID?
    public let airDays: [DayOfWeek]?
    public let studios: [NameGuidPair]?
    public let seasonName: String?
    public let airsBeforeSeasonNumber: Int?
    public let longitude: Double?
    public let cumulativeRunTimeTicks: Int?
    public let status: String?
    public let seriesCount: Int?
    public let providerIDs: [String: String]?
    public let localTrailerCount: Int?
    public let productionYear: Int?
    public let serverID: String?
    public let locationType: LocationType?
    public let name: String?
    public let artistItems: [NameGuidPair]?
    public let parentThumbItemID: String?
    public let sortName: String?
    public let playlistItemID: String?
    public let remoteTrailers: [MediaURL]?
    public let productionLocations: [String]?
    public let dateCreated: Date?
    public let parentArtImageTag: String?
    public let songCount: Int?
    public let communityRating: Double?
    public let primaryImageAspectRatio: Double?
    public let mediaSources: [MediaSourceInfo]?
    public let chapters: [ChapterInfo]?
    public let partCount: Int?
    public let criticRating: Double?
    public let recursiveItemCount: Int?
    public let imageBlurHashes: ImageBlurHashes?
    public let collectionType: String?
    public let altitude: Double?
    public let id: UUID?
    public let parentPrimaryImageTag: String?
    public let episodeCount: Int?
    public let albumArtists: [NameGuidPair]?
    public let parentBackdropItemID: String?
    public let latitude: Double?
    public let taglines: [String]?
    public let seriesID: UUID?
    public let width: Int?
    public let customRating: String?
    public let cameraMake: String?
    public let seriesThumbImageTag: String?
    public let isoType: IsoType?
    public let album: String?
    public let focalLength: Double?
    public let parentID: UUID?
    public let artists: [String]?
    public let audio: ProgramAudio?
    public let completionPercentage: Double?
    public let preferredMetadataLanguage: String?
    public let cameraModel: String?
    public let parentArtItemID: String?
    public let childCount: Int?
    public let videoType: VideoType?
    public let userData: UserItemDataDto?
    public let endDate: Date?
    public let backdropImageTags: [String]?
    public let screenshotImageTags: [String]?
    public let software: String?
    public let number: String?
    public let parentIndexNumber: Int?
    public let originalTitle: String?
    public let seriesTimerID: String?
    public let isNews: Bool?
    public let canDownload: Bool?
    public let etag: String?
    public let hasSubtitles: Bool?
    public let isSeries: Bool?
    public let parentLogoItemID: String?
    public let forcedSortName: String?
    public let programID: String?
    public let tags: [String]?
    public let seriesPrimaryImageTag: String?
    public let airsAfterSeasonNumber: Int?
    public let isRepeat: Bool?
    public let officialRating: String?
    public let isKids: Bool?
    public let height: Int?
    public let albumID: UUID?
    public let mediaStreams: [MediaStream]?
    public let playAccess: PlayAccess?
    public let lockedFields: [MetadataField]?
    public let parentPrimaryImageItemID: String?
    public let isMovie: Bool?
    public let programCount: Int?
    public let container: String?
    public let seriesStudio: String?
    public let displayOrder: String?
    public let parentThumbImageTag: String?
    public let imageTags: [String: String]?
    public let startDate: Date?
    public let genres: [String]?
    public let externalURLs: [ExternalURL]?
    public let isSupportsSync: Bool?
    public let artistCount: Int?
    public let enableMediaSourceDisplay: Bool?
    public let isHD: Bool?
    public let specialFeatureCount: Int?
    public let aperture: Double?
    public let albumPrimaryImageTag: String?
    public let genreItems: [NameGuidPair]?
    public let isFolder: Bool?
    public let overview: String?
    public let parentLogoImageTag: String?
    public let airsBeforeEpisodeNumber: Int?
    public let albumArtist: String?
    public let channelName: String?
    public let exposureTime: Double?
    public let indexNumberEnd: Int?
    public let albumCount: Int?
    public let seriesName: String?
    public let premiereDate: Date?
    public let movieCount: Int?
    public let sourceType: String?
    public let episodeTitle: String?
    public let extraType: String?
    public let mediaSourceCount: Int?
    public let imageOrientation: ImageOrientation?
    public let isPlaceHolder: Bool?
    public let type: String?
    public let isoSpeedRating: Int?
    public let currentProgram: BaseItemDto?

    public struct ImageBlurHashes: Codable {
        public var chapter: [String: String]?
        public var boxRear: [String: String]?
        public var menu: [String: String]?
        public var banner: [String: String]?
        public var art: [String: String]?
        public var screenshot: [String: String]?
        public var logo: [String: String]?
        public var backdrop: [String: String]?
        public var thumb: [String: String]?
        public var disc: [String: String]?
        public var box: [String: String]?
        public var profile: [String: String]?
        public var primary: [String: String]?

        public init(chapter: [String: String]? = nil, boxRear: [String: String]? = nil, menu: [String: String]? = nil, banner: [String: String]? = nil, art: [String: String]? = nil, screenshot: [String: String]? = nil, logo: [String: String]? = nil, backdrop: [String: String]? = nil, thumb: [String: String]? = nil, disc: [String: String]? = nil, box: [String: String]? = nil, profile: [String: String]? = nil, primary: [String: String]? = nil) {
            self.chapter = chapter
            self.boxRear = boxRear
            self.menu = menu
            self.banner = banner
            self.art = art
            self.screenshot = screenshot
            self.logo = logo
            self.backdrop = backdrop
            self.thumb = thumb
            self.disc = disc
            self.box = box
            self.profile = profile
            self.primary = primary
        }

        private enum CodingKeys: String, CodingKey {
            case chapter = "Chapter"
            case boxRear = "BoxRear"
            case menu = "Menu"
            case banner = "Banner"
            case art = "Art"
            case screenshot = "Screenshot"
            case logo = "Logo"
            case backdrop = "Backdrop"
            case thumb = "Thumb"
            case disc = "Disc"
            case box = "Box"
            case profile = "Profile"
            case primary = "Primary"
        }
    }

    public init(parentBackdropImageTags: [String]? = nil, path: String? = nil, shutterSpeed: Double? = nil, isLive: Bool? = nil, isPremiere: Bool? = nil, runTimeTicks: Int? = nil, timerID: String? = nil, aspectRatio: String? = nil, dateLastMediaAdded: Date? = nil, lockData: Bool? = nil, displayPreferencesID: String? = nil, channelPrimaryImageTag: String? = nil, isSports: Bool? = nil, channelNumber: String? = nil, musicVideoCount: Int? = nil, preferredMetadataCountryCode: String? = nil, seasonID: UUID? = nil, people: [BaseItemPerson]? = nil, airTime: String? = nil, canDelete: Bool? = nil, channelType: ChannelType? = nil, video3DFormat: Video3DFormat? = nil, indexNumber: Int? = nil, trailerCount: Int? = nil, mediaType: String? = nil, channelID: UUID? = nil, airDays: [DayOfWeek]? = nil, studios: [NameGuidPair]? = nil, seasonName: String? = nil, airsBeforeSeasonNumber: Int? = nil, longitude: Double? = nil, cumulativeRunTimeTicks: Int? = nil, status: String? = nil, seriesCount: Int? = nil, providerIDs: [String: String]? = nil, localTrailerCount: Int? = nil, productionYear: Int? = nil, serverID: String? = nil, locationType: LocationType? = nil, name: String? = nil, artistItems: [NameGuidPair]? = nil, parentThumbItemID: String? = nil, sortName: String? = nil, playlistItemID: String? = nil, remoteTrailers: [MediaURL]? = nil, productionLocations: [String]? = nil, dateCreated: Date? = nil, parentArtImageTag: String? = nil, songCount: Int? = nil, communityRating: Double? = nil, primaryImageAspectRatio: Double? = nil, mediaSources: [MediaSourceInfo]? = nil, chapters: [ChapterInfo]? = nil, partCount: Int? = nil, criticRating: Double? = nil, recursiveItemCount: Int? = nil, imageBlurHashes: ImageBlurHashes? = nil, collectionType: String? = nil, altitude: Double? = nil, id: UUID? = nil, parentPrimaryImageTag: String? = nil, episodeCount: Int? = nil, albumArtists: [NameGuidPair]? = nil, parentBackdropItemID: String? = nil, latitude: Double? = nil, taglines: [String]? = nil, seriesID: UUID? = nil, width: Int? = nil, customRating: String? = nil, cameraMake: String? = nil, seriesThumbImageTag: String? = nil, isoType: IsoType? = nil, album: String? = nil, focalLength: Double? = nil, parentID: UUID? = nil, artists: [String]? = nil, audio: ProgramAudio? = nil, completionPercentage: Double? = nil, preferredMetadataLanguage: String? = nil, cameraModel: String? = nil, parentArtItemID: String? = nil, childCount: Int? = nil, videoType: VideoType? = nil, userData: UserItemDataDto? = nil, endDate: Date? = nil, backdropImageTags: [String]? = nil, screenshotImageTags: [String]? = nil, software: String? = nil, number: String? = nil, parentIndexNumber: Int? = nil, originalTitle: String? = nil, seriesTimerID: String? = nil, isNews: Bool? = nil, canDownload: Bool? = nil, etag: String? = nil, hasSubtitles: Bool? = nil, isSeries: Bool? = nil, parentLogoItemID: String? = nil, forcedSortName: String? = nil, programID: String? = nil, tags: [String]? = nil, seriesPrimaryImageTag: String? = nil, airsAfterSeasonNumber: Int? = nil, isRepeat: Bool? = nil, officialRating: String? = nil, isKids: Bool? = nil, height: Int? = nil, albumID: UUID? = nil, mediaStreams: [MediaStream]? = nil, playAccess: PlayAccess? = nil, lockedFields: [MetadataField]? = nil, parentPrimaryImageItemID: String? = nil, isMovie: Bool? = nil, programCount: Int? = nil, container: String? = nil, seriesStudio: String? = nil, displayOrder: String? = nil, parentThumbImageTag: String? = nil, imageTags: [String: String]? = nil, startDate: Date? = nil, genres: [String]? = nil, externalURLs: [ExternalURL]? = nil, isSupportsSync: Bool? = nil, artistCount: Int? = nil, enableMediaSourceDisplay: Bool? = nil, isHD: Bool? = nil, specialFeatureCount: Int? = nil, aperture: Double? = nil, albumPrimaryImageTag: String? = nil, genreItems: [NameGuidPair]? = nil, isFolder: Bool? = nil, overview: String? = nil, parentLogoImageTag: String? = nil, airsBeforeEpisodeNumber: Int? = nil, albumArtist: String? = nil, channelName: String? = nil, exposureTime: Double? = nil, indexNumberEnd: Int? = nil, albumCount: Int? = nil, seriesName: String? = nil, premiereDate: Date? = nil, movieCount: Int? = nil, sourceType: String? = nil, episodeTitle: String? = nil, extraType: String? = nil, mediaSourceCount: Int? = nil, imageOrientation: ImageOrientation? = nil, isPlaceHolder: Bool? = nil, type: String? = nil, isoSpeedRating: Int? = nil, currentProgram: BaseItemDto? = nil) {
        self.parentBackdropImageTags = parentBackdropImageTags
        self.path = path
        self.shutterSpeed = shutterSpeed
        self.isLive = isLive
        self.isPremiere = isPremiere
        self.runTimeTicks = runTimeTicks
        self.timerID = timerID
        self.aspectRatio = aspectRatio
        self.dateLastMediaAdded = dateLastMediaAdded
        self.lockData = lockData
        self.displayPreferencesID = displayPreferencesID
        self.channelPrimaryImageTag = channelPrimaryImageTag
        self.isSports = isSports
        self.channelNumber = channelNumber
        self.musicVideoCount = musicVideoCount
        self.preferredMetadataCountryCode = preferredMetadataCountryCode
        self.seasonID = seasonID
        self.people = people
        self.airTime = airTime
        self.canDelete = canDelete
        self.channelType = channelType
        self.video3DFormat = video3DFormat
        self.indexNumber = indexNumber
        self.trailerCount = trailerCount
        self.mediaType = mediaType
        self.channelID = channelID
        self.airDays = airDays
        self.studios = studios
        self.seasonName = seasonName
        self.airsBeforeSeasonNumber = airsBeforeSeasonNumber
        self.longitude = longitude
        self.cumulativeRunTimeTicks = cumulativeRunTimeTicks
        self.status = status
        self.seriesCount = seriesCount
        self.providerIDs = providerIDs
        self.localTrailerCount = localTrailerCount
        self.productionYear = productionYear
        self.serverID = serverID
        self.locationType = locationType
        self.name = name
        self.artistItems = artistItems
        self.parentThumbItemID = parentThumbItemID
        self.sortName = sortName
        self.playlistItemID = playlistItemID
        self.remoteTrailers = remoteTrailers
        self.productionLocations = productionLocations
        self.dateCreated = dateCreated
        self.parentArtImageTag = parentArtImageTag
        self.songCount = songCount
        self.communityRating = communityRating
        self.primaryImageAspectRatio = primaryImageAspectRatio
        self.mediaSources = mediaSources
        self.chapters = chapters
        self.partCount = partCount
        self.criticRating = criticRating
        self.recursiveItemCount = recursiveItemCount
        self.imageBlurHashes = imageBlurHashes
        self.collectionType = collectionType
        self.altitude = altitude
        self.id = id
        self.parentPrimaryImageTag = parentPrimaryImageTag
        self.episodeCount = episodeCount
        self.albumArtists = albumArtists
        self.parentBackdropItemID = parentBackdropItemID
        self.latitude = latitude
        self.taglines = taglines
        self.seriesID = seriesID
        self.width = width
        self.customRating = customRating
        self.cameraMake = cameraMake
        self.seriesThumbImageTag = seriesThumbImageTag
        self.isoType = isoType
        self.album = album
        self.focalLength = focalLength
        self.parentID = parentID
        self.artists = artists
        self.audio = audio
        self.completionPercentage = completionPercentage
        self.preferredMetadataLanguage = preferredMetadataLanguage
        self.cameraModel = cameraModel
        self.parentArtItemID = parentArtItemID
        self.childCount = childCount
        self.videoType = videoType
        self.userData = userData
        self.endDate = endDate
        self.backdropImageTags = backdropImageTags
        self.screenshotImageTags = screenshotImageTags
        self.software = software
        self.number = number
        self.parentIndexNumber = parentIndexNumber
        self.originalTitle = originalTitle
        self.seriesTimerID = seriesTimerID
        self.isNews = isNews
        self.canDownload = canDownload
        self.etag = etag
        self.hasSubtitles = hasSubtitles
        self.isSeries = isSeries
        self.parentLogoItemID = parentLogoItemID
        self.forcedSortName = forcedSortName
        self.programID = programID
        self.tags = tags
        self.seriesPrimaryImageTag = seriesPrimaryImageTag
        self.airsAfterSeasonNumber = airsAfterSeasonNumber
        self.isRepeat = isRepeat
        self.officialRating = officialRating
        self.isKids = isKids
        self.height = height
        self.albumID = albumID
        self.mediaStreams = mediaStreams
        self.playAccess = playAccess
        self.lockedFields = lockedFields
        self.parentPrimaryImageItemID = parentPrimaryImageItemID
        self.isMovie = isMovie
        self.programCount = programCount
        self.container = container
        self.seriesStudio = seriesStudio
        self.displayOrder = displayOrder
        self.parentThumbImageTag = parentThumbImageTag
        self.imageTags = imageTags
        self.startDate = startDate
        self.genres = genres
        self.externalURLs = externalURLs
        self.isSupportsSync = isSupportsSync
        self.artistCount = artistCount
        self.enableMediaSourceDisplay = enableMediaSourceDisplay
        self.isHD = isHD
        self.specialFeatureCount = specialFeatureCount
        self.aperture = aperture
        self.albumPrimaryImageTag = albumPrimaryImageTag
        self.genreItems = genreItems
        self.isFolder = isFolder
        self.overview = overview
        self.parentLogoImageTag = parentLogoImageTag
        self.airsBeforeEpisodeNumber = airsBeforeEpisodeNumber
        self.albumArtist = albumArtist
        self.channelName = channelName
        self.exposureTime = exposureTime
        self.indexNumberEnd = indexNumberEnd
        self.albumCount = albumCount
        self.seriesName = seriesName
        self.premiereDate = premiereDate
        self.movieCount = movieCount
        self.sourceType = sourceType
        self.episodeTitle = episodeTitle
        self.extraType = extraType
        self.mediaSourceCount = mediaSourceCount
        self.imageOrientation = imageOrientation
        self.isPlaceHolder = isPlaceHolder
        self.type = type
        self.isoSpeedRating = isoSpeedRating
        self.currentProgram = currentProgram
    }

    private enum CodingKeys: String, CodingKey {
        case parentBackdropImageTags = "ParentBackdropImageTags"
        case path = "Path"
        case shutterSpeed = "ShutterSpeed"
        case isLive = "IsLive"
        case isPremiere = "IsPremiere"
        case runTimeTicks = "RunTimeTicks"
        case timerID = "TimerId"
        case aspectRatio = "AspectRatio"
        case dateLastMediaAdded = "DateLastMediaAdded"
        case lockData = "LockData"
        case displayPreferencesID = "DisplayPreferencesId"
        case channelPrimaryImageTag = "ChannelPrimaryImageTag"
        case isSports = "IsSports"
        case channelNumber = "ChannelNumber"
        case musicVideoCount = "MusicVideoCount"
        case preferredMetadataCountryCode = "PreferredMetadataCountryCode"
        case seasonID = "SeasonId"
        case people = "People"
        case airTime = "AirTime"
        case canDelete = "CanDelete"
        case channelType = "ChannelType"
        case video3DFormat = "Video3DFormat"
        case indexNumber = "IndexNumber"
        case trailerCount = "TrailerCount"
        case mediaType = "MediaType"
        case channelID = "ChannelId"
        case airDays = "AirDays"
        case studios = "Studios"
        case seasonName = "SeasonName"
        case airsBeforeSeasonNumber = "AirsBeforeSeasonNumber"
        case longitude = "Longitude"
        case cumulativeRunTimeTicks = "CumulativeRunTimeTicks"
        case status = "Status"
        case seriesCount = "SeriesCount"
        case providerIDs = "ProviderIds"
        case localTrailerCount = "LocalTrailerCount"
        case productionYear = "ProductionYear"
        case serverID = "ServerId"
        case locationType = "LocationType"
        case name = "Name"
        case artistItems = "ArtistItems"
        case parentThumbItemID = "ParentThumbItemId"
        case sortName = "SortName"
        case playlistItemID = "PlaylistItemId"
        case remoteTrailers = "RemoteTrailers"
        case productionLocations = "ProductionLocations"
        case dateCreated = "DateCreated"
        case parentArtImageTag = "ParentArtImageTag"
        case songCount = "SongCount"
        case communityRating = "CommunityRating"
        case primaryImageAspectRatio = "PrimaryImageAspectRatio"
        case mediaSources = "MediaSources"
        case chapters = "Chapters"
        case partCount = "PartCount"
        case criticRating = "CriticRating"
        case recursiveItemCount = "RecursiveItemCount"
        case imageBlurHashes = "ImageBlurHashes"
        case collectionType = "CollectionType"
        case altitude = "Altitude"
        case id = "Id"
        case parentPrimaryImageTag = "ParentPrimaryImageTag"
        case episodeCount = "EpisodeCount"
        case albumArtists = "AlbumArtists"
        case parentBackdropItemID = "ParentBackdropItemId"
        case latitude = "Latitude"
        case taglines = "Taglines"
        case seriesID = "SeriesId"
        case width = "Width"
        case customRating = "CustomRating"
        case cameraMake = "CameraMake"
        case seriesThumbImageTag = "SeriesThumbImageTag"
        case isoType = "IsoType"
        case album = "Album"
        case focalLength = "FocalLength"
        case parentID = "ParentId"
        case artists = "Artists"
        case audio = "Audio"
        case completionPercentage = "CompletionPercentage"
        case preferredMetadataLanguage = "PreferredMetadataLanguage"
        case cameraModel = "CameraModel"
        case parentArtItemID = "ParentArtItemId"
        case childCount = "ChildCount"
        case videoType = "VideoType"
        case userData = "UserData"
        case endDate = "EndDate"
        case backdropImageTags = "BackdropImageTags"
        case screenshotImageTags = "ScreenshotImageTags"
        case software = "Software"
        case number = "Number"
        case parentIndexNumber = "ParentIndexNumber"
        case originalTitle = "OriginalTitle"
        case seriesTimerID = "SeriesTimerId"
        case isNews = "IsNews"
        case canDownload = "CanDownload"
        case etag = "Etag"
        case hasSubtitles = "HasSubtitles"
        case isSeries = "IsSeries"
        case parentLogoItemID = "ParentLogoItemId"
        case forcedSortName = "ForcedSortName"
        case programID = "ProgramId"
        case tags = "Tags"
        case seriesPrimaryImageTag = "SeriesPrimaryImageTag"
        case airsAfterSeasonNumber = "AirsAfterSeasonNumber"
        case isRepeat = "IsRepeat"
        case officialRating = "OfficialRating"
        case isKids = "IsKids"
        case height = "Height"
        case albumID = "AlbumId"
        case mediaStreams = "MediaStreams"
        case playAccess = "PlayAccess"
        case lockedFields = "LockedFields"
        case parentPrimaryImageItemID = "ParentPrimaryImageItemId"
        case isMovie = "IsMovie"
        case programCount = "ProgramCount"
        case container = "Container"
        case seriesStudio = "SeriesStudio"
        case displayOrder = "DisplayOrder"
        case parentThumbImageTag = "ParentThumbImageTag"
        case imageTags = "ImageTags"
        case startDate = "StartDate"
        case genres = "Genres"
        case externalURLs = "ExternalUrls"
        case isSupportsSync = "SupportsSync"
        case artistCount = "ArtistCount"
        case enableMediaSourceDisplay = "EnableMediaSourceDisplay"
        case isHD = "IsHD"
        case specialFeatureCount = "SpecialFeatureCount"
        case aperture = "Aperture"
        case albumPrimaryImageTag = "AlbumPrimaryImageTag"
        case genreItems = "GenreItems"
        case isFolder = "IsFolder"
        case overview = "Overview"
        case parentLogoImageTag = "ParentLogoImageTag"
        case airsBeforeEpisodeNumber = "AirsBeforeEpisodeNumber"
        case albumArtist = "AlbumArtist"
        case channelName = "ChannelName"
        case exposureTime = "ExposureTime"
        case indexNumberEnd = "IndexNumberEnd"
        case albumCount = "AlbumCount"
        case seriesName = "SeriesName"
        case premiereDate = "PremiereDate"
        case movieCount = "MovieCount"
        case sourceType = "SourceType"
        case episodeTitle = "EpisodeTitle"
        case extraType = "ExtraType"
        case mediaSourceCount = "MediaSourceCount"
        case imageOrientation = "ImageOrientation"
        case isPlaceHolder = "IsPlaceHolder"
        case type = "Type"
        case isoSpeedRating = "IsoSpeedRating"
        case currentProgram = "CurrentProgram"
    }
}

public struct AuthenticationInfo: Codable {
    public var userName: String?
    public var dateRevoked: Date?
    public var deviceID: String?
    public var id: Int?
    public var appVersion: String?
    public var dateCreated: Date?
    public var deviceName: String?
    public var isActive: Bool?
    public var accessToken: String?
    public var dateLastActivity: Date?
    public var userID: UUID?
    public var appName: String?

    public init(userName: String? = nil, dateRevoked: Date? = nil, deviceID: String? = nil, id: Int? = nil, appVersion: String? = nil, dateCreated: Date? = nil, deviceName: String? = nil, isActive: Bool? = nil, accessToken: String? = nil, dateLastActivity: Date? = nil, userID: UUID? = nil, appName: String? = nil) {
        self.userName = userName
        self.dateRevoked = dateRevoked
        self.deviceID = deviceID
        self.id = id
        self.appVersion = appVersion
        self.dateCreated = dateCreated
        self.deviceName = deviceName
        self.isActive = isActive
        self.accessToken = accessToken
        self.dateLastActivity = dateLastActivity
        self.userID = userID
        self.appName = appName
    }

    private enum CodingKeys: String, CodingKey {
        case userName = "UserName"
        case dateRevoked = "DateRevoked"
        case deviceID = "DeviceId"
        case id = "Id"
        case appVersion = "AppVersion"
        case dateCreated = "DateCreated"
        case deviceName = "DeviceName"
        case isActive = "IsActive"
        case accessToken = "AccessToken"
        case dateLastActivity = "DateLastActivity"
        case userID = "UserId"
        case appName = "AppName"
    }
}

public enum GroupRepeatMode: String, Codable, CaseIterable {
    case repeatOne = "RepeatOne"
    case repeatAll = "RepeatAll"
    case repeatNone = "RepeatNone"
}

public struct UpdateMediaPathRequestDto: Codable {
    public var name: String
    public var pathInfo: MediaPathInfo

    public init(name: String, pathInfo: MediaPathInfo) {
        self.name = name
        self.pathInfo = pathInfo
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case pathInfo = "PathInfo"
    }
}

public enum RatingType: String, Codable, CaseIterable {
    case score = "Score"
    case likes = "Likes"
}

public struct MovePlaylistItemRequestDto: Codable {
    public var playlistItemID: UUID?
    public var newIndex: Int?

    public init(playlistItemID: UUID? = nil, newIndex: Int? = nil) {
        self.playlistItemID = playlistItemID
        self.newIndex = newIndex
    }

    private enum CodingKeys: String, CodingKey {
        case playlistItemID = "PlaylistItemId"
        case newIndex = "NewIndex"
    }
}

public struct QueueRequestDto: Codable {
    public var mode: GroupQueueMode?
    public var itemIDs: [UUID]?

    public init(mode: GroupQueueMode? = nil, itemIDs: [UUID]? = nil) {
        self.mode = mode
        self.itemIDs = itemIDs
    }

    private enum CodingKeys: String, CodingKey {
        case mode = "Mode"
        case itemIDs = "ItemIds"
    }
}

public enum TaskState: String, Codable, CaseIterable {
    case idle = "Idle"
    case cancelling = "Cancelling"
    case running = "Running"
}

public struct PlaystateRequest: Codable {
    public var controllingUserID: String?
    public var seekPositionTicks: Int?
    public var command: PlaystateCommand?

    public init(controllingUserID: String? = nil, seekPositionTicks: Int? = nil, command: PlaystateCommand? = nil) {
        self.controllingUserID = controllingUserID
        self.seekPositionTicks = seekPositionTicks
        self.command = command
    }

    private enum CodingKeys: String, CodingKey {
        case controllingUserID = "ControllingUserId"
        case seekPositionTicks = "SeekPositionTicks"
        case command = "Command"
    }
}

public enum DlnaProfileType: String, Codable, CaseIterable {
    case audio = "Audio"
    case video = "Video"
    case photo = "Photo"
}

public struct EndPointInfo: Codable {
    public var isInNetwork: Bool?
    public var isLocal: Bool?

    public init(isInNetwork: Bool? = nil, isLocal: Bool? = nil) {
        self.isInNetwork = isInNetwork
        self.isLocal = isLocal
    }

    private enum CodingKeys: String, CodingKey {
        case isInNetwork = "IsInNetwork"
        case isLocal = "IsLocal"
    }
}

public struct StartupUserDto: Codable {
    public var name: String?
    public var password: String?

    public init(name: String? = nil, password: String? = nil) {
        self.name = name
        self.password = password
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case password = "Password"
    }
}

public struct SeriesTimerInfoDto: Codable {
    public var startDate: Date?
    public var externalID: String?
    public var isRecordAnyTime: Bool?
    public var parentBackdropImageTags: [String]?
    public var parentPrimaryImageItemID: String?
    public var isRecordAnyChannel: Bool?
    public var isRecordNewOnly: Bool?
    public var priority: Int?
    public var keepUntil: KeepUntil?
    public var channelID: UUID?
    public var parentPrimaryImageTag: String?
    public var keepUpTo: Int?
    public var parentThumbImageTag: String?
    public var endDate: Date?
    public var postPaddingSeconds: Int?
    public var serverID: String?
    public var parentThumbItemID: String?
    public var type: String?
    public var serviceName: String?
    public var channelName: String?
    public var id: String?
    public var dayPattern: DayPattern?
    public var overview: String?
    public var externalProgramID: String?
    public var externalChannelID: String?
    public var isPostPaddingRequired: Bool?
    public var prePaddingSeconds: Int?
    public var channelPrimaryImageTag: String?
    public var programID: String?
    public var name: String?
    public var isSkipEpisodesInLibrary: Bool?
    public var parentBackdropItemID: String?
    public var imageTags: [String: String]?
    public var isPrePaddingRequired: Bool?
    public var days: [DayOfWeek]?

    public init(startDate: Date? = nil, externalID: String? = nil, isRecordAnyTime: Bool? = nil, parentBackdropImageTags: [String]? = nil, parentPrimaryImageItemID: String? = nil, isRecordAnyChannel: Bool? = nil, isRecordNewOnly: Bool? = nil, priority: Int? = nil, keepUntil: KeepUntil? = nil, channelID: UUID? = nil, parentPrimaryImageTag: String? = nil, keepUpTo: Int? = nil, parentThumbImageTag: String? = nil, endDate: Date? = nil, postPaddingSeconds: Int? = nil, serverID: String? = nil, parentThumbItemID: String? = nil, type: String? = nil, serviceName: String? = nil, channelName: String? = nil, id: String? = nil, dayPattern: DayPattern? = nil, overview: String? = nil, externalProgramID: String? = nil, externalChannelID: String? = nil, isPostPaddingRequired: Bool? = nil, prePaddingSeconds: Int? = nil, channelPrimaryImageTag: String? = nil, programID: String? = nil, name: String? = nil, isSkipEpisodesInLibrary: Bool? = nil, parentBackdropItemID: String? = nil, imageTags: [String: String]? = nil, isPrePaddingRequired: Bool? = nil, days: [DayOfWeek]? = nil) {
        self.startDate = startDate
        self.externalID = externalID
        self.isRecordAnyTime = isRecordAnyTime
        self.parentBackdropImageTags = parentBackdropImageTags
        self.parentPrimaryImageItemID = parentPrimaryImageItemID
        self.isRecordAnyChannel = isRecordAnyChannel
        self.isRecordNewOnly = isRecordNewOnly
        self.priority = priority
        self.keepUntil = keepUntil
        self.channelID = channelID
        self.parentPrimaryImageTag = parentPrimaryImageTag
        self.keepUpTo = keepUpTo
        self.parentThumbImageTag = parentThumbImageTag
        self.endDate = endDate
        self.postPaddingSeconds = postPaddingSeconds
        self.serverID = serverID
        self.parentThumbItemID = parentThumbItemID
        self.type = type
        self.serviceName = serviceName
        self.channelName = channelName
        self.id = id
        self.dayPattern = dayPattern
        self.overview = overview
        self.externalProgramID = externalProgramID
        self.externalChannelID = externalChannelID
        self.isPostPaddingRequired = isPostPaddingRequired
        self.prePaddingSeconds = prePaddingSeconds
        self.channelPrimaryImageTag = channelPrimaryImageTag
        self.programID = programID
        self.name = name
        self.isSkipEpisodesInLibrary = isSkipEpisodesInLibrary
        self.parentBackdropItemID = parentBackdropItemID
        self.imageTags = imageTags
        self.isPrePaddingRequired = isPrePaddingRequired
        self.days = days
    }

    private enum CodingKeys: String, CodingKey {
        case startDate = "StartDate"
        case externalID = "ExternalId"
        case isRecordAnyTime = "RecordAnyTime"
        case parentBackdropImageTags = "ParentBackdropImageTags"
        case parentPrimaryImageItemID = "ParentPrimaryImageItemId"
        case isRecordAnyChannel = "RecordAnyChannel"
        case isRecordNewOnly = "RecordNewOnly"
        case priority = "Priority"
        case keepUntil = "KeepUntil"
        case channelID = "ChannelId"
        case parentPrimaryImageTag = "ParentPrimaryImageTag"
        case keepUpTo = "KeepUpTo"
        case parentThumbImageTag = "ParentThumbImageTag"
        case endDate = "EndDate"
        case postPaddingSeconds = "PostPaddingSeconds"
        case serverID = "ServerId"
        case parentThumbItemID = "ParentThumbItemId"
        case type = "Type"
        case serviceName = "ServiceName"
        case channelName = "ChannelName"
        case id = "Id"
        case dayPattern = "DayPattern"
        case overview = "Overview"
        case externalProgramID = "ExternalProgramId"
        case externalChannelID = "ExternalChannelId"
        case isPostPaddingRequired = "IsPostPaddingRequired"
        case prePaddingSeconds = "PrePaddingSeconds"
        case channelPrimaryImageTag = "ChannelPrimaryImageTag"
        case programID = "ProgramId"
        case name = "Name"
        case isSkipEpisodesInLibrary = "SkipEpisodesInLibrary"
        case parentBackdropItemID = "ParentBackdropItemId"
        case imageTags = "ImageTags"
        case isPrePaddingRequired = "IsPrePaddingRequired"
        case days = "Days"
    }
}

public struct WakeOnLanInfo: Codable {
    public var macAddress: String?
    public var port: Int?

    public init(macAddress: String? = nil, port: Int? = nil) {
        self.macAddress = macAddress
        self.port = port
    }

    private enum CodingKeys: String, CodingKey {
        case macAddress = "MacAddress"
        case port = "Port"
    }
}

public struct TaskTriggerInfo: Codable {
    public var timeOfDayTicks: Int?
    public var maxRuntimeTicks: Int?
    public var dayOfWeek: DayOfWeek?
    public var type: String?
    public var intervalTicks: Int?

    public init(timeOfDayTicks: Int? = nil, maxRuntimeTicks: Int? = nil, dayOfWeek: DayOfWeek? = nil, type: String? = nil, intervalTicks: Int? = nil) {
        self.timeOfDayTicks = timeOfDayTicks
        self.maxRuntimeTicks = maxRuntimeTicks
        self.dayOfWeek = dayOfWeek
        self.type = type
        self.intervalTicks = intervalTicks
    }

    private enum CodingKeys: String, CodingKey {
        case timeOfDayTicks = "TimeOfDayTicks"
        case maxRuntimeTicks = "MaxRuntimeTicks"
        case dayOfWeek = "DayOfWeek"
        case type = "Type"
        case intervalTicks = "IntervalTicks"
    }
}

public struct LiveStreamResponse: Codable {
    public var mediaSource: MediaSourceInfo?

    public init(mediaSource: MediaSourceInfo? = nil) {
        self.mediaSource = mediaSource
    }

    private enum CodingKeys: String, CodingKey {
        case mediaSource = "MediaSource"
    }
}

public struct UserConfiguration: Codable {
    public var latestItemsExcludes: [String]?
    public var isDisplayMissingEpisodes: Bool?
    public var subtitleMode: SubtitlePlaybackMode?
    public var audioLanguagePreference: String?
    public var isDisplayCollectionsView: Bool?
    public var myMediaExcludes: [String]?
    public var orderedViews: [String]?
    public var isPlayDefaultAudioTrack: Bool?
    public var groupedFolders: [String]?
    public var enableLocalPassword: Bool?
    public var isRememberSubtitleSelections: Bool?
    public var subtitleLanguagePreference: String?
    public var isRememberAudioSelections: Bool?
    public var isHidePlayedInLatest: Bool?
    public var enableNextEpisodeAutoPlay: Bool?

    public init(latestItemsExcludes: [String]? = nil, isDisplayMissingEpisodes: Bool? = nil, subtitleMode: SubtitlePlaybackMode? = nil, audioLanguagePreference: String? = nil, isDisplayCollectionsView: Bool? = nil, myMediaExcludes: [String]? = nil, orderedViews: [String]? = nil, isPlayDefaultAudioTrack: Bool? = nil, groupedFolders: [String]? = nil, enableLocalPassword: Bool? = nil, isRememberSubtitleSelections: Bool? = nil, subtitleLanguagePreference: String? = nil, isRememberAudioSelections: Bool? = nil, isHidePlayedInLatest: Bool? = nil, enableNextEpisodeAutoPlay: Bool? = nil) {
        self.latestItemsExcludes = latestItemsExcludes
        self.isDisplayMissingEpisodes = isDisplayMissingEpisodes
        self.subtitleMode = subtitleMode
        self.audioLanguagePreference = audioLanguagePreference
        self.isDisplayCollectionsView = isDisplayCollectionsView
        self.myMediaExcludes = myMediaExcludes
        self.orderedViews = orderedViews
        self.isPlayDefaultAudioTrack = isPlayDefaultAudioTrack
        self.groupedFolders = groupedFolders
        self.enableLocalPassword = enableLocalPassword
        self.isRememberSubtitleSelections = isRememberSubtitleSelections
        self.subtitleLanguagePreference = subtitleLanguagePreference
        self.isRememberAudioSelections = isRememberAudioSelections
        self.isHidePlayedInLatest = isHidePlayedInLatest
        self.enableNextEpisodeAutoPlay = enableNextEpisodeAutoPlay
    }

    private enum CodingKeys: String, CodingKey {
        case latestItemsExcludes = "LatestItemsExcludes"
        case isDisplayMissingEpisodes = "DisplayMissingEpisodes"
        case subtitleMode = "SubtitleMode"
        case audioLanguagePreference = "AudioLanguagePreference"
        case isDisplayCollectionsView = "DisplayCollectionsView"
        case myMediaExcludes = "MyMediaExcludes"
        case orderedViews = "OrderedViews"
        case isPlayDefaultAudioTrack = "PlayDefaultAudioTrack"
        case groupedFolders = "GroupedFolders"
        case enableLocalPassword = "EnableLocalPassword"
        case isRememberSubtitleSelections = "RememberSubtitleSelections"
        case subtitleLanguagePreference = "SubtitleLanguagePreference"
        case isRememberAudioSelections = "RememberAudioSelections"
        case isHidePlayedInLatest = "HidePlayedInLatest"
        case enableNextEpisodeAutoPlay = "EnableNextEpisodeAutoPlay"
    }
}

public struct MediaUpdateInfoDto: Codable {
    public var updates: [MediaUpdateInfoPathDto]?

    public init(updates: [MediaUpdateInfoPathDto]? = nil) {
        self.updates = updates
    }

    private enum CodingKeys: String, CodingKey {
        case updates = "Updates"
    }
}

public struct BufferRequestDto: Codable {
    public var playlistItemID: UUID?
    public var positionTicks: Int?
    public var isPlaying: Bool?
    public var when: Date?

    public init(playlistItemID: UUID? = nil, positionTicks: Int? = nil, isPlaying: Bool? = nil, when: Date? = nil) {
        self.playlistItemID = playlistItemID
        self.positionTicks = positionTicks
        self.isPlaying = isPlaying
        self.when = when
    }

    private enum CodingKeys: String, CodingKey {
        case playlistItemID = "PlaylistItemId"
        case positionTicks = "PositionTicks"
        case isPlaying = "IsPlaying"
        case when = "When"
    }
}

public struct ArtistInfoRemoteSearchQuery: Codable {
    public var searchInfo: ArtistInfo?
    public var itemID: UUID?
    public var searchProviderName: String?
    public var isIncludeDisabledProviders: Bool?

    public init(searchInfo: ArtistInfo? = nil, itemID: UUID? = nil, searchProviderName: String? = nil, isIncludeDisabledProviders: Bool? = nil) {
        self.searchInfo = searchInfo
        self.itemID = itemID
        self.searchProviderName = searchProviderName
        self.isIncludeDisabledProviders = isIncludeDisabledProviders
    }

    private enum CodingKeys: String, CodingKey {
        case searchInfo = "SearchInfo"
        case itemID = "ItemId"
        case searchProviderName = "SearchProviderName"
        case isIncludeDisabledProviders = "IncludeDisabledProviders"
    }
}

public struct NameValuePair: Codable {
    public var name: String?
    public var value: String?

    public init(name: String? = nil, value: String? = nil) {
        self.name = name
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }
}

public struct NextItemRequestDto: Codable {
    public var playlistItemID: UUID?

    public init(playlistItemID: UUID? = nil) {
        self.playlistItemID = playlistItemID
    }

    private enum CodingKeys: String, CodingKey {
        case playlistItemID = "PlaylistItemId"
    }
}

public enum HeaderMatchType: String, Codable, CaseIterable {
    case equals = "Equals"
    case regex = "Regex"
    case substring = "Substring"
}

public struct SeriesInfo: Codable {
    public var indexNumber: Int?
    public var parentIndexNumber: Int?
    public var name: String?
    public var metadataCountryCode: String?
    public var isAutomated: Bool?
    public var year: Int?
    public var path: String?
    public var providerIDs: [String: String]?
    public var premiereDate: Date?
    public var metadataLanguage: String?

    public init(indexNumber: Int? = nil, parentIndexNumber: Int? = nil, name: String? = nil, metadataCountryCode: String? = nil, isAutomated: Bool? = nil, year: Int? = nil, path: String? = nil, providerIDs: [String: String]? = nil, premiereDate: Date? = nil, metadataLanguage: String? = nil) {
        self.indexNumber = indexNumber
        self.parentIndexNumber = parentIndexNumber
        self.name = name
        self.metadataCountryCode = metadataCountryCode
        self.isAutomated = isAutomated
        self.year = year
        self.path = path
        self.providerIDs = providerIDs
        self.premiereDate = premiereDate
        self.metadataLanguage = metadataLanguage
    }

    private enum CodingKeys: String, CodingKey {
        case indexNumber = "IndexNumber"
        case parentIndexNumber = "ParentIndexNumber"
        case name = "Name"
        case metadataCountryCode = "MetadataCountryCode"
        case isAutomated = "IsAutomated"
        case year = "Year"
        case path = "Path"
        case providerIDs = "ProviderIds"
        case premiereDate = "PremiereDate"
        case metadataLanguage = "MetadataLanguage"
    }
}

public struct SetRepeatModeRequestDto: Codable {
    public var mode: GroupRepeatMode?

    public init(mode: GroupRepeatMode? = nil) {
        self.mode = mode
    }

    private enum CodingKeys: String, CodingKey {
        case mode = "Mode"
    }
}

public enum GeneralCommandType: String, Codable, CaseIterable {
    case moveUp = "MoveUp"
    case moveDown = "MoveDown"
    case moveLeft = "MoveLeft"
    case moveRight = "MoveRight"
    case pageUp = "PageUp"
    case pageDown = "PageDown"
    case previousLetter = "PreviousLetter"
    case nextLetter = "NextLetter"
    case toggleOsd = "ToggleOsd"
    case toggleContextMenu = "ToggleContextMenu"
    case select = "Select"
    case back = "Back"
    case takeScreenshot = "TakeScreenshot"
    case sendKey = "SendKey"
    case sendString = "SendString"
    case goHome = "GoHome"
    case goToSettings = "GoToSettings"
    case volumeUp = "VolumeUp"
    case volumeDown = "VolumeDown"
    case mute = "Mute"
    case unmute = "Unmute"
    case toggleMute = "ToggleMute"
    case setVolume = "SetVolume"
    case setAudioStreamIndex = "SetAudioStreamIndex"
    case setSubtitleStreamIndex = "SetSubtitleStreamIndex"
    case toggleFullscreen = "ToggleFullscreen"
    case displayContent = "DisplayContent"
    case goToSearch = "GoToSearch"
    case displayMessage = "DisplayMessage"
    case setRepeatMode = "SetRepeatMode"
    case channelUp = "ChannelUp"
    case channelDown = "ChannelDown"
    case guide = "Guide"
    case toggleStats = "ToggleStats"
    case playMediaSource = "PlayMediaSource"
    case playTrailers = "PlayTrailers"
    case setShuffleQueue = "SetShuffleQueue"
    case playState = "PlayState"
    case playNext = "PlayNext"
    case toggleOsdMenu = "ToggleOsdMenu"
    case play = "Play"
}

public enum SubtitleDeliveryMethod: String, Codable, CaseIterable {
    case encode = "Encode"
    case embed = "Embed"
    case external = "External"
    case hls = "Hls"
}

public enum SyncPlayUserAccessType: String, Codable, CaseIterable {
    case createAndJoinGroups = "CreateAndJoinGroups"
    case joinGroups = "JoinGroups"
    case `none` = "None"
}

public enum IsoType: String, Codable, CaseIterable {
    case dvd = "Dvd"
    case bluRay = "BluRay"
}

public struct NameIDPair: Codable {
    public var id: String?
    public var name: String?

    public init(id: String? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
    }
}

public struct ExternalIDInfo: Codable {
    public var name: String?
    public var key: String?
    public var urlFormatString: String?
    public var type: ExternalIDMediaType?

    public init(name: String? = nil, key: String? = nil, urlFormatString: String? = nil, type: ExternalIDMediaType? = nil) {
        self.name = name
        self.key = key
        self.urlFormatString = urlFormatString
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case key = "Key"
        case urlFormatString = "UrlFormatString"
        case type = "Type"
    }
}

public enum MetadataRefreshMode: String, Codable, CaseIterable {
    case `none` = "None"
    case validationOnly = "ValidationOnly"
    case `default` = "Default"
    case fullRefresh = "FullRefresh"
}

public enum PluginStatus: String, Codable, CaseIterable {
    case active = "Active"
    case restart = "Restart"
    case deleted = "Deleted"
    case superceded = "Superceded"
    case malfunctioned = "Malfunctioned"
    case notSupported = "NotSupported"
    case disabled = "Disabled"
}

public struct SessionUserInfo: Codable {
    public var userID: UUID?
    public var userName: String?

    public init(userID: UUID? = nil, userName: String? = nil) {
        self.userID = userID
        self.userName = userName
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "UserId"
        case userName = "UserName"
    }
}

public struct MediaPathInfo: Codable {
    public var networkPath: String?
    public var path: String?

    public init(networkPath: String? = nil, path: String? = nil) {
        self.networkPath = networkPath
        self.path = path
    }

    private enum CodingKeys: String, CodingKey {
        case networkPath = "NetworkPath"
        case path = "Path"
    }
}

public struct ForgotPasswordDto: Codable {
    public var enteredUsername: String

    public init(enteredUsername: String) {
        self.enteredUsername = enteredUsername
    }

    private enum CodingKeys: String, CodingKey {
        case enteredUsername = "EnteredUsername"
    }
}

public enum MediaStreamType: String, Codable, CaseIterable {
    case audio = "Audio"
    case video = "Video"
    case subtitle = "Subtitle"
    case embeddedImage = "EmbeddedImage"
}

public struct ClientCapabilitiesDto: Codable {
    public var iconURL: String?
    public var messageCallbackURL: String?
    public var isSupportsSync: Bool?
    public var playableMediaTypes: [String]?
    public var isSupportsPersistentIdentifier: Bool?
    public var appStoreURL: String?
    public var supportedCommands: [GeneralCommandType]?
    public var isSupportsContentUploading: Bool?
    public var deviceProfile: DeviceProfile?
    public var isSupportsMediaControl: Bool?

    public init(iconURL: String? = nil, messageCallbackURL: String? = nil, isSupportsSync: Bool? = nil, playableMediaTypes: [String]? = nil, isSupportsPersistentIdentifier: Bool? = nil, appStoreURL: String? = nil, supportedCommands: [GeneralCommandType]? = nil, isSupportsContentUploading: Bool? = nil, deviceProfile: DeviceProfile? = nil, isSupportsMediaControl: Bool? = nil) {
        self.iconURL = iconURL
        self.messageCallbackURL = messageCallbackURL
        self.isSupportsSync = isSupportsSync
        self.playableMediaTypes = playableMediaTypes
        self.isSupportsPersistentIdentifier = isSupportsPersistentIdentifier
        self.appStoreURL = appStoreURL
        self.supportedCommands = supportedCommands
        self.isSupportsContentUploading = isSupportsContentUploading
        self.deviceProfile = deviceProfile
        self.isSupportsMediaControl = isSupportsMediaControl
    }

    private enum CodingKeys: String, CodingKey {
        case iconURL = "IconUrl"
        case messageCallbackURL = "MessageCallbackUrl"
        case isSupportsSync = "SupportsSync"
        case playableMediaTypes = "PlayableMediaTypes"
        case isSupportsPersistentIdentifier = "SupportsPersistentIdentifier"
        case appStoreURL = "AppStoreUrl"
        case supportedCommands = "SupportedCommands"
        case isSupportsContentUploading = "SupportsContentUploading"
        case deviceProfile = "DeviceProfile"
        case isSupportsMediaControl = "SupportsMediaControl"
    }
}

public struct MediaPathDto: Codable {
    public var path: String?
    public var pathInfo: MediaPathInfo?
    public var name: String

    public init(path: String? = nil, pathInfo: MediaPathInfo? = nil, name: String) {
        self.path = path
        self.pathInfo = pathInfo
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case path = "Path"
        case pathInfo = "PathInfo"
        case name = "Name"
    }
}

public struct MediaUpdateInfoPathDto: Codable {
    public var updateType: String?
    public var path: String?

    public init(updateType: String? = nil, path: String? = nil) {
        self.updateType = updateType
        self.path = path
    }

    private enum CodingKeys: String, CodingKey {
        case updateType = "UpdateType"
        case path = "Path"
    }
}

public struct LibraryTypeOptionsDto: Codable {
    public var imageFetchers: [LibraryOptionInfoDto]?
    public var metadataFetchers: [LibraryOptionInfoDto]?
    public var defaultImageOptions: [ImageOption]?
    public var supportedImageTypes: [ImageType]?
    public var type: String?

    public init(imageFetchers: [LibraryOptionInfoDto]? = nil, metadataFetchers: [LibraryOptionInfoDto]? = nil, defaultImageOptions: [ImageOption]? = nil, supportedImageTypes: [ImageType]? = nil, type: String? = nil) {
        self.imageFetchers = imageFetchers
        self.metadataFetchers = metadataFetchers
        self.defaultImageOptions = defaultImageOptions
        self.supportedImageTypes = supportedImageTypes
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case imageFetchers = "ImageFetchers"
        case metadataFetchers = "MetadataFetchers"
        case defaultImageOptions = "DefaultImageOptions"
        case supportedImageTypes = "SupportedImageTypes"
        case type = "Type"
    }
}

public struct ObjectGroupUpdate: Codable {
    public var type: GroupUpdateType?
    public var groupID: UUID?
    public var data: AnyJSON?

    public init(type: GroupUpdateType? = nil, groupID: UUID? = nil, data: AnyJSON? = nil) {
        self.type = type
        self.groupID = groupID
        self.data = data
    }

    private enum CodingKeys: String, CodingKey {
        case type = "Type"
        case groupID = "GroupId"
        case data = "Data"
    }
}

public enum ProfileConditionType: String, Codable, CaseIterable {
    case equals = "Equals"
    case notEquals = "NotEquals"
    case lessThanEqual = "LessThanEqual"
    case greaterThanEqual = "GreaterThanEqual"
    case equalsAny = "EqualsAny"
}

public enum DayOfWeek: String, Codable, CaseIterable {
    case sunday = "Sunday"
    case monday = "Monday"
    case tuesday = "Tuesday"
    case wednesday = "Wednesday"
    case thursday = "Thursday"
    case friday = "Friday"
    case saturday = "Saturday"
}

public struct MessageCommand: Codable {
    public var header: String?
    public var text: String
    public var timeoutMs: Int?

    public init(header: String? = nil, text: String, timeoutMs: Int? = nil) {
        self.header = header
        self.text = text
        self.timeoutMs = timeoutMs
    }

    private enum CodingKeys: String, CodingKey {
        case header = "Header"
        case text = "Text"
        case timeoutMs = "TimeoutMs"
    }
}

public struct AccessSchedule: Codable {
    public var userID: UUID
    public var startHour: Double
    public var dayOfWeek: DynamicDayOfWeek
    public var endHour: Double
    public var id: Int

    public init(userID: UUID, startHour: Double, dayOfWeek: DynamicDayOfWeek, endHour: Double, id: Int) {
        self.userID = userID
        self.startHour = startHour
        self.dayOfWeek = dayOfWeek
        self.endHour = endHour
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "UserId"
        case startHour = "StartHour"
        case dayOfWeek = "DayOfWeek"
        case endHour = "EndHour"
        case id = "Id"
    }
}

public struct IgnoreWaitRequestDto: Codable {
    public var isIgnoreWait: Bool?

    public init(isIgnoreWait: Bool? = nil) {
        self.isIgnoreWait = isIgnoreWait
    }

    private enum CodingKeys: String, CodingKey {
        case isIgnoreWait = "IgnoreWait"
    }
}

public enum NotificationLevel: String, Codable, CaseIterable {
    case normal = "Normal"
    case warning = "Warning"
    case error = "Error"
}

public struct RecommendationDto: Codable {
    public var recommendationType: RecommendationType?
    public var items: [BaseItemDto]?
    public var baselineItemName: String?
    public var categoryID: UUID?

    public init(recommendationType: RecommendationType? = nil, items: [BaseItemDto]? = nil, baselineItemName: String? = nil, categoryID: UUID? = nil) {
        self.recommendationType = recommendationType
        self.items = items
        self.baselineItemName = baselineItemName
        self.categoryID = categoryID
    }

    private enum CodingKeys: String, CodingKey {
        case recommendationType = "RecommendationType"
        case items = "Items"
        case baselineItemName = "BaselineItemName"
        case categoryID = "CategoryId"
    }
}

public struct XmlAttribute: Codable {
    public var name: String?
    public var value: String?

    public init(name: String? = nil, value: String? = nil) {
        self.name = name
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }
}

public enum EncodingContext: String, Codable, CaseIterable {
    case streaming = "Streaming"
    case `static` = "Static"
}

public struct FontFile: Codable {
    public var dateCreated: Date?
    public var size: Int?
    public var name: String?
    public var dateModified: Date?

    public init(dateCreated: Date? = nil, size: Int? = nil, name: String? = nil, dateModified: Date? = nil) {
        self.dateCreated = dateCreated
        self.size = size
        self.name = name
        self.dateModified = dateModified
    }

    private enum CodingKeys: String, CodingKey {
        case dateCreated = "DateCreated"
        case size = "Size"
        case name = "Name"
        case dateModified = "DateModified"
    }
}

public struct MovieInfo: Codable {
    public var indexNumber: Int?
    public var metadataLanguage: String?
    public var premiereDate: Date?
    public var isAutomated: Bool?
    public var metadataCountryCode: String?
    public var providerIDs: [String: String]?
    public var path: String?
    public var year: Int?
    public var parentIndexNumber: Int?
    public var name: String?

    public init(indexNumber: Int? = nil, metadataLanguage: String? = nil, premiereDate: Date? = nil, isAutomated: Bool? = nil, metadataCountryCode: String? = nil, providerIDs: [String: String]? = nil, path: String? = nil, year: Int? = nil, parentIndexNumber: Int? = nil, name: String? = nil) {
        self.indexNumber = indexNumber
        self.metadataLanguage = metadataLanguage
        self.premiereDate = premiereDate
        self.isAutomated = isAutomated
        self.metadataCountryCode = metadataCountryCode
        self.providerIDs = providerIDs
        self.path = path
        self.year = year
        self.parentIndexNumber = parentIndexNumber
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case indexNumber = "IndexNumber"
        case metadataLanguage = "MetadataLanguage"
        case premiereDate = "PremiereDate"
        case isAutomated = "IsAutomated"
        case metadataCountryCode = "MetadataCountryCode"
        case providerIDs = "ProviderIds"
        case path = "Path"
        case year = "Year"
        case parentIndexNumber = "ParentIndexNumber"
        case name = "Name"
    }
}

public struct UserItemDataDto: Codable {
    public var unplayedItemCount: Int?
    public var playCount: Int?
    public var isPlayed: Bool?
    public var isLikes: Bool?
    public var playbackPositionTicks: Int?
    public var itemID: String?
    public var lastPlayedDate: Date?
    public var rating: Double?
    public var key: String?
    public var isFavorite: Bool?
    public var playedPercentage: Double?

    public init(unplayedItemCount: Int? = nil, playCount: Int? = nil, isPlayed: Bool? = nil, isLikes: Bool? = nil, playbackPositionTicks: Int? = nil, itemID: String? = nil, lastPlayedDate: Date? = nil, rating: Double? = nil, key: String? = nil, isFavorite: Bool? = nil, playedPercentage: Double? = nil) {
        self.unplayedItemCount = unplayedItemCount
        self.playCount = playCount
        self.isPlayed = isPlayed
        self.isLikes = isLikes
        self.playbackPositionTicks = playbackPositionTicks
        self.itemID = itemID
        self.lastPlayedDate = lastPlayedDate
        self.rating = rating
        self.key = key
        self.isFavorite = isFavorite
        self.playedPercentage = playedPercentage
    }

    private enum CodingKeys: String, CodingKey {
        case unplayedItemCount = "UnplayedItemCount"
        case playCount = "PlayCount"
        case isPlayed = "Played"
        case isLikes = "Likes"
        case playbackPositionTicks = "PlaybackPositionTicks"
        case itemID = "ItemId"
        case lastPlayedDate = "LastPlayedDate"
        case rating = "Rating"
        case key = "Key"
        case isFavorite = "IsFavorite"
        case playedPercentage = "PlayedPercentage"
    }
}

public enum MetadataField: String, Codable, CaseIterable {
    case cast = "Cast"
    case genres = "Genres"
    case productionLocations = "ProductionLocations"
    case studios = "Studios"
    case tags = "Tags"
    case name = "Name"
    case overview = "Overview"
    case runtime = "Runtime"
    case officialRating = "OfficialRating"
}

public struct SetChannelMappingDto: Codable {
    public var tunerChannelID: String
    public var providerChannelID: String
    public var providerID: String

    public init(tunerChannelID: String, providerChannelID: String, providerID: String) {
        self.tunerChannelID = tunerChannelID
        self.providerChannelID = providerChannelID
        self.providerID = providerID
    }

    private enum CodingKeys: String, CodingKey {
        case tunerChannelID = "TunerChannelId"
        case providerChannelID = "ProviderChannelId"
        case providerID = "ProviderId"
    }
}

public struct SessionInfo: Codable {
    public var deviceName: String?
    public var additionalUsers: [SessionUserInfo]?
    public var userID: UUID?
    public var nowPlayingItem: BaseItemDto?
    public var transcodingInfo: TranscodingInfo?
    public var userName: String?
    public var deviceType: String?
    public var nowViewingItem: BaseItemDto?
    public var serverID: String?
    public var id: String?
    public var lastPlaybackCheckIn: Date?
    public var applicationVersion: String?
    public var remoteEndPoint: String?
    public var supportedCommands: [GeneralCommandType]?
    public var isSupportsMediaControl: Bool?
    public var isSupportsRemoteControl: Bool?
    public var deviceID: String?
    public var isActive: Bool?
    public var playableMediaTypes: [String]?
    public var hasCustomDeviceName: Bool?
    public var capabilities: ClientCapabilities?
    public var nowPlayingQueue: [QueueItem]?
    public var userPrimaryImageTag: String?
    public var lastActivityDate: Date?
    public var fullNowPlayingItem: BaseItem?
    public var client: String?
    public var playlistItemID: String?
    public var playState: PlayerStateInfo?

    public init(deviceName: String? = nil, additionalUsers: [SessionUserInfo]? = nil, userID: UUID? = nil, nowPlayingItem: BaseItemDto? = nil, transcodingInfo: TranscodingInfo? = nil, userName: String? = nil, deviceType: String? = nil, nowViewingItem: BaseItemDto? = nil, serverID: String? = nil, id: String? = nil, lastPlaybackCheckIn: Date? = nil, applicationVersion: String? = nil, remoteEndPoint: String? = nil, supportedCommands: [GeneralCommandType]? = nil, isSupportsMediaControl: Bool? = nil, isSupportsRemoteControl: Bool? = nil, deviceID: String? = nil, isActive: Bool? = nil, playableMediaTypes: [String]? = nil, hasCustomDeviceName: Bool? = nil, capabilities: ClientCapabilities? = nil, nowPlayingQueue: [QueueItem]? = nil, userPrimaryImageTag: String? = nil, lastActivityDate: Date? = nil, fullNowPlayingItem: BaseItem? = nil, client: String? = nil, playlistItemID: String? = nil, playState: PlayerStateInfo? = nil) {
        self.deviceName = deviceName
        self.additionalUsers = additionalUsers
        self.userID = userID
        self.nowPlayingItem = nowPlayingItem
        self.transcodingInfo = transcodingInfo
        self.userName = userName
        self.deviceType = deviceType
        self.nowViewingItem = nowViewingItem
        self.serverID = serverID
        self.id = id
        self.lastPlaybackCheckIn = lastPlaybackCheckIn
        self.applicationVersion = applicationVersion
        self.remoteEndPoint = remoteEndPoint
        self.supportedCommands = supportedCommands
        self.isSupportsMediaControl = isSupportsMediaControl
        self.isSupportsRemoteControl = isSupportsRemoteControl
        self.deviceID = deviceID
        self.isActive = isActive
        self.playableMediaTypes = playableMediaTypes
        self.hasCustomDeviceName = hasCustomDeviceName
        self.capabilities = capabilities
        self.nowPlayingQueue = nowPlayingQueue
        self.userPrimaryImageTag = userPrimaryImageTag
        self.lastActivityDate = lastActivityDate
        self.fullNowPlayingItem = fullNowPlayingItem
        self.client = client
        self.playlistItemID = playlistItemID
        self.playState = playState
    }

    private enum CodingKeys: String, CodingKey {
        case deviceName = "DeviceName"
        case additionalUsers = "AdditionalUsers"
        case userID = "UserId"
        case nowPlayingItem = "NowPlayingItem"
        case transcodingInfo = "TranscodingInfo"
        case userName = "UserName"
        case deviceType = "DeviceType"
        case nowViewingItem = "NowViewingItem"
        case serverID = "ServerId"
        case id = "Id"
        case lastPlaybackCheckIn = "LastPlaybackCheckIn"
        case applicationVersion = "ApplicationVersion"
        case remoteEndPoint = "RemoteEndPoint"
        case supportedCommands = "SupportedCommands"
        case isSupportsMediaControl = "SupportsMediaControl"
        case isSupportsRemoteControl = "SupportsRemoteControl"
        case deviceID = "DeviceId"
        case isActive = "IsActive"
        case playableMediaTypes = "PlayableMediaTypes"
        case hasCustomDeviceName = "HasCustomDeviceName"
        case capabilities = "Capabilities"
        case nowPlayingQueue = "NowPlayingQueue"
        case userPrimaryImageTag = "UserPrimaryImageTag"
        case lastActivityDate = "LastActivityDate"
        case fullNowPlayingItem = "FullNowPlayingItem"
        case client = "Client"
        case playlistItemID = "PlaylistItemId"
        case playState = "PlayState"
    }
}

public struct PlaybackStartInfo: Codable {
    public var liveStreamID: String?
    public var item: BaseItemDto?
    public var mediaSourceID: String?
    public var subtitleStreamIndex: Int?
    public var playbackStartTimeTicks: Int?
    public var playlistItemID: String?
    public var itemID: UUID?
    public var isPaused: Bool?
    public var volumeLevel: Int?
    public var isMuted: Bool?
    public var audioStreamIndex: Int?
    public var positionTicks: Int?
    public var aspectRatio: String?
    public var repeatMode: RepeatMode?
    public var nowPlayingQueue: [QueueItem]?
    public var playSessionID: String?
    public var brightness: Int?
    public var playMethod: PlayMethod?
    public var sessionID: String?
    public var canSeek: Bool?

    public init(liveStreamID: String? = nil, item: BaseItemDto? = nil, mediaSourceID: String? = nil, subtitleStreamIndex: Int? = nil, playbackStartTimeTicks: Int? = nil, playlistItemID: String? = nil, itemID: UUID? = nil, isPaused: Bool? = nil, volumeLevel: Int? = nil, isMuted: Bool? = nil, audioStreamIndex: Int? = nil, positionTicks: Int? = nil, aspectRatio: String? = nil, repeatMode: RepeatMode? = nil, nowPlayingQueue: [QueueItem]? = nil, playSessionID: String? = nil, brightness: Int? = nil, playMethod: PlayMethod? = nil, sessionID: String? = nil, canSeek: Bool? = nil) {
        self.liveStreamID = liveStreamID
        self.item = item
        self.mediaSourceID = mediaSourceID
        self.subtitleStreamIndex = subtitleStreamIndex
        self.playbackStartTimeTicks = playbackStartTimeTicks
        self.playlistItemID = playlistItemID
        self.itemID = itemID
        self.isPaused = isPaused
        self.volumeLevel = volumeLevel
        self.isMuted = isMuted
        self.audioStreamIndex = audioStreamIndex
        self.positionTicks = positionTicks
        self.aspectRatio = aspectRatio
        self.repeatMode = repeatMode
        self.nowPlayingQueue = nowPlayingQueue
        self.playSessionID = playSessionID
        self.brightness = brightness
        self.playMethod = playMethod
        self.sessionID = sessionID
        self.canSeek = canSeek
    }

    private enum CodingKeys: String, CodingKey {
        case liveStreamID = "LiveStreamId"
        case item = "Item"
        case mediaSourceID = "MediaSourceId"
        case subtitleStreamIndex = "SubtitleStreamIndex"
        case playbackStartTimeTicks = "PlaybackStartTimeTicks"
        case playlistItemID = "PlaylistItemId"
        case itemID = "ItemId"
        case isPaused = "IsPaused"
        case volumeLevel = "VolumeLevel"
        case isMuted = "IsMuted"
        case audioStreamIndex = "AudioStreamIndex"
        case positionTicks = "PositionTicks"
        case aspectRatio = "AspectRatio"
        case repeatMode = "RepeatMode"
        case nowPlayingQueue = "NowPlayingQueue"
        case playSessionID = "PlaySessionId"
        case brightness = "Brightness"
        case playMethod = "PlayMethod"
        case sessionID = "SessionId"
        case canSeek = "CanSeek"
    }
}

public struct MediaEncoderPathDto: Codable {
    public var pathType: String?
    public var path: String?

    public init(pathType: String? = nil, path: String? = nil) {
        self.pathType = pathType
        self.path = path
    }

    private enum CodingKeys: String, CodingKey {
        case pathType = "PathType"
        case path = "Path"
    }
}

public enum SeriesStatus: String, Codable, CaseIterable {
    case continuing = "Continuing"
    case ended = "Ended"
}

public enum MediaProtocol: String, Codable, CaseIterable {
    case file = "File"
    case http = "Http"
    case rtmp = "Rtmp"
    case rtsp = "Rtsp"
    case udp = "Udp"
    case rtp = "Rtp"
    case ftp = "Ftp"
}

public struct ImageByNameInfo: Codable {
    public var format: String?
    public var fileLength: Int?
    public var theme: String?
    public var name: String?
    public var context: String?

    public init(format: String? = nil, fileLength: Int? = nil, theme: String? = nil, name: String? = nil, context: String? = nil) {
        self.format = format
        self.fileLength = fileLength
        self.theme = theme
        self.name = name
        self.context = context
    }

    private enum CodingKeys: String, CodingKey {
        case format = "Format"
        case fileLength = "FileLength"
        case theme = "Theme"
        case name = "Name"
        case context = "Context"
    }
}

public struct VersionInfo: Codable {
    public var repositoryName: String?
    public var version: String?
    public var sourceURL: String?
    public var changelog: String?
    public var repositoryURL: String?
    public var timestamp: String?
    public var targetAbi: String?
    public var versionNumber: Version?
    public var checksum: String?

    public init(repositoryName: String? = nil, version: String? = nil, sourceURL: String? = nil, changelog: String? = nil, repositoryURL: String? = nil, timestamp: String? = nil, targetAbi: String? = nil, versionNumber: Version? = nil, checksum: String? = nil) {
        self.repositoryName = repositoryName
        self.version = version
        self.sourceURL = sourceURL
        self.changelog = changelog
        self.repositoryURL = repositoryURL
        self.timestamp = timestamp
        self.targetAbi = targetAbi
        self.versionNumber = versionNumber
        self.checksum = checksum
    }

    private enum CodingKeys: String, CodingKey {
        case repositoryName
        case version
        case sourceURL = "sourceUrl"
        case changelog
        case repositoryURL = "repositoryUrl"
        case timestamp
        case targetAbi
        case versionNumber = "VersionNumber"
        case checksum
    }
}

public enum CollectionTypeOptions: String, Codable, CaseIterable {
    case movies = "Movies"
    case tvShows = "TvShows"
    case music = "Music"
    case musicVideos = "MusicVideos"
    case homeVideos = "HomeVideos"
    case boxSets = "BoxSets"
    case books = "Books"
    case mixed = "Mixed"
}

public enum PlayAccess: String, Codable, CaseIterable {
    case full = "Full"
    case `none` = "None"
}

public struct RepositoryInfo: Codable {
    public var url: String?
    public var isEnabled: Bool?
    public var name: String?

    public init(url: String? = nil, isEnabled: Bool? = nil, name: String? = nil) {
        self.url = url
        self.isEnabled = isEnabled
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case url = "Url"
        case isEnabled = "Enabled"
        case name = "Name"
    }
}

public struct BookInfoRemoteSearchQuery: Codable {
    public var searchInfo: BookInfo?
    public var searchProviderName: String?
    public var itemID: UUID?
    public var isIncludeDisabledProviders: Bool?

    public init(searchInfo: BookInfo? = nil, searchProviderName: String? = nil, itemID: UUID? = nil, isIncludeDisabledProviders: Bool? = nil) {
        self.searchInfo = searchInfo
        self.searchProviderName = searchProviderName
        self.itemID = itemID
        self.isIncludeDisabledProviders = isIncludeDisabledProviders
    }

    private enum CodingKeys: String, CodingKey {
        case searchInfo = "SearchInfo"
        case searchProviderName = "SearchProviderName"
        case itemID = "ItemId"
        case isIncludeDisabledProviders = "IncludeDisabledProviders"
    }
}

public enum SendCommandType: String, Codable, CaseIterable {
    case unpause = "Unpause"
    case pause = "Pause"
    case stop = "Stop"
    case seek = "Seek"
}

public enum PlaybackErrorCode: String, Codable, CaseIterable {
    case notAllowed = "NotAllowed"
    case noCompatibleStream = "NoCompatibleStream"
    case rateLimitExceeded = "RateLimitExceeded"
}

public struct ArtistInfo: Codable {
    public var metadataCountryCode: String?
    public var providerIDs: [String: String]?
    public var year: Int?
    public var isAutomated: Bool?
    public var parentIndexNumber: Int?
    public var indexNumber: Int?
    public var songInfos: [SongInfo]?
    public var name: String?
    public var premiereDate: Date?
    public var metadataLanguage: String?
    public var path: String?

    public init(metadataCountryCode: String? = nil, providerIDs: [String: String]? = nil, year: Int? = nil, isAutomated: Bool? = nil, parentIndexNumber: Int? = nil, indexNumber: Int? = nil, songInfos: [SongInfo]? = nil, name: String? = nil, premiereDate: Date? = nil, metadataLanguage: String? = nil, path: String? = nil) {
        self.metadataCountryCode = metadataCountryCode
        self.providerIDs = providerIDs
        self.year = year
        self.isAutomated = isAutomated
        self.parentIndexNumber = parentIndexNumber
        self.indexNumber = indexNumber
        self.songInfos = songInfos
        self.name = name
        self.premiereDate = premiereDate
        self.metadataLanguage = metadataLanguage
        self.path = path
    }

    private enum CodingKeys: String, CodingKey {
        case metadataCountryCode = "MetadataCountryCode"
        case providerIDs = "ProviderIds"
        case year = "Year"
        case isAutomated = "IsAutomated"
        case parentIndexNumber = "ParentIndexNumber"
        case indexNumber = "IndexNumber"
        case songInfos = "SongInfos"
        case name = "Name"
        case premiereDate = "PremiereDate"
        case metadataLanguage = "MetadataLanguage"
        case path = "Path"
    }
}

public struct ReadyRequestDto: Codable {
    public var when: Date?
    public var isPlaying: Bool?
    public var positionTicks: Int?
    public var playlistItemID: UUID?

    public init(when: Date? = nil, isPlaying: Bool? = nil, positionTicks: Int? = nil, playlistItemID: UUID? = nil) {
        self.when = when
        self.isPlaying = isPlaying
        self.positionTicks = positionTicks
        self.playlistItemID = playlistItemID
    }

    private enum CodingKeys: String, CodingKey {
        case when = "When"
        case isPlaying = "IsPlaying"
        case positionTicks = "PositionTicks"
        case playlistItemID = "PlaylistItemId"
    }
}

public enum ProgramAudio: String, Codable, CaseIterable {
    case mono = "Mono"
    case stereo = "Stereo"
    case dolby = "Dolby"
    case dolbyDigital = "DolbyDigital"
    case thx = "Thx"
    case atmos = "Atmos"
}

public struct LocalizationOption: Codable {
    public var name: String?
    public var value: String?

    public init(name: String? = nil, value: String? = nil) {
        self.name = name
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }
}

public struct PingRequestDto: Codable {
    public var ping: Int?

    public init(ping: Int? = nil) {
        self.ping = ping
    }

    private enum CodingKeys: String, CodingKey {
        case ping = "Ping"
    }
}

public struct NotificationResultDto: Codable {
    public var totalRecordCount: Int?
    public var notifications: [NotificationDto]?

    public init(totalRecordCount: Int? = nil, notifications: [NotificationDto]? = nil) {
        self.totalRecordCount = totalRecordCount
        self.notifications = notifications
    }

    private enum CodingKeys: String, CodingKey {
        case totalRecordCount = "TotalRecordCount"
        case notifications = "Notifications"
    }
}

public struct BoxSetInfo: Codable {
    public var isAutomated: Bool?
    public var path: String?
    public var indexNumber: Int?
    public var metadataLanguage: String?
    public var providerIDs: [String: String]?
    public var premiereDate: Date?
    public var metadataCountryCode: String?
    public var name: String?
    public var parentIndexNumber: Int?
    public var year: Int?

    public init(isAutomated: Bool? = nil, path: String? = nil, indexNumber: Int? = nil, metadataLanguage: String? = nil, providerIDs: [String: String]? = nil, premiereDate: Date? = nil, metadataCountryCode: String? = nil, name: String? = nil, parentIndexNumber: Int? = nil, year: Int? = nil) {
        self.isAutomated = isAutomated
        self.path = path
        self.indexNumber = indexNumber
        self.metadataLanguage = metadataLanguage
        self.providerIDs = providerIDs
        self.premiereDate = premiereDate
        self.metadataCountryCode = metadataCountryCode
        self.name = name
        self.parentIndexNumber = parentIndexNumber
        self.year = year
    }

    private enum CodingKeys: String, CodingKey {
        case isAutomated = "IsAutomated"
        case path = "Path"
        case indexNumber = "IndexNumber"
        case metadataLanguage = "MetadataLanguage"
        case providerIDs = "ProviderIds"
        case premiereDate = "PremiereDate"
        case metadataCountryCode = "MetadataCountryCode"
        case name = "Name"
        case parentIndexNumber = "ParentIndexNumber"
        case year = "Year"
    }
}

public struct InstallationInfo: Codable {
    public var guid: UUID?
    public var version: Version?
    public var name: String?
    public var changelog: String?
    public var sourceURL: String?
    public var checksum: String?
    public var packageInfo: PackageInfo?

    public init(guid: UUID? = nil, version: Version? = nil, name: String? = nil, changelog: String? = nil, sourceURL: String? = nil, checksum: String? = nil, packageInfo: PackageInfo? = nil) {
        self.guid = guid
        self.version = version
        self.name = name
        self.changelog = changelog
        self.sourceURL = sourceURL
        self.checksum = checksum
        self.packageInfo = packageInfo
    }

    private enum CodingKeys: String, CodingKey {
        case guid = "Guid"
        case version = "Version"
        case name = "Name"
        case changelog = "Changelog"
        case sourceURL = "SourceUrl"
        case checksum = "Checksum"
        case packageInfo = "PackageInfo"
    }
}

public enum Video3DFormat: String, Codable, CaseIterable {
    case halfSideBySide = "HalfSideBySide"
    case fullSideBySide = "FullSideBySide"
    case fullTopAndBottom = "FullTopAndBottom"
    case halfTopAndBottom = "HalfTopAndBottom"
    case mvc = "MVC"
}

public enum ImageSavingConvention: String, Codable, CaseIterable {
    case legacy = "Legacy"
    case compatible = "Compatible"
}

public struct OpenLiveStreamDto: Codable {
    public var audioStreamIndex: Int?
    public var directPlayProtocols: [MediaProtocol]?
    public var openToken: String?
    public var playSessionID: String?
    public var enableDirectPlay: Bool?
    public var itemID: UUID?
    public var userID: UUID?
    public var enableDirectStream: Bool?
    public var maxStreamingBitrate: Int?
    public var maxAudioChannels: Int?
    public var deviceProfile: DeviceProfile?
    public var subtitleStreamIndex: Int?
    public var startTimeTicks: Int?

    public init(audioStreamIndex: Int? = nil, directPlayProtocols: [MediaProtocol]? = nil, openToken: String? = nil, playSessionID: String? = nil, enableDirectPlay: Bool? = nil, itemID: UUID? = nil, userID: UUID? = nil, enableDirectStream: Bool? = nil, maxStreamingBitrate: Int? = nil, maxAudioChannels: Int? = nil, deviceProfile: DeviceProfile? = nil, subtitleStreamIndex: Int? = nil, startTimeTicks: Int? = nil) {
        self.audioStreamIndex = audioStreamIndex
        self.directPlayProtocols = directPlayProtocols
        self.openToken = openToken
        self.playSessionID = playSessionID
        self.enableDirectPlay = enableDirectPlay
        self.itemID = itemID
        self.userID = userID
        self.enableDirectStream = enableDirectStream
        self.maxStreamingBitrate = maxStreamingBitrate
        self.maxAudioChannels = maxAudioChannels
        self.deviceProfile = deviceProfile
        self.subtitleStreamIndex = subtitleStreamIndex
        self.startTimeTicks = startTimeTicks
    }

    private enum CodingKeys: String, CodingKey {
        case audioStreamIndex = "AudioStreamIndex"
        case directPlayProtocols = "DirectPlayProtocols"
        case openToken = "OpenToken"
        case playSessionID = "PlaySessionId"
        case enableDirectPlay = "EnableDirectPlay"
        case itemID = "ItemId"
        case userID = "UserId"
        case enableDirectStream = "EnableDirectStream"
        case maxStreamingBitrate = "MaxStreamingBitrate"
        case maxAudioChannels = "MaxAudioChannels"
        case deviceProfile = "DeviceProfile"
        case subtitleStreamIndex = "SubtitleStreamIndex"
        case startTimeTicks = "StartTimeTicks"
    }
}

public struct LibraryOptionInfoDto: Codable {
    public var name: String?
    public var isDefaultEnabled: Bool?

    public init(name: String? = nil, isDefaultEnabled: Bool? = nil) {
        self.name = name
        self.isDefaultEnabled = isDefaultEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case isDefaultEnabled = "DefaultEnabled"
    }
}

public enum KeepUntil: String, Codable, CaseIterable {
    case untilDeleted = "UntilDeleted"
    case untilSpaceNeeded = "UntilSpaceNeeded"
    case untilWatched = "UntilWatched"
    case untilDate = "UntilDate"
}

public struct SetShuffleModeRequestDto: Codable {
    public var mode: GroupShuffleMode?

    public init(mode: GroupShuffleMode? = nil) {
        self.mode = mode
    }

    private enum CodingKeys: String, CodingKey {
        case mode = "Mode"
    }
}

public enum PlayMethod: String, Codable, CaseIterable {
    case transcode = "Transcode"
    case directStream = "DirectStream"
    case directPlay = "DirectPlay"
}

public struct TranscodingInfo: Codable {
    public var isAudioDirect: Bool?
    public var audioCodec: String?
    public var height: Int?
    public var videoCodec: String?
    public var width: Int?
    public var bitrate: Int?
    public var framerate: Double?
    public var isVideoDirect: Bool?
    public var container: String?
    public var transcodeReasons: [TranscodeReason]?
    public var audioChannels: Int?
    public var completionPercentage: Double?

    public init(isAudioDirect: Bool? = nil, audioCodec: String? = nil, height: Int? = nil, videoCodec: String? = nil, width: Int? = nil, bitrate: Int? = nil, framerate: Double? = nil, isVideoDirect: Bool? = nil, container: String? = nil, transcodeReasons: [TranscodeReason]? = nil, audioChannels: Int? = nil, completionPercentage: Double? = nil) {
        self.isAudioDirect = isAudioDirect
        self.audioCodec = audioCodec
        self.height = height
        self.videoCodec = videoCodec
        self.width = width
        self.bitrate = bitrate
        self.framerate = framerate
        self.isVideoDirect = isVideoDirect
        self.container = container
        self.transcodeReasons = transcodeReasons
        self.audioChannels = audioChannels
        self.completionPercentage = completionPercentage
    }

    private enum CodingKeys: String, CodingKey {
        case isAudioDirect = "IsAudioDirect"
        case audioCodec = "AudioCodec"
        case height = "Height"
        case videoCodec = "VideoCodec"
        case width = "Width"
        case bitrate = "Bitrate"
        case framerate = "Framerate"
        case isVideoDirect = "IsVideoDirect"
        case container = "Container"
        case transcodeReasons = "TranscodeReasons"
        case audioChannels = "AudioChannels"
        case completionPercentage = "CompletionPercentage"
    }
}

public enum QuickConnectState: String, Codable, CaseIterable {
    case unavailable = "Unavailable"
    case available = "Available"
    case active = "Active"
}

public struct TimerEventInfo: Codable {
    public var id: String?
    public var programID: UUID?

    public init(id: String? = nil, programID: UUID? = nil) {
        self.id = id
        self.programID = programID
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case programID = "ProgramId"
    }
}

public struct SeekRequestDto: Codable {
    public var positionTicks: Int?

    public init(positionTicks: Int? = nil) {
        self.positionTicks = positionTicks
    }

    private enum CodingKeys: String, CodingKey {
        case positionTicks = "PositionTicks"
    }
}

public struct DefaultDirectoryBrowserInfoDto: Codable {
    public var path: String?

    public init(path: String? = nil) {
        self.path = path
    }

    private enum CodingKeys: String, CodingKey {
        case path = "Path"
    }
}

public struct ActivityLogEntryQueryResult: Codable {
    public var startIndex: Int?
    public var totalRecordCount: Int?
    public var items: [ActivityLogEntry]?

    public init(startIndex: Int? = nil, totalRecordCount: Int? = nil, items: [ActivityLogEntry]? = nil) {
        self.startIndex = startIndex
        self.totalRecordCount = totalRecordCount
        self.items = items
    }

    private enum CodingKeys: String, CodingKey {
        case startIndex = "StartIndex"
        case totalRecordCount = "TotalRecordCount"
        case items = "Items"
    }
}

public struct NameGuidPair: Codable {
    public var id: UUID?
    public var name: String?

    public init(id: UUID? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
    }
}

public struct PlayRequest: Codable {
    public var playCommand: PlayCommand?
    public var controllingUserID: UUID?
    public var startPositionTicks: Int?
    public var mediaSourceID: String?
    public var subtitleStreamIndex: Int?
    public var audioStreamIndex: Int?
    public var startIndex: Int?
    public var itemIDs: [UUID]?

    public init(playCommand: PlayCommand? = nil, controllingUserID: UUID? = nil, startPositionTicks: Int? = nil, mediaSourceID: String? = nil, subtitleStreamIndex: Int? = nil, audioStreamIndex: Int? = nil, startIndex: Int? = nil, itemIDs: [UUID]? = nil) {
        self.playCommand = playCommand
        self.controllingUserID = controllingUserID
        self.startPositionTicks = startPositionTicks
        self.mediaSourceID = mediaSourceID
        self.subtitleStreamIndex = subtitleStreamIndex
        self.audioStreamIndex = audioStreamIndex
        self.startIndex = startIndex
        self.itemIDs = itemIDs
    }

    private enum CodingKeys: String, CodingKey {
        case playCommand = "PlayCommand"
        case controllingUserID = "ControllingUserId"
        case startPositionTicks = "StartPositionTicks"
        case mediaSourceID = "MediaSourceId"
        case subtitleStreamIndex = "SubtitleStreamIndex"
        case audioStreamIndex = "AudioStreamIndex"
        case startIndex = "StartIndex"
        case itemIDs = "ItemIds"
    }
}

public struct NotificationDto: Codable {
    public var url: String?
    public var name: String?
    public var id: String?
    public var isRead: Bool?
    public var description: String?
    public var level: NotificationLevel?
    public var date: Date?
    public var userID: String?

    public init(url: String? = nil, name: String? = nil, id: String? = nil, isRead: Bool? = nil, description: String? = nil, level: NotificationLevel? = nil, date: Date? = nil, userID: String? = nil) {
        self.url = url
        self.name = name
        self.id = id
        self.isRead = isRead
        self.description = description
        self.level = level
        self.date = date
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case url = "Url"
        case name = "Name"
        case id = "Id"
        case isRead = "IsRead"
        case description = "Description"
        case level = "Level"
        case date = "Date"
        case userID = "UserId"
    }
}

public struct GetProgramsDto: Codable {
    public var enableUserData: Bool?
    public var fields: [ItemFields]?
    public var minStartDate: Date?
    public var channelIDs: [UUID]?
    public var imageTypeLimit: Int?
    public var librarySeriesID: UUID?
    public var enableImageTypes: [ImageType]?
    public var startIndex: Int?
    public var isAiring: Bool?
    public var userID: UUID?
    public var genreIDs: [UUID]?
    public var isSports: Bool?
    public var maxStartDate: Date?
    public var genres: [String]?
    public var isSeries: Bool?
    public var isKids: Bool?
    public var enableImages: Bool?
    public var sortOrder: [SortOrder]?
    public var limit: Int?
    public var hasAired: Bool?
    public var minEndDate: Date?
    public var maxEndDate: Date?
    public var sortBy: [String]?
    public var isNews: Bool?
    public var enableTotalRecordCount: Bool?
    public var seriesTimerID: String?
    public var isMovie: Bool?

    public init(enableUserData: Bool? = nil, fields: [ItemFields]? = nil, minStartDate: Date? = nil, channelIDs: [UUID]? = nil, imageTypeLimit: Int? = nil, librarySeriesID: UUID? = nil, enableImageTypes: [ImageType]? = nil, startIndex: Int? = nil, isAiring: Bool? = nil, userID: UUID? = nil, genreIDs: [UUID]? = nil, isSports: Bool? = nil, maxStartDate: Date? = nil, genres: [String]? = nil, isSeries: Bool? = nil, isKids: Bool? = nil, enableImages: Bool? = nil, sortOrder: [SortOrder]? = nil, limit: Int? = nil, hasAired: Bool? = nil, minEndDate: Date? = nil, maxEndDate: Date? = nil, sortBy: [String]? = nil, isNews: Bool? = nil, enableTotalRecordCount: Bool? = nil, seriesTimerID: String? = nil, isMovie: Bool? = nil) {
        self.enableUserData = enableUserData
        self.fields = fields
        self.minStartDate = minStartDate
        self.channelIDs = channelIDs
        self.imageTypeLimit = imageTypeLimit
        self.librarySeriesID = librarySeriesID
        self.enableImageTypes = enableImageTypes
        self.startIndex = startIndex
        self.isAiring = isAiring
        self.userID = userID
        self.genreIDs = genreIDs
        self.isSports = isSports
        self.maxStartDate = maxStartDate
        self.genres = genres
        self.isSeries = isSeries
        self.isKids = isKids
        self.enableImages = enableImages
        self.sortOrder = sortOrder
        self.limit = limit
        self.hasAired = hasAired
        self.minEndDate = minEndDate
        self.maxEndDate = maxEndDate
        self.sortBy = sortBy
        self.isNews = isNews
        self.enableTotalRecordCount = enableTotalRecordCount
        self.seriesTimerID = seriesTimerID
        self.isMovie = isMovie
    }

    private enum CodingKeys: String, CodingKey {
        case enableUserData = "EnableUserData"
        case fields = "Fields"
        case minStartDate = "MinStartDate"
        case channelIDs = "ChannelIds"
        case imageTypeLimit = "ImageTypeLimit"
        case librarySeriesID = "LibrarySeriesId"
        case enableImageTypes = "EnableImageTypes"
        case startIndex = "StartIndex"
        case isAiring = "IsAiring"
        case userID = "UserId"
        case genreIDs = "GenreIds"
        case isSports = "IsSports"
        case maxStartDate = "MaxStartDate"
        case genres = "Genres"
        case isSeries = "IsSeries"
        case isKids = "IsKids"
        case enableImages = "EnableImages"
        case sortOrder = "SortOrder"
        case limit = "Limit"
        case hasAired = "HasAired"
        case minEndDate = "MinEndDate"
        case maxEndDate = "MaxEndDate"
        case sortBy = "SortBy"
        case isNews = "IsNews"
        case enableTotalRecordCount = "EnableTotalRecordCount"
        case seriesTimerID = "SeriesTimerId"
        case isMovie = "IsMovie"
    }
}

public enum DayPattern: String, Codable, CaseIterable {
    case daily = "Daily"
    case weekdays = "Weekdays"
    case weekends = "Weekends"
}

public struct QuickConnectDto: Codable {
    public var token: String

    public init(token: String) {
        self.token = token
    }

    private enum CodingKeys: String, CodingKey {
        case token = "Token"
    }
}

public struct ConfigurationPageInfo: Codable {
    public var configurationPageType: ConfigurationPageType?
    public var menuSection: String?
    public var pluginID: UUID?
    public var name: String?
    public var enableInMainMenu: Bool?
    public var menuIcon: String?
    public var displayName: String?

    public init(configurationPageType: ConfigurationPageType? = nil, menuSection: String? = nil, pluginID: UUID? = nil, name: String? = nil, enableInMainMenu: Bool? = nil, menuIcon: String? = nil, displayName: String? = nil) {
        self.configurationPageType = configurationPageType
        self.menuSection = menuSection
        self.pluginID = pluginID
        self.name = name
        self.enableInMainMenu = enableInMainMenu
        self.menuIcon = menuIcon
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case configurationPageType = "ConfigurationPageType"
        case menuSection = "MenuSection"
        case pluginID = "PluginId"
        case name = "Name"
        case enableInMainMenu = "EnableInMainMenu"
        case menuIcon = "MenuIcon"
        case displayName = "DisplayName"
    }
}

public struct ControlResponse: Codable {
    public var headers: [String: String]?
    public var isSuccessful: Bool?
    public var xml: String?

    public init(headers: [String: String]? = nil, isSuccessful: Bool? = nil, xml: String? = nil) {
        self.headers = headers
        self.isSuccessful = isSuccessful
        self.xml = xml
    }

    private enum CodingKeys: String, CodingKey {
        case headers = "Headers"
        case isSuccessful = "IsSuccessful"
        case xml = "Xml"
    }
}

public enum DynamicDayOfWeek: String, Codable, CaseIterable {
    case sunday = "Sunday"
    case monday = "Monday"
    case tuesday = "Tuesday"
    case wednesday = "Wednesday"
    case thursday = "Thursday"
    case friday = "Friday"
    case saturday = "Saturday"
    case everyday = "Everyday"
    case weekday = "Weekday"
    case weekend = "Weekend"
}

public struct IPlugin: Codable {
    public var dataFolderPath: String?
    public var name: String?
    public var assemblyFilePath: String?
    public var description: String?
    public var id: UUID?
    public var canUninstall: Bool?
    public var version: Version?

    public init(dataFolderPath: String? = nil, name: String? = nil, assemblyFilePath: String? = nil, description: String? = nil, id: UUID? = nil, canUninstall: Bool? = nil, version: Version? = nil) {
        self.dataFolderPath = dataFolderPath
        self.name = name
        self.assemblyFilePath = assemblyFilePath
        self.description = description
        self.id = id
        self.canUninstall = canUninstall
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case dataFolderPath = "DataFolderPath"
        case name = "Name"
        case assemblyFilePath = "AssemblyFilePath"
        case description = "Description"
        case id = "Id"
        case canUninstall = "CanUninstall"
        case version = "Version"
    }
}

public enum LiveTvServiceStatus: String, Codable, CaseIterable {
    case ok = "Ok"
    case unavailable = "Unavailable"
}

public struct SeriesInfoRemoteSearchQuery: Codable {
    public var isIncludeDisabledProviders: Bool?
    public var searchInfo: SeriesInfo?
    public var itemID: UUID?
    public var searchProviderName: String?

    public init(isIncludeDisabledProviders: Bool? = nil, searchInfo: SeriesInfo? = nil, itemID: UUID? = nil, searchProviderName: String? = nil) {
        self.isIncludeDisabledProviders = isIncludeDisabledProviders
        self.searchInfo = searchInfo
        self.itemID = itemID
        self.searchProviderName = searchProviderName
    }

    private enum CodingKeys: String, CodingKey {
        case isIncludeDisabledProviders = "IncludeDisabledProviders"
        case searchInfo = "SearchInfo"
        case itemID = "ItemId"
        case searchProviderName = "SearchProviderName"
    }
}

public struct CreatePlaylistDto: Codable {
    public var name: String?
    public var mediaType: String?
    public var ids: [UUID]?
    public var userID: UUID?

    public init(name: String? = nil, mediaType: String? = nil, ids: [UUID]? = nil, userID: UUID? = nil) {
        self.name = name
        self.mediaType = mediaType
        self.ids = ids
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case mediaType = "MediaType"
        case ids = "Ids"
        case userID = "UserId"
    }
}

public struct AuthenticationInfoQueryResult: Codable {
    public var startIndex: Int?
    public var totalRecordCount: Int?
    public var items: [AuthenticationInfo]?

    public init(startIndex: Int? = nil, totalRecordCount: Int? = nil, items: [AuthenticationInfo]? = nil) {
        self.startIndex = startIndex
        self.totalRecordCount = totalRecordCount
        self.items = items
    }

    private enum CodingKeys: String, CodingKey {
        case startIndex = "StartIndex"
        case totalRecordCount = "TotalRecordCount"
        case items = "Items"
    }
}

public struct ListingsProviderInfo: Codable {
    public var movieCategories: [String]?
    public var zipCode: String?
    public var channelMappings: [NameValuePair]?
    public var password: String?
    public var country: String?
    public var preferredLanguage: String?
    public var type: String?
    public var path: String?
    public var id: String?
    public var userAgent: String?
    public var enabledTuners: [String]?
    public var listingsID: String?
    public var sportsCategories: [String]?
    public var moviePrefix: String?
    public var kidsCategories: [String]?
    public var username: String?
    public var newsCategories: [String]?
    public var enableAllTuners: Bool?

    public init(movieCategories: [String]? = nil, zipCode: String? = nil, channelMappings: [NameValuePair]? = nil, password: String? = nil, country: String? = nil, preferredLanguage: String? = nil, type: String? = nil, path: String? = nil, id: String? = nil, userAgent: String? = nil, enabledTuners: [String]? = nil, listingsID: String? = nil, sportsCategories: [String]? = nil, moviePrefix: String? = nil, kidsCategories: [String]? = nil, username: String? = nil, newsCategories: [String]? = nil, enableAllTuners: Bool? = nil) {
        self.movieCategories = movieCategories
        self.zipCode = zipCode
        self.channelMappings = channelMappings
        self.password = password
        self.country = country
        self.preferredLanguage = preferredLanguage
        self.type = type
        self.path = path
        self.id = id
        self.userAgent = userAgent
        self.enabledTuners = enabledTuners
        self.listingsID = listingsID
        self.sportsCategories = sportsCategories
        self.moviePrefix = moviePrefix
        self.kidsCategories = kidsCategories
        self.username = username
        self.newsCategories = newsCategories
        self.enableAllTuners = enableAllTuners
    }

    private enum CodingKeys: String, CodingKey {
        case movieCategories = "MovieCategories"
        case zipCode = "ZipCode"
        case channelMappings = "ChannelMappings"
        case password = "Password"
        case country = "Country"
        case preferredLanguage = "PreferredLanguage"
        case type = "Type"
        case path = "Path"
        case id = "Id"
        case userAgent = "UserAgent"
        case enabledTuners = "EnabledTuners"
        case listingsID = "ListingsId"
        case sportsCategories = "SportsCategories"
        case moviePrefix = "MoviePrefix"
        case kidsCategories = "KidsCategories"
        case username = "Username"
        case newsCategories = "NewsCategories"
        case enableAllTuners = "EnableAllTuners"
    }
}

public struct PlayerStateInfo: Codable {
    public var isPaused: Bool?
    public var repeatMode: RepeatMode?
    public var mediaSourceID: String?
    public var volumeLevel: Int?
    public var isMuted: Bool?
    public var canSeek: Bool?
    public var positionTicks: Int?
    public var audioStreamIndex: Int?
    public var subtitleStreamIndex: Int?
    public var playMethod: PlayMethod?

    public init(isPaused: Bool? = nil, repeatMode: RepeatMode? = nil, mediaSourceID: String? = nil, volumeLevel: Int? = nil, isMuted: Bool? = nil, canSeek: Bool? = nil, positionTicks: Int? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, playMethod: PlayMethod? = nil) {
        self.isPaused = isPaused
        self.repeatMode = repeatMode
        self.mediaSourceID = mediaSourceID
        self.volumeLevel = volumeLevel
        self.isMuted = isMuted
        self.canSeek = canSeek
        self.positionTicks = positionTicks
        self.audioStreamIndex = audioStreamIndex
        self.subtitleStreamIndex = subtitleStreamIndex
        self.playMethod = playMethod
    }

    private enum CodingKeys: String, CodingKey {
        case isPaused = "IsPaused"
        case repeatMode = "RepeatMode"
        case mediaSourceID = "MediaSourceId"
        case volumeLevel = "VolumeLevel"
        case isMuted = "IsMuted"
        case canSeek = "CanSeek"
        case positionTicks = "PositionTicks"
        case audioStreamIndex = "AudioStreamIndex"
        case subtitleStreamIndex = "SubtitleStreamIndex"
        case playMethod = "PlayMethod"
    }
}

public struct ServerDiscoveryInfo: Codable {
    public var address: String?
    public var endpointAddress: String?
    public var id: String?
    public var name: String?

    public init(address: String? = nil, endpointAddress: String? = nil, id: String? = nil, name: String? = nil) {
        self.address = address
        self.endpointAddress = endpointAddress
        self.id = id
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case address = "Address"
        case endpointAddress = "EndpointAddress"
        case id = "Id"
        case name = "Name"
    }
}

public struct TranscodingProfile: Codable {
    public var enableMpegtsM2TsMode: Bool?
    public var maxAudioChannels: String?
    public var audioCodec: String?
    public var container: String?
    public var videoCodec: String?
    public var minSegments: Int?
    public var enableSubtitlesInManifest: Bool?
    public var isEstimateContentLength: Bool?
    public var `protocol`: String?
    public var type: DlnaProfileType?
    public var transcodeSeekInfo: TranscodeSeekInfo?
    public var isBreakOnNonKeyFrames: Bool?
    public var context: EncodingContext?
    public var isCopyTimestamps: Bool?
    public var segmentLength: Int?

    public init(enableMpegtsM2TsMode: Bool? = nil, maxAudioChannels: String? = nil, audioCodec: String? = nil, container: String? = nil, videoCodec: String? = nil, minSegments: Int? = nil, enableSubtitlesInManifest: Bool? = nil, isEstimateContentLength: Bool? = nil, `protocol`: String? = nil, type: DlnaProfileType? = nil, transcodeSeekInfo: TranscodeSeekInfo? = nil, isBreakOnNonKeyFrames: Bool? = nil, context: EncodingContext? = nil, isCopyTimestamps: Bool? = nil, segmentLength: Int? = nil) {
        self.enableMpegtsM2TsMode = enableMpegtsM2TsMode
        self.maxAudioChannels = maxAudioChannels
        self.audioCodec = audioCodec
        self.container = container
        self.videoCodec = videoCodec
        self.minSegments = minSegments
        self.enableSubtitlesInManifest = enableSubtitlesInManifest
        self.isEstimateContentLength = isEstimateContentLength
        self.protocol = `protocol`
        self.type = type
        self.transcodeSeekInfo = transcodeSeekInfo
        self.isBreakOnNonKeyFrames = isBreakOnNonKeyFrames
        self.context = context
        self.isCopyTimestamps = isCopyTimestamps
        self.segmentLength = segmentLength
    }

    private enum CodingKeys: String, CodingKey {
        case enableMpegtsM2TsMode = "EnableMpegtsM2TsMode"
        case maxAudioChannels = "MaxAudioChannels"
        case audioCodec = "AudioCodec"
        case container = "Container"
        case videoCodec = "VideoCodec"
        case minSegments = "MinSegments"
        case enableSubtitlesInManifest = "EnableSubtitlesInManifest"
        case isEstimateContentLength = "EstimateContentLength"
        case `protocol` = "Protocol"
        case type = "Type"
        case transcodeSeekInfo = "TranscodeSeekInfo"
        case isBreakOnNonKeyFrames = "BreakOnNonKeyFrames"
        case context = "Context"
        case isCopyTimestamps = "CopyTimestamps"
        case segmentLength = "SegmentLength"
    }
}

public enum GroupStateType: String, Codable, CaseIterable {
    case idle = "Idle"
    case waiting = "Waiting"
    case paused = "Paused"
    case playing = "Playing"
}

public struct Version: Codable {
    public var majorRevision: Int?
    public var build: Int?
    public var major: Int?
    public var revision: Int?
    public var minorRevision: Int?
    public var minor: Int?

    public init(majorRevision: Int? = nil, build: Int? = nil, major: Int? = nil, revision: Int? = nil, minorRevision: Int? = nil, minor: Int? = nil) {
        self.majorRevision = majorRevision
        self.build = build
        self.major = major
        self.revision = revision
        self.minorRevision = minorRevision
        self.minor = minor
    }

    private enum CodingKeys: String, CodingKey {
        case majorRevision = "MajorRevision"
        case build = "Build"
        case major = "Major"
        case revision = "Revision"
        case minorRevision = "MinorRevision"
        case minor = "Minor"
    }
}

public struct AuthenticateUserByName: Codable {
    public var password: String?
    public var pw: String?
    public var username: String?

    public init(password: String? = nil, pw: String? = nil, username: String? = nil) {
        self.password = password
        self.pw = pw
        self.username = username
    }

    private enum CodingKeys: String, CodingKey {
        case password = "Password"
        case pw = "Pw"
        case username = "Username"
    }
}

public struct PlaylistCreationResult: Codable {
    public var id: String?

    public init(id: String? = nil) {
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
    }
}

public enum ImageFormat: String, Codable, CaseIterable {
    case bmp = "Bmp"
    case gif = "Gif"
    case jpg = "Jpg"
    case png = "Png"
    case webp = "Webp"
}

public struct GuideInfo: Codable {
    public var endDate: Date?
    public var startDate: Date?

    public init(endDate: Date? = nil, startDate: Date? = nil) {
        self.endDate = endDate
        self.startDate = startDate
    }

    private enum CodingKeys: String, CodingKey {
        case endDate = "EndDate"
        case startDate = "StartDate"
    }
}

public struct ValidatePathDto: Codable {
    public var path: String?
    public var isFile: Bool?
    public var isValidateWritable: Bool?

    public init(path: String? = nil, isFile: Bool? = nil, isValidateWritable: Bool? = nil) {
        self.path = path
        self.isFile = isFile
        self.isValidateWritable = isValidateWritable
    }

    private enum CodingKeys: String, CodingKey {
        case path = "Path"
        case isFile = "IsFile"
        case isValidateWritable = "ValidateWritable"
    }
}

public struct PreviousItemRequestDto: Codable {
    public var playlistItemID: UUID?

    public init(playlistItemID: UUID? = nil) {
        self.playlistItemID = playlistItemID
    }

    private enum CodingKeys: String, CodingKey {
        case playlistItemID = "PlaylistItemId"
    }
}

public struct RemoteImageResult: Codable {
    public var images: [RemoteImageInfo]?
    public var totalRecordCount: Int?
    public var providers: [String]?

    public init(images: [RemoteImageInfo]? = nil, totalRecordCount: Int? = nil, providers: [String]? = nil) {
        self.images = images
        self.totalRecordCount = totalRecordCount
        self.providers = providers
    }

    private enum CodingKeys: String, CodingKey {
        case images = "Images"
        case totalRecordCount = "TotalRecordCount"
        case providers = "Providers"
    }
}

public struct UpdateLibraryOptionsDto: Codable {
    public var libraryOptions: LibraryOptions?
    public var id: UUID?

    public init(libraryOptions: LibraryOptions? = nil, id: UUID? = nil) {
        self.libraryOptions = libraryOptions
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case libraryOptions = "LibraryOptions"
        case id = "Id"
    }
}

public struct StartupRemoteAccessDto: Codable {
    public var enableRemoteAccess: Bool
    public var enableAutomaticPortMapping: Bool

    public init(enableRemoteAccess: Bool, enableAutomaticPortMapping: Bool) {
        self.enableRemoteAccess = enableRemoteAccess
        self.enableAutomaticPortMapping = enableAutomaticPortMapping
    }

    private enum CodingKeys: String, CodingKey {
        case enableRemoteAccess = "EnableRemoteAccess"
        case enableAutomaticPortMapping = "EnableAutomaticPortMapping"
    }
}

public struct VirtualFolderInfo: Codable {
    public var locations: [String]?
    public var refreshStatus: String?
    public var itemID: String?
    public var name: String?
    public var refreshProgress: Double?
    public var libraryOptions: LibraryOptions?
    public var collectionType: CollectionTypeOptions?
    public var primaryImageItemID: String?

    public init(locations: [String]? = nil, refreshStatus: String? = nil, itemID: String? = nil, name: String? = nil, refreshProgress: Double? = nil, libraryOptions: LibraryOptions? = nil, collectionType: CollectionTypeOptions? = nil, primaryImageItemID: String? = nil) {
        self.locations = locations
        self.refreshStatus = refreshStatus
        self.itemID = itemID
        self.name = name
        self.refreshProgress = refreshProgress
        self.libraryOptions = libraryOptions
        self.collectionType = collectionType
        self.primaryImageItemID = primaryImageItemID
    }

    private enum CodingKeys: String, CodingKey {
        case locations = "Locations"
        case refreshStatus = "RefreshStatus"
        case itemID = "ItemId"
        case name = "Name"
        case refreshProgress = "RefreshProgress"
        case libraryOptions = "LibraryOptions"
        case collectionType = "CollectionType"
        case primaryImageItemID = "PrimaryImageItemId"
    }
}

public struct TunerChannelMapping: Codable {
    public var id: String?
    public var name: String?
    public var providerChannelID: String?
    public var providerChannelName: String?

    public init(id: String? = nil, name: String? = nil, providerChannelID: String? = nil, providerChannelName: String? = nil) {
        self.id = id
        self.name = name
        self.providerChannelID = providerChannelID
        self.providerChannelName = providerChannelName
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case providerChannelID = "ProviderChannelId"
        case providerChannelName = "ProviderChannelName"
    }
}

public struct SubtitleProfile: Codable {
    public var language: String?
    public var didlMode: String?
    public var method: SubtitleDeliveryMethod?
    public var container: String?
    public var format: String?

    public init(language: String? = nil, didlMode: String? = nil, method: SubtitleDeliveryMethod? = nil, container: String? = nil, format: String? = nil) {
        self.language = language
        self.didlMode = didlMode
        self.method = method
        self.container = container
        self.format = format
    }

    private enum CodingKeys: String, CodingKey {
        case language = "Language"
        case didlMode = "DidlMode"
        case method = "Method"
        case container = "Container"
        case format = "Format"
    }
}

public struct DirectPlayProfile: Codable {
    public var audioCodec: String?
    public var container: String?
    public var videoCodec: String?
    public var type: DlnaProfileType?

    public init(audioCodec: String? = nil, container: String? = nil, videoCodec: String? = nil, type: DlnaProfileType? = nil) {
        self.audioCodec = audioCodec
        self.container = container
        self.videoCodec = videoCodec
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case audioCodec = "AudioCodec"
        case container = "Container"
        case videoCodec = "VideoCodec"
        case type = "Type"
    }
}

public struct BaseItemDtoQueryResult: Codable {
    public var startIndex: Int?
    public var totalRecordCount: Int?
    public var items: [BaseItemDto]?

    public init(startIndex: Int? = nil, totalRecordCount: Int? = nil, items: [BaseItemDto]? = nil) {
        self.startIndex = startIndex
        self.totalRecordCount = totalRecordCount
        self.items = items
    }

    private enum CodingKeys: String, CodingKey {
        case startIndex = "StartIndex"
        case totalRecordCount = "TotalRecordCount"
        case items = "Items"
    }
}

public struct GroupInfoDto: Codable {
    public var groupName: String?
    public var participants: [String]?
    public var lastUpdatedAt: Date?
    public var groupID: UUID?
    public var state: GroupStateType?

    public init(groupName: String? = nil, participants: [String]? = nil, lastUpdatedAt: Date? = nil, groupID: UUID? = nil, state: GroupStateType? = nil) {
        self.groupName = groupName
        self.participants = participants
        self.lastUpdatedAt = lastUpdatedAt
        self.groupID = groupID
        self.state = state
    }

    private enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case participants = "Participants"
        case lastUpdatedAt = "LastUpdatedAt"
        case groupID = "GroupId"
        case state = "State"
    }
}

public struct ContainerProfile: Codable {
    public var type: DlnaProfileType?
    public var container: String?
    public var conditions: [ProfileCondition]?

    public init(type: DlnaProfileType? = nil, container: String? = nil, conditions: [ProfileCondition]? = nil) {
        self.type = type
        self.container = container
        self.conditions = conditions
    }

    private enum CodingKeys: String, CodingKey {
        case type = "Type"
        case container = "Container"
        case conditions = "Conditions"
    }
}

public enum DeviceProfileType: String, Codable, CaseIterable {
    case system = "System"
    case user = "User"
}

public struct PluginSecurityInfo: Codable {
    public var isMbSupporter: Bool?
    public var supporterKey: String?

    public init(isMbSupporter: Bool? = nil, supporterKey: String? = nil) {
        self.isMbSupporter = isMbSupporter
        self.supporterKey = supporterKey
    }

    private enum CodingKeys: String, CodingKey {
        case isMbSupporter = "IsMbSupporter"
        case supporterKey = "SupporterKey"
    }
}

public struct FileSystemEntryInfo: Codable {
    public var path: String?
    public var type: FileSystemEntryType?
    public var name: String?

    public init(path: String? = nil, type: FileSystemEntryType? = nil, name: String? = nil) {
        self.path = path
        self.type = type
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case path = "Path"
        case type = "Type"
        case name = "Name"
    }
}

public struct QueueItem: Codable {
    public var id: UUID?
    public var playlistItemID: String?

    public init(id: UUID? = nil, playlistItemID: String? = nil) {
        self.id = id
        self.playlistItemID = playlistItemID
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case playlistItemID = "PlaylistItemId"
    }
}

public enum CodecType: String, Codable, CaseIterable {
    case video = "Video"
    case videoAudio = "VideoAudio"
    case audio = "Audio"
}

public struct TrailerInfoRemoteSearchQuery: Codable {
    public var isIncludeDisabledProviders: Bool?
    public var searchInfo: TrailerInfo?
    public var searchProviderName: String?
    public var itemID: UUID?

    public init(isIncludeDisabledProviders: Bool? = nil, searchInfo: TrailerInfo? = nil, searchProviderName: String? = nil, itemID: UUID? = nil) {
        self.isIncludeDisabledProviders = isIncludeDisabledProviders
        self.searchInfo = searchInfo
        self.searchProviderName = searchProviderName
        self.itemID = itemID
    }

    private enum CodingKeys: String, CodingKey {
        case isIncludeDisabledProviders = "IncludeDisabledProviders"
        case searchInfo = "SearchInfo"
        case searchProviderName = "SearchProviderName"
        case itemID = "ItemId"
    }
}

public struct LibraryUpdateInfo: Codable {
    public var foldersAddedTo: [String]?
    public var collectionFolders: [String]?
    public var itemsAdded: [String]?
    public var foldersRemovedFrom: [String]?
    public var isEmpty: Bool?
    public var itemsUpdated: [String]?
    public var itemsRemoved: [String]?

    public init(foldersAddedTo: [String]? = nil, collectionFolders: [String]? = nil, itemsAdded: [String]? = nil, foldersRemovedFrom: [String]? = nil, isEmpty: Bool? = nil, itemsUpdated: [String]? = nil, itemsRemoved: [String]? = nil) {
        self.foldersAddedTo = foldersAddedTo
        self.collectionFolders = collectionFolders
        self.itemsAdded = itemsAdded
        self.foldersRemovedFrom = foldersRemovedFrom
        self.isEmpty = isEmpty
        self.itemsUpdated = itemsUpdated
        self.itemsRemoved = itemsRemoved
    }

    private enum CodingKeys: String, CodingKey {
        case foldersAddedTo = "FoldersAddedTo"
        case collectionFolders = "CollectionFolders"
        case itemsAdded = "ItemsAdded"
        case foldersRemovedFrom = "FoldersRemovedFrom"
        case isEmpty = "IsEmpty"
        case itemsUpdated = "ItemsUpdated"
        case itemsRemoved = "ItemsRemoved"
    }
}

public struct SongInfo: Codable {
    public var albumArtists: [String]?
    public var metadataLanguage: String?
    public var album: String?
    public var parentIndexNumber: Int?
    public var artists: [String]?
    public var metadataCountryCode: String?
    public var isAutomated: Bool?
    public var name: String?
    public var path: String?
    public var providerIDs: [String: String]?
    public var indexNumber: Int?
    public var premiereDate: Date?
    public var year: Int?

    public init(albumArtists: [String]? = nil, metadataLanguage: String? = nil, album: String? = nil, parentIndexNumber: Int? = nil, artists: [String]? = nil, metadataCountryCode: String? = nil, isAutomated: Bool? = nil, name: String? = nil, path: String? = nil, providerIDs: [String: String]? = nil, indexNumber: Int? = nil, premiereDate: Date? = nil, year: Int? = nil) {
        self.albumArtists = albumArtists
        self.metadataLanguage = metadataLanguage
        self.album = album
        self.parentIndexNumber = parentIndexNumber
        self.artists = artists
        self.metadataCountryCode = metadataCountryCode
        self.isAutomated = isAutomated
        self.name = name
        self.path = path
        self.providerIDs = providerIDs
        self.indexNumber = indexNumber
        self.premiereDate = premiereDate
        self.year = year
    }

    private enum CodingKeys: String, CodingKey {
        case albumArtists = "AlbumArtists"
        case metadataLanguage = "MetadataLanguage"
        case album = "Album"
        case parentIndexNumber = "ParentIndexNumber"
        case artists = "Artists"
        case metadataCountryCode = "MetadataCountryCode"
        case isAutomated = "IsAutomated"
        case name = "Name"
        case path = "Path"
        case providerIDs = "ProviderIds"
        case indexNumber = "IndexNumber"
        case premiereDate = "PremiereDate"
        case year = "Year"
    }
}

public enum RepeatMode: String, Codable, CaseIterable {
    case repeatNone = "RepeatNone"
    case repeatAll = "RepeatAll"
    case repeatOne = "RepeatOne"
}

public struct PlaybackInfoDto: Codable {
    public var allowAudioStreamCopy: Bool?
    public var subtitleStreamIndex: Int?
    public var userID: UUID?
    public var maxStreamingBitrate: Int?
    public var isAutoOpenLiveStream: Bool?
    public var liveStreamID: String?
    public var allowVideoStreamCopy: Bool?
    public var enableDirectPlay: Bool?
    public var maxAudioChannels: Int?
    public var enableDirectStream: Bool?
    public var audioStreamIndex: Int?
    public var mediaSourceID: String?
    public var startTimeTicks: Int?
    public var deviceProfile: DeviceProfile?
    public var enableTranscoding: Bool?

    public init(allowAudioStreamCopy: Bool? = nil, subtitleStreamIndex: Int? = nil, userID: UUID? = nil, maxStreamingBitrate: Int? = nil, isAutoOpenLiveStream: Bool? = nil, liveStreamID: String? = nil, allowVideoStreamCopy: Bool? = nil, enableDirectPlay: Bool? = nil, maxAudioChannels: Int? = nil, enableDirectStream: Bool? = nil, audioStreamIndex: Int? = nil, mediaSourceID: String? = nil, startTimeTicks: Int? = nil, deviceProfile: DeviceProfile? = nil, enableTranscoding: Bool? = nil) {
        self.allowAudioStreamCopy = allowAudioStreamCopy
        self.subtitleStreamIndex = subtitleStreamIndex
        self.userID = userID
        self.maxStreamingBitrate = maxStreamingBitrate
        self.isAutoOpenLiveStream = isAutoOpenLiveStream
        self.liveStreamID = liveStreamID
        self.allowVideoStreamCopy = allowVideoStreamCopy
        self.enableDirectPlay = enableDirectPlay
        self.maxAudioChannels = maxAudioChannels
        self.enableDirectStream = enableDirectStream
        self.audioStreamIndex = audioStreamIndex
        self.mediaSourceID = mediaSourceID
        self.startTimeTicks = startTimeTicks
        self.deviceProfile = deviceProfile
        self.enableTranscoding = enableTranscoding
    }

    private enum CodingKeys: String, CodingKey {
        case allowAudioStreamCopy = "AllowAudioStreamCopy"
        case subtitleStreamIndex = "SubtitleStreamIndex"
        case userID = "UserId"
        case maxStreamingBitrate = "MaxStreamingBitrate"
        case isAutoOpenLiveStream = "AutoOpenLiveStream"
        case liveStreamID = "LiveStreamId"
        case allowVideoStreamCopy = "AllowVideoStreamCopy"
        case enableDirectPlay = "EnableDirectPlay"
        case maxAudioChannels = "MaxAudioChannels"
        case enableDirectStream = "EnableDirectStream"
        case audioStreamIndex = "AudioStreamIndex"
        case mediaSourceID = "MediaSourceId"
        case startTimeTicks = "StartTimeTicks"
        case deviceProfile = "DeviceProfile"
        case enableTranscoding = "EnableTranscoding"
    }
}

public struct SetPlaylistItemRequestDto: Codable {
    public var playlistItemID: UUID?

    public init(playlistItemID: UUID? = nil) {
        self.playlistItemID = playlistItemID
    }

    private enum CodingKeys: String, CodingKey {
        case playlistItemID = "PlaylistItemId"
    }
}

public struct MovieInfoRemoteSearchQuery: Codable {
    public var searchInfo: MovieInfo?
    public var itemID: UUID?
    public var isIncludeDisabledProviders: Bool?
    public var searchProviderName: String?

    public init(searchInfo: MovieInfo? = nil, itemID: UUID? = nil, isIncludeDisabledProviders: Bool? = nil, searchProviderName: String? = nil) {
        self.searchInfo = searchInfo
        self.itemID = itemID
        self.isIncludeDisabledProviders = isIncludeDisabledProviders
        self.searchProviderName = searchProviderName
    }

    private enum CodingKeys: String, CodingKey {
        case searchInfo = "SearchInfo"
        case itemID = "ItemId"
        case isIncludeDisabledProviders = "IncludeDisabledProviders"
        case searchProviderName = "SearchProviderName"
    }
}

public struct SpecialViewOptionDto: Codable {
    public var id: String?
    public var name: String?

    public init(id: String? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
    }
}

public struct LibraryOptionsResultDto: Codable {
    public var typeOptions: [LibraryTypeOptionsDto]?
    public var metadataSavers: [LibraryOptionInfoDto]?
    public var metadataReaders: [LibraryOptionInfoDto]?
    public var subtitleFetchers: [LibraryOptionInfoDto]?

    public init(typeOptions: [LibraryTypeOptionsDto]? = nil, metadataSavers: [LibraryOptionInfoDto]? = nil, metadataReaders: [LibraryOptionInfoDto]? = nil, subtitleFetchers: [LibraryOptionInfoDto]? = nil) {
        self.typeOptions = typeOptions
        self.metadataSavers = metadataSavers
        self.metadataReaders = metadataReaders
        self.subtitleFetchers = subtitleFetchers
    }

    private enum CodingKeys: String, CodingKey {
        case typeOptions = "TypeOptions"
        case metadataSavers = "MetadataSavers"
        case metadataReaders = "MetadataReaders"
        case subtitleFetchers = "SubtitleFetchers"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
